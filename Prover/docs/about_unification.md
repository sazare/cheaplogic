# Unificationと代入の分類と関係
## 概要
Substitution(代入)の2つのアルゴリズムの機能と計算量について考える。
Unificationアルゴリズムには2つの代入が使われている。
代入の違いによるUnificationの違いというものはあるのか?
証明や証明のトライアル全体の計算量を考えることについても触れる。

代入のアルゴリズムが何種類あるとかUnificationがそれによってどう違ってくるとかいう話は聞いたことがないので、考え方だけでもここに書いておきたいという意図。

## 代入
代入を考えるためには「表現」の定義が必要だが、ここではLISPのS式のようなものを考えておくので十分だと思う。
最初にSymbol(Atom)があり、それから表現を次のように定義する。

```
定義:表現
Expr = Symbol | (Symbol . Expr*)
Expr* = () | (Expr . Expr*)
```
SymbolでないExprのことをC-Exprと呼ぶ。

```
定義: 表現に出現する記号
S(e) = 表現sに登場するすべてのSymbolからなる集合
```

また、部分表現を次のように表記する。

```
表記:部分表現
e1 < e2
表現e1は表現e2の一部として出現している
```

Symbolを変数と定数に区別したくなるが、それはUnificationのときに考える。

### 基本代入
基本代入といっているのは1つのSymbolに対する代入のことで、次のように表記する。

```
定義:基本代入
基本代入 = [s ← e]
sはSymbol, eはExprとする。
```

この操作の意味は、表現eに対する代入σ={x ← e1}の適用操作(*)で定義される。

```
定義:基本代入の適用
e*σ = e1 when eがSymbolで、e=x
      e  eがSymbolで、e!=x
      (s e1*σ e2*σ ... ek*σ) when e=(s e1 e2 ... ek)
```

LISPにはsubst()という関数があるが、これは(subst e1 x e)のようなインターフェースで、表現の中をどうトラバースするのかは気にしない。
だから、それをもとに代入関数を作ると、この定義とは違うものになる。

### 代入
基本代入は要素が1つしかないが、複数の要素があるものを「代入」と呼ぶ。
代入の表記を二種類考える。

```
表記: 代入
直列型: σ=[s1←e1, s2←e2, ..., sk←ek]
並列型: σ=[s1,s2,...,sk]←[e1,e2,...,ek]
```

代入を対象とする次の関数も使う。
```
L(σ) = {s1,s2,...,sk}
R(σ) = {e1,e2,...,ek}
```


表現に対する代入の適用を次のように定義する。

#### 適用1
表現に対する直列型の代入の適用を次のように定義する。
```
定義:適用1
σ=[σ1,σ2,...,σk]とすると、
e*σ=((...(e*σ1)*σ2)*...*σk)
```

```
例
σ1=[x←a, y←f(x)]
σ2=[y←f(x), x←a]
e1=(x y)
```
とすると
```
e1*σ1 = (a f(x))
e2*σ2 = (a f(a))
```
となる。
この結果の違いは、表現eを作業台として、x←aが圧縮(queezeと呼びたい)されたからと考えられる。

### 適用2
表現eに対する並列型の代入の適用は次のように定義する。

```
定義:適用2
eは表現、代入σは
σ=[s1,s2,...,sk]←[e1,e2,...,ek]
とする。このとき、

e@σ = ei when eがSymbolであり、si=e
      e  when eがSymbolであり、eに一致するsiが存在しない
      (s e1@σ e2@σ ... ek@σ) when e=(s e1 e2 ... ek)のとき

si=eとなるsiが複数存在したら、その中のひとつを選ぶことにしておく。
たぶん最初にみつかったsiになるだろう。
```
@は基本代入の適用を並列に行う操作と考えられる。

```
例
σ1=[x,y]←[a,f(x)]
σ2=[y,x]←[f(x),a]
e1=(x y)
```
の場合
```
e1@σ1 = (a f(x))
e2@σ2 = (a f(x))
```
*のときのような代入要素の圧縮はおきない。
また、代入の表記の順番をかえても結果は変わらない。

このことから、+で代入を実行する場合、圧縮された結果が必要ならば、使用する代入表現がもともと圧縮されていなくてはならない。

直列型の表記で、適用2を行うこともできるが、区別しやすくしたかったのでこうした。

### 代入を代入に適用する

```
定義: 代入同士の適用(操作的定義)
σ1とσ2を代入とする。
σ1=[σ11,σ12,...,σ1k]
σ2=[σ21,σ22,...,σ2m]
とする。
このとき、代入間の演算*を次のように定義する。

σ1*σ2 = [s1i←e1i*σ2, s2p←e2p]
要素は2つのパターンの要素からなり、
ここで、iは1からk、s2pはL(σ2)-S(L(σ2))の要素から選ぶ。
```
つまり、σ1の要素については、si←ei*σ2とし、σ2の要素についてはσ1のLにないものだけを選んでできる代入である。

この定義によって
```
定義:代入の同値〜
代入σ1、σ2について
σ1~σ2 を
任意の表現eについて e*σ1 = e*σ2 が成り立つことと定義する
```

```
定義:代入の同値∽
代入σ1、σ2について
σ1∽σ2 を
任意の表現eについて e@σ1 = e@σ2 が成り立つことと定義する

#### 
まだ証明していないが、次は成り立つか
1. σ1とσ2は要素の順番を入れ替えても同値になる
2. 

#### 
- e@σ1 = e@σ2だとどうか
- []←[]タイプの代入と[←]タイプの代入を掛け合わせるときはどうなるか


### 補足

ρ1=[x,y]←[y,x]
ρ2=[x←y]
ρ2'=[y←x]
e=(x,y)

を考えてみる。
ρ1は、xとyを入れ替えるので
e@ρ1 = (y,x) 
となる。

ρ2とρ2'は、代入の左右を入れ替えた表現であり、逆元のようにかんじられるが実際にeに適用してみると
e*ρ1*ρ1' = (x,x)
e*ρ1'*ρ1 = (y,y)

となりeには戻らないので、逆元ではない。


## Unification

```
定義: Unifier
与えられた表現e1,e2について、次の条件を満たす代入σをe1とe2のunifierと呼ぶ。
e1*σ = e2*σ
```
unifierは、変数どうしの代入要素がある場合、その変数を入れ替えてもunifierになるので、表現上一意に決まるわけではない。

また
```
定義: most general unifier(mgu)
表現e1,e2について、次の条件を満たすUnifier σをmost general unifier(mgu)と呼ぶ。

任意のユニファイアー μ について、代入τが存在し、
μ = σ*τ
となる
```

Unificationという操作は次のように定義する。
```
定義:Unification
Unificationは、二つの表現e1,e2が与えられた時、それらのmguを求める操作/アルゴリズムのことである。
この資料では、Unificationを次のように表記する。

μ = <e1:e2>
```

* ここで変数が登場する。
変数はSymbolの一部であり、代入の左側に出現できる。
L(σ)以外の変数も存在しうる。
変数をどのようにUnificationに知らせるかはいろいろな方法が考えられる。

理論では、単純に変数全体の集合(や定数の集合)を与え、それによって変数を決めることが行われるようだが、コードを書く場合は、それにあわせて、globalな変数に変数を定義するとか、あいはSymbolの文字列に含まれる特別な記号で判定するとか、Symbolのproperty(map, dictionalyなど)として変数かどうかの判定条件を持つとか、あるいはe1とe2に属する変数のリストを与えるとかがありうる。

ここでは、実装の詳細にはまだ踏み込まない。

Unificationは、次のようなアルゴリズムが知られている。
```
1. μ = []
2. e1,e2のdisagreement set(*1) δ(e1,e2)=(d1,d2)を求める
3. d1,d2から基本代入が作れるならそれをσiとする。
　　つくれなければ(*2)、Unificationは失敗で、ここで処理は終わる。
4. e1,e2 := e1△σ1, e2△σ2とする。
5. μ = μ ○ σ1 として、mguを拡張する。
6. 2に戻る。

ここで、step 4の代入操作△は表現x基本代入の操作であり、*が使われる。

*1) d1<e1, d2<e2であり、d1!=d2となる極大の部分表現。
　- d1,d2がともにSymbolである。ということは、異なるSymbolである。
　- d1,d2のどちらかがSymbolでもう片方がC-Exprの場合。
　- e1,e2がともにC-Exprであり、d1=(s1 e1i,...), d2=(s2 e2i,...)
　　s1==s2の場合は、i=1からkの順にδ(e1i, e2i)の中で最初に(d1,d2)が求められたらその値。
  - それ以外のd1!=d2の場合は(d1,d2)

*2) 基本代入が作れるか作れないかの基準
  - d1,d2の一方が変数の場合。例えばd1が変数だとすると、
  - d1 < d2 なら失敗(このテストはinside check(*3)と呼ぶ)
　- そうでなければσi=[d1←d2]

*3) inside checkについては後で改めて考える。
```

#### Unificationの△と○
unifictionでは、つぎの2つの部分で代入適用を行う。
1. σiを|e1>と|e2>に適用する。(表現△代入)
2. mgu:=mgu*σi (代入○代入)

1の代入適用は、要素代入の適用なので*になる。表現が介在するので、圧縮がおき、処理の順番による結果の違いはない。

2の代入適用は、代入どうしの適用なので、表現を介するsqueezeができない。
 *によって、処理の順序に依存しないmguの表現を求めることができる。


#### 例
Unificationアルゴリズムでは、単純化のためか、σiの適用は元のei全体を対象としている。
実際には、直前のδを含む左側の部分はすでに同一になっているので、δよりも右側の部分だけにσiを適用すればよい。
そこで、直前のδから右側だけを表す表記を用いることにする。

```
例
e1 = f(x, h(y) g(k(x)))
e2 = f(a, h(z), g(w))

0. mgu=[]
<e1:e2>=|f(x, h(y) g(k(x))):
1. δ1 = (x:a) => σ1 = [x←a]
mgu=mgu*σ1=[x←a]
| h(y) g(k(a))):|h(z), g(w))
2. δ2 = (y,z) => σ2 = [y←z]
mgu=mgu*σ2=[x←a, y←z]
| g(k(a))):|g(w))
3. δ3 = (k(a),w) => [w←k(a)]
mgu=mgu*σ3=[x←a, y←z, w←k(a)]
|):|)
4. δ4 = () => end
mgu=x←a, y←z, w←k(a)]
end

```

```
例2
e1 = f(x, h(y) g(h(y)))
e2 = f(a, h(z), g(w))
```

### 計算量
ここでは、計算量について簡単に検討する。

#### 代入の計算量
#### 基本代入　e*σ
- eの全Symbolに対してσが適用できるかどうかを判定する必要がある。
- ある記号を置換したら、eの中の同じ記号についても置換されていれば効率がよいが、そううまくはいかない。
　とはいえ、置換にかかる計算量はO(0)とみなすとする。

```
定義: 記号数‖e‖
表現eのSymbolの重複を含めた数を‖e‖で表すとする

定義: 代入の長さ|σ|
|σ|は、σの要素数
```

```
基本代入の計算量
 代入操作の計算量O(e*σ)は
O(e*σ) ∝ ‖e‖
```

```
直列代入の計算量
σが直列型の代入であるとして、e*σの計算量は次のように近似できる。
O(e*σ) ∝ ‖e‖*|σ|

σの全要素について、基本代入の*を実行する必要がある
代入操作の途中にeの形がかわり、δが増えるので、もっと多くなるので、おおまかな近似になる。
```

```
並列代入の計算量
σが並列型の代入であるとすると、eiに対するsjの代入はおきないので、σの平均的なヒット回数は|σ|/2だから、
O(e@σ) ∝ ‖e‖*|σ|/2
```

```
代入演算σ+τの計算量
並列演算の場合は、siとsjに同じものがあるかどうかの判定、τのかく要素がσに含まれるかどうかの処理の計算量になる。

O(σ+τ) ∝ |σ|*|τ|
```





#### unificationの代入計算量

### Resolutionの中での代入
2つのclause C1, C2が与えられた時のresolutionを考える。

C1 = +L1 ∨ C1'
C2 = -L2 ∨ C2'

ならば、mgu σ=<L1:L2>をもとめ、R=(C1'∨C2')○σによってresolventを作る。

σの計算では、
1) リテラルL1とL2の引数の数の中で小さいほうの数をmaxとした回数(n)の比較が行われる
   対応するeiで変数でないほうの数
　ただし、x←eのeがdisagreeの検索対象になると数がふえる。

'''
例
x,yを変数として
a) <f(x,h(x)):f(g(b),h(g(a)))>
と
でのdisagreeをみると

a)では、δ1=(x,b)⇨[x←b]なので
左のh(x)がh(b)となり、h(g(a))と比較できるようになり
|h(g(b)):|h(g(a)))⇨(b,a)となりNOにはなるが
この左側の第二引数のような変化がこれになる。

成功する場合は
b) <f(x,h(x)):f(g(y),h(g(a)))>
もあるが、処理上は同じような推移になる。
'''

2) 代入の適用は、最大n^2/2回行われる。

3) 代入同士の適用は、n回行われる。

1+2の回数と比較して3の回数が少ないので、こちらはe*σの計算でもよい。(???)
1+2は表現が作業台になるので、*でよい。(???)


Rに対するL*σの計算は
Rのリテラルの個数x各リテラルの要素表現の数だけ行われる。


### 証明の中での代入の回数
未


### 失敗した証明ステップ(resolution)を含めて、期待されるステップ数
未


