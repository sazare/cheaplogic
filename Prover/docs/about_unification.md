# Unificationと代入の分類と関係
## 概要
Substitution(代入)の2つのアルゴリズムの機能と計算量について考える。
Unificationアルゴリズムには2つの代入が使われている。
代入の違いによるUnificationの違いというものはあるのか?
証明や証明のトライアル全体の計算量を考えることについても触れる。

代入のアルゴリズムが何種類あるとかUnificationがそれによってどう違ってくるとかいう話は聞いたことがないので、考え方だけでもここに書いておきたいという意図。

## 代入
代入を考えるためには「表現」の定義が必要だが、ここではLISPのS式のようなものを考えておくので十分だと思う。
最初にSymbol(Atom)があり、それから表現を次のように定義する。

```
定義:表現
Expr = Symbol | (Symbol . Expr*)
Expr* = () | (Expr . Expr*)
```
SymbolでないExprのことをC-Exprと呼ぶ。

```
定義: 表現に出現する記号
S(e) = 表現sに登場するすべてのSymbolからなる集合
```

また、部分表現を次のように表記する。

```
表記:部分表現
e1 < e2
表現e1は表現e2の一部として出現している
```

Symbolを変数と定数に区別したくなるが、それはUnificationのときに考える。

### 基本代入
基本代入といっているのは1つのSymbolに対する代入のことで、次のように表記する。

```
定義:基本代入
基本代入 = [s ← e]
sはSymbol, eはExprとする。
```

この操作の意味は、表現eに対する代入σ={x ← e1}の適用操作(*)で定義される。

```
定義:基本代入の適用
e*σ = e1 when eがSymbolで、e=x
      e  eがSymbolで、e!=x
      (s e1*σ e2*σ ... ek*σ) when e=(s e1 e2 ... ek)
```

LISPにはsubst()という関数があるが、これは(subst e1 x e)のようなインターフェースで、表現の中をどうトラバースするのかは気にしない。
だから、それをもとに代入関数を作ると、この定義とは違うものになる。

### 代入
基本代入は要素が1つしかないが、複数の要素があるものを「代入」と呼ぶ。
代入の表記を二種類考える。

```
表記: 代入
直列型: σ=[s1←e1, s2←e2, ..., sk←ek]
並列型: σ=[s1,s2,...,sk]←[e1,e2,...,ek]
```

代入を対象とする次の関数も使う。
```
L(σ) = {s1,s2,...,sk}
R(σ) = {e1,e2,...,ek}
```


表現に対する代入の適用を次のように定義する。

#### 適用1
表現に対する直列型の代入の適用を次のように定義する。
```
定義:適用1
σ=[σ1,σ2,...,σk]とすると、
e*σ=((...(e*σ1)*σ2)*...*σk)
```

```
例
σ1=[x←a, y←f(x)]
σ2=[y←f(x), x←a]
e1=(x y)
```
とすると
```
e1*σ1 = (a f(x))
e2*σ2 = (a f(a))
```
となる。
この結果の違いは、表現eを作業台として、x←aが圧縮(queezeと呼びたい)されたからと考えられる。

### 適用2
表現eに対する並列型の代入の適用は次のように定義する。

```
定義:適用2
eは表現、代入σは
σ=[s1,s2,...,sk]←[e1,e2,...,ek]
とする。このとき、

e@σ = ei when eがSymbolであり、si=e
      e  when eがSymbolであり、eに一致するsiが存在しない
      (s e1@σ e2@σ ... ek@σ) when e=(s e1 e2 ... ek)のとき

si=eとなるsiが複数存在したら、その中のひとつを選ぶことにしておく。
たぶん最初にみつかったsiになるだろう。
```
@は基本代入の適用を並列に行う操作と考えられる。

```
例
σ1=[x,y]←[a,f(x)]
σ2=[y,x]←[f(x),a]
e1=(x y)
```
の場合
```
e1@σ1 = (a f(x))
e2@σ2 = (a f(x))
```
*のときのような代入要素の圧縮はおきない。
また、代入の表記の順番をかえても結果は変わらない。

このことから、+で代入を実行する場合、圧縮された結果が必要ならば、使用する代入表現がもともと圧縮されていなくてはならない。

直列型の表記で、適用2を行うこともできるが、区別しやすくしたかったのでこうした。

### 代入を代入に適用する

```
定義: 代入同士の適用(操作的定義)
σ1とσ2を代入とする。
σ1=[σ11,σ12,...,σ1k]
σ2=[σ21,σ22,...,σ2m]
とする。
このとき、代入間の演算*を次のように定義する。

σ1*σ2 = [s1i←e1i*σ2, s2p←e2p]
要素は2つのパターンの要素からなり、
ここで、iは1からk、s2pはL(σ2)-S(L(σ2))の要素から選ぶ。
```
つまり、σ1の要素については、si←ei*σ2とし、σ2の要素についてはσ1のLにないものだけを選んでできる代入である。

この定義によって
```
定義:代入の同値〜
代入σ1、σ2について
σ1~σ2 を
任意の表現eについて e*σ1 = e*σ2 が成り立つことと定義する
```

```
定義:代入の同値∽
代入σ1、σ2について
σ1∽σ2 を
任意の表現eについて e@σ1 = e@σ2 が成り立つことと定義する

#### 
まだ証明していないが、次は成り立つか
1. σ1とσ2は要素の順番を入れ替えても同値になる
2. 

#### 
- []←[]タイプの代入と[←]タイプの代入を掛け合わせるときは行列みたいに書かれるのか
　あるいは行列式?


### 補足

ρ1=[x,y]←[y,x]
ρ2=[x←y]
ρ2'=[y←x]
e=(x,y)

を考えてみる。
ρ1は、xとyを入れ替えるので
e@ρ1 = (y,x) 
となる。
また、機械的に作ったρ1'=[y,x]←[x,y]は逆元だが、そもそも並行代入なのでこの順番に意味はないので、ふたつの表現は同値である。
コードにするとき、同値の代入が複数あると面倒だが、左の変数でソートしておけば、解決する。毎回ソートするのでなく比較するときだけソートする。

ρ2とρ2'は、代入の左右を入れ替えた表現であり、逆元のようにかんじられるが実際にeに適用してみると
e*ρ1*ρ1' = (x,x)
e*ρ1'*ρ1 = (y,y)

となりeには戻らないので、逆元ではない。


## Unification

```
定義: Unifier
与えられた表現e1,e2について、次の条件を満たす代入σをe1とe2のunifierと呼ぶ。
e1*σ = e2*σ
```
unifierは、変数どうしの代入要素がある場合、その変数を入れ替えてもunifierになるので、表現上一意に決まるわけではない。

また
```
定義: most general unifier(mgu)
表現e1,e2について、次の条件を満たすUnifier σをmost general unifier(mgu)と呼ぶ。

任意のユニファイアー μ について、代入τが存在し、
μ = σ*τ
となる
```

Unificationという操作は次のように定義する。
```
定義:Unification
Unificationは、二つの表現e1,e2が与えられた時、それらのmguを求める操作/アルゴリズムのことである。
この資料では、Unificationを次のように表記する。

μ = <e1:e2>
```

* ここで変数が登場する。
変数はSymbolの一部であり、代入の左側に出現できる。
L(σ)以外の変数も存在しうる。
変数をどのようにUnificationに知らせるかはいろいろな方法が考えられる。

理論では、単純に変数全体の集合(や定数の集合)を与え、それによって変数を決めることが行われるようだが、コードを書く場合は、それにあわせて、globalな変数に変数を定義するとか、あいはSymbolの文字列に含まれる特別な記号で判定するとか、Symbolのproperty(map, dictionalyなど)として変数かどうかの判定条件を持つとか、あるいはe1とe2に属する変数のリストを与えるとかがありうる。
また、unificationの場合は、e1,e2にのみ登場する変数のリストにするかとか、e1、e2のそれぞれが変数リストを持つとか、実装の幅はいろいろある。

ここでは、実装の詳細にはまだ踏み込まない。

Unificationは、次のようなアルゴリズムが知られている。
```
1. μ = []
2. e1,e2のdisagreement set(*1) δ(e1,e2)=(d1,d2)を求める
3. d1,d2から基本代入が作れるならそれをσiとする。
　　つくれなければ(*2)、Unificationは失敗で、ここで処理は終わる。
4. e1,e2 := e1△σi, e2△σiとする。(*4)
5. μ = μ ○ σi として、mguを拡張する。
6. iを1増加して、2に戻る。

ここで、step 4の代入操作△は表現x基本代入の操作であり、*が使われる。

*1) d1<e1, d2<e2であり、d1!=d2となる極大の部分表現。
　- d1,d2がともにSymbolである。ということは、異なるSymbolである。
　- d1,d2のどちらかがSymbolでもう片方がC-Exprの場合。
　- e1,e2がともにC-Exprであり、d1=(s1 e1i,...), d2=(s2 e2i,...)
　　s1==s2の場合は、i=1からkの順にδ(e1i, e2i)の中で最初に(d1,d2)が求められたらその値。
  - それ以外のd1!=d2の場合は(d1,d2)

*2) 基本代入が作れるか作れないかの基準
  - d1,d2の一方が変数の場合。例えばd1が変数だとすると、
  - d1 < d2 なら失敗(このテストはinside check(*3)と呼ぶ)
　- そうでなければσi=[d1←d2]

*3) inside checkについては後で改めて考える。

*4) e1,e2全体にσiをかけるが、実際には、d1,d2の出現する箇所の左側についてはすでに同一になっているので、σiを適用する必要はない。
　同一になった部分を除いた、表現eの一部(表現ではない)を|tのように書くことにする。
```

#### Unificationの△と○
unifictionでは、つぎの2つの部分で代入適用を行う。
1. σiを|e1と|e2に適用する。(表現△代入)
2. mgu:=mgu*σi (代入○代入)

1の代入適用は、要素代入の適用なので*になる。表現が介在するので、圧縮がおき、処理の順番による結果の違いはない。

2の代入適用は、代入どうしの適用なので、表現を介するsqueezeができない。
 *によって、処理の順序に依存しないmguの表現を求めることができる。


#### 例

```
例1i
e1 = f(x,x)
e2 = f(y,a)

δσ: (x,y)⇨[x←y];(y,a)⇨[y←a]
+ => [x,y]←[y,a] △
* => [x←a,y←a] ○
```

```
例1ii
e1 = f(x,x)
e2 = f(a,y)

δσ: (x,a)⇨[x←a];(a,y)⇨[y←a]
+ => [x,y]←[a,a] ○
* => [x←a, y←a] ○
```
これは、関数記号の有無とは関係なく、変数の出現順序にのみ依存する。


```
例1a
e1 = f(x,f(x))
e2 = f(y,f(a))

例1b
e1 = f(f(x),x)
e2 = f(f(a),y)

```


Unificationアルゴリズムのステップの詳細を書く場合、σiの適用は元のei全体を対象でなく、
直前のδを含む左側の部分はすでに同一になっているので、δよりも右側の部分だけにσiを適用すればよい。
(理論的には常に元のe1,e2にかければよい)
そこで、直前のδから右側だけを表す表記を用いることにする。
```
例2
e1 = f(x, h(y), g(k(x)))
e2 = f(a, h(z), g(w))

0. mgu=[]
<e1:e2>=|f(x, h(y) g(k(x))):|f(a, h(z), g(w))
1. δ1 = (x:a) => σ1 = [x←a]
mgu=mgu*σ1=[x←a]
|a,h(y), g(k(a))):|a,h(z), g(w))
2. δ2 = (y,z) => σ2 = [y←z]
mgu=mgu*σ2=[x←a, y←z]
|h(z),g(k(a))):|h(z),g(w))
3. δ3 = (k(a),w) => [w←k(a)]
mgu=mgu*σ3=[x←a, y←z, w←k(a)]
|):|)
4. δ4 = () => end
mgu=x←a, y←z, w←k(a)]
end

```

```
例2a
e1 = f(g(k(x)),h(y),x)
e2 = f(g(w),h(z),a)
```

### 計算量
ここでは、計算量について簡単に検討する。

#### 代入の計算量
#### 基本代入　e*σ
- eの全Symbolに対してσが適用できるかどうかを判定する必要がある。

```
定義: 記号数‖e‖
表現eのSymbolの重複を含めた数を‖e‖で表すとする

定義: 代入の長さ|σ|
|σ|は、σの要素数
```

eにσを適用するのにかかる時間は定数だとしよう。

```
基本代入の計算量
 代入操作の計算量O(e*σ)は
O(e*σ) ∝ ‖e‖
```


```
直列代入の計算量
σが直列型の代入であるとして、e*σの計算量は次のように近似できる。
O(e*σ) ∝ ‖e‖*|σ|

σの全要素について、基本代入の*を実行する必要がある。
代入操作の途中にeの形がかわり、δが増えるので、具体的な回数はもっと多くなるだろう。
```

```
並列代入の計算量
σが並列型の代入であるとすると、eiに対するsjの代入はおきないので、σの平均的なヒット回数は|σ|/2だから、
O(e@σ) ∝ ‖e‖*|σ|/2 ∝ ‖e‖
ではないか
```
並列代入はeのSymbolの数で抑えられるが、直列代入は代入が累積するので計算量のコストは大きい。
n=‖e‖としm=|σ|とすると、オーダーは O(n*m)なのかもしれない。

```
代入演算σ+τの計算量
並列演算の場合は、siとsjに同じものがあるかどうかの判定、τのかく要素がσに含まれるかどうかの処理の計算量になる。

O(σ+τ) ∝ |σ|
和集合の計算量と同じ程度だろう
```
```
代入演算σ1*σ2の計算量
O(e1i*σ2)+|σ1|*|σ2|
第一項は、σ1の要素の右側にσ2をかける処理分
第二項は、σ2からσ1にない要素を選ぶ処理分
```

前提として、代入表現が圧縮されている場合は*を使う必要がない。同じ結果になるということ。
そして、圧縮された表現の代入を+や@で合成すると、その結果も圧縮されていればよいが、どうだろうか。

単一代入にはそもそも圧縮非圧縮の区別はないが、σ1,σ2,...,σkという列については圧縮と同等の概念がある。

#### unificationの代入計算量
unificationでは、e*σとmguを集約するμ○σiの処理が主に時間を消費する。

e*σについては、σ1,σ2,...,σkの間に圧縮の性質は期待できない。
しかし、このアルゴリズムで求めるものはmgu(μ)であり、e*σの部分はe1とe2が等しくなっていることがわかればよいので@で十分である。

○については、+を使うか*を使うかの選択肢があるが、○によって非圧縮形式のσをかけあわせた結果、μは圧縮形式になっている必要があるので、*を使うしかない。

以上から、途中で失敗することがない場合、Unification全体の計算量は、μ*σiの計算量で抑えられ、σiの個数はδの個数に等しい。

mguの計算では+を使い、これ以外の代入計算で*を使うという選択肢もある。
どちらがよいかは、それぞれの回数による。
unificationでの○の回数は、δの個数であるが、resolventを作成するときの代入の回数は次のとおり。
同じmguを何回代入することになるのかが問題なので、次のようになる。
ここでは、mgu作成に失敗した回数は考慮していない。

### Resolutionの中での代入
2つのclause C1, C2が与えられた時のresolutionを考える。

C1 = +L1 ∨ C1'
C2 = -L2 ∨ C2'

ならば、mgu σ=<L1:L2>をもとめ、R=(C1'∨C2')○σによってresolventを作る。

だから、N=|C1|+|C2|-2 回、リテラルに対する代入が発生する。
この回数Nと、<L1:L2>でmguを蓄積する場合の*の回数=δの数Mの比較になるだろう。

また、mgu μの要素数はMである。



σの計算では、
1) リテラルL1とL2の引数の数の中で小さいほうの数をmaxとした回数(n)の比較が行われる
   対応するeiで変数でないほうの数
　ただし、x←eのeがdisagreeの検索対象になると数がふえる。

'''
例
x,yを変数として
<f(x,h(x)):f(g(b),h(g(a)))>


### 証明の中での代入の回数
ひとつの反証Πができたとき、N=(Πに出現するclauseのリテラル数-inputリテラル数)は、なんらかの代入を適用した回数に等しい。

また、M=Πに出現するclauseのリテラル数/2はunificationの回数である。

M*N/2はΠの計算量の目安になる。


### 失敗した証明ステップ(resolution)を含めて、期待されるステップ数
失敗したmguの回数は、作成された証明や反証をながめていてもわからない。
戦略アルゴリズムのトレースが必要になる



