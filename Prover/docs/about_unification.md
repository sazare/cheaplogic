# Unificationと代入の分類と関係
## 概要
Substitution(代入)の2つのアルゴリズムの機能と計算量について考える。
Unificationアルゴリズムには2つの代入が使われている。
代入の違いによるUnificationの違いというものはあるのか?
証明や証明のトライアル全体の計算量を考えることについても触れる。

代入のアルゴリズムが何種類あるとかUnificationがそれによってどう違ってくるとかいう話は聞いたことがないので、考え方だけでもここに書いておきたいという意図。

## 代入
代入を考えるためには「表現」の定義が必要だが、ここではLISPのS式のようなものを考えておくので十分だと思う。
最初にSymbol(Atom)があり、それから表現を次のように定義する。

```
定義:表現
Expr = Symbol | (Symbol . Expr*)
Expr* = () | (Expr . Expr*)
```

```
定義: 表現に出現する記号
S(e) = 表現sに登場するすべてのSymbolからなる集合
```

また、部分表現を次のように表記する。

```
表記:部分表現
e1 < e2
表現e1は表現e2の一部として出現している
```

Symbolを変数と定数に区別したくなるが、それはUnificationのときに考える。

### 基本代入
基本代入といっているのは1つのSymbolに対する代入のことで、次のように表記する。

```
定義:基本代入
基本代入 = [S ← E]
SはSymbol, EはExprとする。
```

この操作の意味は、表現eに対する代入σ={x ← e1}の適用操作(*)で定義できる。

```
定義:基本代入の適用
e*σ = e1 when eがSymbolで、e=x
      e  eがSymbolで、e!=x
      (s e1*σ e2*σ ... ek*σ) when e=(s e1 e2 ... ek)
```

LISPにはsubst()という関数があるが、これは(subst e1 x e)のようなインターフェースで、表現の中をどうトラバースするのかは気にしない。
だから、それをもとに代入関数を作ると、この定義とは違うものになる。(昔はsublisという関数があったような気がするがsbclではみつからなかった)

### 代入
基本代入は要素が1つしかないが、複数の要素があるものを「代入」と呼ぶ。
代入の表記を二種類考える。

```
表記: 代入
タイプ1: σ=[s1←e1, s2←e2, ..., sk←ek]
タイプ2: σ=[s1,s2,...,sk]←[e1,e2,...,ek]
```

代入を対象とする次の関数も使う。
```
L(σ) = {s1,s2,...,sk}
R(σ) = {e1,e2,...,ek}
```


表現に対する代入の適用を次のように定義する。

#### 適用1
表現に対するタイプ1の代入の適用を次のように定義する。
```
定義:適用1
σ=[σ1,σ2,...,σk]とすると、
e*σ=((...(e*σ1)*σ2)*...*σk)
```

```
例
σ1=[x←a, y←f(x)]
σ2=[y←f(x), x←a]
e1=(x y)
```
とすると
```
e1*σ1 = (a f(x))
e2*σ2 = (a f(a))
```
となる。
この結果の違いは、表現eを作業台として、x←aが圧縮されたからと考えられる。

これはUnificationで改めて考える。

### 適用2
表現eに対するタイプ2の代入の適用は次のように定義する。

```
定義:適用2
eは表現、代入σは
σ=[s1,s2,...,sk]←[e1,e2,...,ek]
とする。このとき、

e@σ = ei when eがSymbolであり、si=e
      e  when eがSymbolであり、eに一致するsiが存在しない
      (s e1@σ e2@σ ... ek@σ) when e=(s e1 e2 ... ek)のとき
```
@は基本代入の適用を並列に行う操作と考えられる。

```
例
σ1=[x,y]←[a,f(x)]
σ2=[y,x]←[f(x),a]
e1=(x y)
```
の場合
```
e1@σ1 = (a f(x))
e2@σ2 = (a f(x))
```
となり、*のときのような代入要素の圧縮はおきない。

## Unification

```
定義: Unifier
表現e1,e2について、次の条件を満たす代入σをunifierと呼ぶ。
e1*σ = e2*σ
```
また
```
定義: most general unifier(mgu)
表現e1,e2について、次の条件を満たすUnifier σをmost general unifier(mgu)と呼ぶ。

任意のユニファイアー μ について、代入τが存在し、
μ = σ*τ
となる
```

Unificationという操作は次のように定義する。
```
定義:Unification
Unificationは、二つの表現e1,e2が与えられた時、それらのmguを求める操作/アルゴリズムのことである。
この資料では、Unificationを次のように表記する。

μ = <e1:e2>
```

ここで変数が登場する。
変数はSymbolの一部であり、代入の左側に出現できる。
変数をどのようにUnificationに知らせるかはいろいろな方法が考えられる。

理論では、単純に変数全体の集合を与え、それによって決めることが行われるが、コードを書く場合は、それにあわせて、globalな変数に変数を定義するとか、あいはSymbolの文字列の特別な記号で判定するとか、Symbolのpropertyとして変数かどうかのbooleanを持つとか、あるいはe1とe2に属する変数のリストを与えるとかがありうる。

実装の詳細にはまだ踏み込まない。

Unificationは、次のようなアルゴリズムが知られている。
```
1. μ = []
2. e1,e2のdisagreement set δ=(d1,d2)を求める
　　d1<e1, d2<e2であり、d1!=d2となる極大の部分表現。
3. d1,d2から基本代入が作れるならそれをσiとする。
　　つくれなければ(*1)、Unificationは失敗で、ここで処理は終わる。
4. e1,e2 := e1△σ1, e2△σ2とする。
5. μ = μ ○ σ1 として、mguを拡張する。
6. 2に戻る。

ここで、△と○は表現x代入、および代入x代入の操作だが、それぞれ2つのタイプがあるうちのどちらを使うかでUnificationの結果が異なるので、ここでは特定せずに書いている。





