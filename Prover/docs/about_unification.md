# Unificationと代入の分類と関係
## 概要
Substitution(代入)の2つのアルゴリズムの機能と計算量について考える。
Unificationアルゴリズムには2つの代入が使われている。
代入の違いによるUnificationの違いというものはあるのか?
証明や証明のトライアル全体の計算量を考えることについても触れる。

代入のアルゴリズムが何種類あるとかUnificationがそれによってどう違ってくるとかいう話は聞いたことがないので、考え方だけでもここに書いておきたいという意図。

## 代入
代入を考えるためには「表現」の定義が必要だが、ここではLISPのS式のようなものを考えておくので十分だと思う。
最初にSymbol(Atom)があり、それから表現を次のように定義する。

```
定義:表現
Expr = Symbol | (Symbol . Expr*)
Expr* = () | (Expr . Expr*)
```
SymbolでないExprのことをC-Exprと呼ぶ。

```
定義: 表現に出現する記号
S(e) = 表現sに登場するすべてのSymbolからなる集合
```

また、部分表現を次のように表記する。

```
表記:部分表現
e1 < e2
表現e1は表現e2の一部として出現している
```

Symbolを変数と定数に区別したくなるが、それはUnificationのときに考える。

### 基本代入
基本代入といっているのは1つのSymbolに対する代入のことで、次のように表記する。

```
定義:基本代入
基本代入 = [s ← e]
sはSymbol, eはExprとする。
```

この操作の意味は、表現eに対する代入σ={x ← e1}の適用操作(*)で定義される。

```
定義:基本代入の適用
e*σ = e1 when eがSymbolで、e=x
      e  eがSymbolで、e!=x
      (s e1*σ e2*σ ... ek*σ) when e=(s e1 e2 ... ek)
```

LISPにはsubst()という関数があるが、これは(subst e1 x e)のようなインターフェースで、表現の中をどうトラバースするのかは気にしない。
だから、それをもとに代入関数を作ると、この定義とは違うものになる。

### 代入
基本代入は要素が1つしかないが、複数の要素があるものを「代入」と呼ぶ。
代入の表記を二種類考える。

```
表記: 代入
タイプ1: σ=[s1←e1, s2←e2, ..., sk←ek]
タイプ2: σ=[s1,s2,...,sk]←[e1,e2,...,ek]
```

代入を対象とする次の関数も使う。
```
L(σ) = {s1,s2,...,sk}
R(σ) = {e1,e2,...,ek}
```


表現に対する代入の適用を次のように定義する。

#### 適用1
表現に対するタイプ1の代入の適用を次のように定義する。
```
定義:適用1
σ=[σ1,σ2,...,σk]とすると、
e*σ=((...(e*σ1)*σ2)*...*σk)
```

```
例
σ1=[x←a, y←f(x)]
σ2=[y←f(x), x←a]
e1=(x y)
```
とすると
```
e1*σ1 = (a f(x))
e2*σ2 = (a f(a))
```
となる。
この結果の違いは、表現eを作業台として、x←aが圧縮されたからと考えられる。

### 適用2
表現eに対するタイプ2の代入の適用は次のように定義する。

```
定義:適用2
eは表現、代入σは
σ=[s1,s2,...,sk]←[e1,e2,...,ek]
とする。このとき、

e@σ = ei when eがSymbolであり、si=e
      e  when eがSymbolであり、eに一致するsiが存在しない
      (s e1@σ e2@σ ... ek@σ) when e=(s e1 e2 ... ek)のとき
```
@は基本代入の適用を並列に行う操作と考えられる。

```
例
σ1=[x,y]←[a,f(x)]
σ2=[y,x]←[f(x),a]
e1=(x y)
```
の場合
```
e1@σ1 = (a f(x))
e2@σ2 = (a f(x))
```
となり、*のときのような代入要素の圧縮はおきない。

タイプ1の表記で、適用2を行うこともできるが、区別したかったのでこうした。

### 代入を代入に適用する

```
定義: 代入同士の適用(操作的定義)
σ1とσ2を代入とする。
σ1=[σ11,σ12,...,σ1k]
σ2=[σ21,σ22,...,σ2m]
とする。
このとき、代入間の演算*を次のように定義する。

σ1*σ2 = [s1i←e1i*σ2, s2p←e2p]
要素は2つのパターンの要素からなり、
ここで、iは1からk、s2pはL(σ2)-S(L(σ2))の要素から選ぶ。
```
つまり、σ1の要素については、si←ei*σ2とし、σ2の要素についてはσ1のLにないものだけを選んでできる代入である。

この定義によって
```
定義:代入の同値
代入σ1、σ2について
σ1~σ2 を
任意の表現eについて e*σ1 = e*σ2 が成り立つことと定義する
```

#### 不明点
- e@σ1 = e@σ2だとどうか
- []←[]タイプの代入と[←]タイプの代入を掛け合わせるときはどうなるか


### 補足

ρ1=[x,y]←[y,x]
ρ2=[x←y]
ρ2'=[y←x]
e=(x,y)

を考えてみる。
ρ1は、xとyを入れ替えるので
e@ρ1 = (y,x) 
となる。

ρ2とρ2'は、代入の左右を入れ替えた表現であり、逆元のようにかんじられるが実際にeに適用してみると
e*ρ1*ρ1' = (x,x)
e*ρ1'*ρ1 = (y,y)

となりeには戻らないので、逆元ではない。

## Unification

```
定義: Unifier
表現e1,e2について、次の条件を満たす代入σをunifierと呼ぶ。
e1*σ = e2*σ
```
また
```
定義: most general unifier(mgu)
表現e1,e2について、次の条件を満たすUnifier σをmost general unifier(mgu)と呼ぶ。

任意のユニファイアー μ について、代入τが存在し、
μ = σ*τ
となる
```

Unificationという操作は次のように定義する。
```
定義:Unification
Unificationは、二つの表現e1,e2が与えられた時、それらのmguを求める操作/アルゴリズムのことである。
この資料では、Unificationを次のように表記する。

μ = <e1:e2>
```

* ここで変数が登場する。
変数はSymbolの一部であり、代入の左側に出現できる。
L(σ)以外の変数も存在しうる。
変数をどのようにUnificationに知らせるかはいろいろな方法が考えられる。

理論では、単純に変数全体の集合を与え、それによって決めることが行われるが、コードを書く場合は、それにあわせて、globalな変数に変数を定義するとか、あいはSymbolの文字列の特別な記号で判定するとか、Symbolのpropertyとして変数かどうかのbooleanを持つとか、あるいはe1とe2に属する変数のリストを与えるとかがありうる。

ここでは、実装の詳細にはまだ踏み込まない。

Unificationは、次のようなアルゴリズムが知られている。
```
1. μ = []
2. e1,e2のdisagreement set(*1) δ(e1,e2)=(d1,d2)を求める
3. d1,d2から基本代入が作れるならそれをσiとする。
　　つくれなければ(*2)、Unificationは失敗で、ここで処理は終わる。
4. e1,e2 := e1△σ1, e2△σ2とする。
5. μ = μ * σ1 として、mguを拡張する。
6. 2に戻る。

ここで、△は表現x代入の操作であり、2つのタイプがある。
うちのどちらを使うかでUnificationの結果が異なる。

*1) d1<e1, d2<e2であり、d1!=d2となる極大の部分表現。
　- d1,d2がともにSymbolである。ということは、異なるSymbolである。
　- d1,d2のどちらかがSymbolでもう片方がC-Exprの場合。
　- e1,e2がともにC-Exprであり、d1=(s1 e1i,...), d2=(s2 e2i,...)
　　s1==s2の場合は、i=1からkの順にδ(e1i, e2i)の中で最初に(d1,d2)が求められたらその値。
  - それ以外のd1!=d2の場合は(d1,d2)

*2) 基本代入が作れるか作れないかの基準
  - d1,d2の一方が変数の場合。例えばd1が変数だとすると、
  - d1 < d2 なら失敗(このテストはinside checkと呼ぶ)
　- そうでなければσi=[d1←d2]

*3) inside checkについては後で改めて考える。
```

#### Unificationの△
unifictionでは、つぎの2つの部分で代入適用を行う。
1. σiを|e1>と|e2>に適用する。(表現*代入)
2. mgu:=mgu*σi (代入○代入)

1の代入適用は、要素代入の適用なので*になる。表現が介在するので、squeezeがおき、処理の順番による結果の違いはない。

2の代入適用は、代入どうしの適用なので、表現を介するsqueezeができない。
 *によって、処理の順序に依存しないmguの表現を求めることができる。


#### 例
Unificationアルゴリズムでは、単純化のためか、σiの適用は元のei全体を対象としている。
実際には、直前のδを含む左側の部分はすでに同一になっているので、δよりも右側の部分だけにσiを適用すればよい。
そこで、直前のδから右側だけを表す表記を用いることにする。

```
例
e1 = f(x, h(y) g(k(x)))
e2 = f(a, h(z), g(w))

0. mgu=[]
<e1:e2>=|f(x, h(y) g(k(x))):
1. δ1 = (x:a) => σ1 = [x←a]
mgu=mgu*σ1=[x←a]
| h(y) g(k(a))):|h(z), g(w))
2. δ2 = (y,z) => σ2 = [y←z]
mgu=mgu*σ2=[x←a, y←z]
| g(k(a))):|g(w))
3. δ3 = (k(a),w) => [w←k(a)]
mgu=mgu*σ3=[x←a, y←z, w←k(a)]
|):|)
4. δ4 = () => end
mgu=x←a, y←z, w←k(a)]
end

```

```
例2
e1 = f(x, h(y) g(h(y)))
e2 = f(a, h(z), g(w))
```

### Resolutionの中での代入
2つのclause C1, C2が与えられた時のresolutionを考える。

C1 = +L1 ∨ C1'
C2 = -L2 ∨ C2'

ならば、mgu σ=<L1:L2>をもとめ、R=(C1'∨C2')○σによってresolventを作る。

σの計算では、
1) リテラルL1とL2の引数の数の中で小さいほうの数をmaxとした回数(n)の比較が行われる
2) 代入の適用は、最大n^2/2回行われる。

3) 代入同士の適用は、n回行われる。

1+2の回数と比較して3の回数が少ないので、こちらはe*σの計算でもよい。(???)
1+2は表現が作業台になるので、*でよい。(???)


Rに対するL*σの計算は
Rのリテラルの個数x各リテラルの要素表現の数だけ行われる。


### 証明の中での代入の回数
未


### 失敗した証明ステップ(resolution)を含めて、期待されるステップ数
未


