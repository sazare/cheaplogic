# Unificationと代入の分類と関係
## 概要
Substitution(代入)の2つのアルゴリズムの機能と計算量について考える。
Unificationアルゴリズムには2つの代入が使われている。
代入の違いによるUnificationの違いというものはあるのか?
証明や証明のトライアル全体の計算量を考えることについても触れる。

代入のアルゴリズムが何種類あるとかUnificationがそれによってどう違ってくるとかいう話は聞いたことがないので、考え方だけでもここに書いておきたいという意図。

## 代入
代入を考えるためには「表現」の定義が必要だが、ここではLISPのS式のようなものを考えておくので十分だと思う。
最初にSymbol(Atom)があり、それから表現を次のように定義する。

```定義:表現
Expr = Symbol | (Symbol . Expr*)
Expr* = () | (Expr . Expr*)
```

Symbolを変数と定数に区別したくなるが、それはUnificationのときに考える。

### 基本代入
基本代入といっているのは1つのSymbolに対する代入のことで、次のように表記する。

```定義:基本代入
基本代入 = [S ← E]
SはSymbol, EはExprとする。
```

この操作の意味は、表現eに対する代入σ={x ← e1}の適用操作(*)で定義できる。

```定義:基本代入の適用
e*σ = e1 when eがSymbolで、e=x
      e  eがSymbolで、e!=x
      (s e1*σ e2*σ ... ek*σ) when e=(s e1 e2 ... ek)
```

LISPにはsubst()という関数があるが、これは(subst e1 x e)のようなインターフェースで、表現の中をどうトラバースするのかは気にしない。
だから、それをもとに代入関数を作ると、この定義とは違うものになる。(昔はsublisという関数があったような気がするがsbclではみつからなかった)

### 代入
基本代入は要素が1つしかないが、複数の要素があるものを「代入」と呼ぶ。
代入の表記を二種類考える。

```表記: 代入
タイプ1: σ=[s1←e1, s2←e2, ..., sk←ek]
タイプ2: σ=[s1,s2,...,sk]←[e1,e2,...,ek]
```

表現に対する代入の適用を次のように定義する。
#### 適用1

表現に対するタイプ1の代入の適用を次のように定義する。
```定義:適用1
σ=[σ1,σ2,...,σk]とすると、
e*σ=((...(e*σ1)*σ2)*...*σk)
```

例
```
σ1=[x←a, y←f(x)]
σ2=[y←f(x), x←a]
e1=(x y)
```
とすると
```
e1*σ1 = (a f(x))
e2*σ2 = (a f(a))
```
となる。
この結果の違いは、表現eを作業台として、x←aが圧縮されたからと考えられる。

これはUnificationで改めて考える。

### 適用2
表現eに対するタイプ2の代入の適用は次のように定義する。

```定義:適用2
eは表現、代入σは
σ=[s1,s2,...,sk]←[e1,e2,...,ek]
とする。このとき、

e@σ = ei when eがSymbolであり、si=e
      e  when eがSymbolであり、eに一致するsiが存在しない
      (s e1@σ e2@σ ... ek@σ) when e=(s e1 e2 ... ek)のとき
```
@は基本代入の適用を並列に行う操作と考えられる。

例
```
σ1=[x,y]←[a,f(x)]
σ2=[y,x]←[f(x),a]
e1=(x y)
```
の場合
```
e1@σ1 = (a f(x))
e2@σ2 = (a f(x))
```
となり、*のときのような代入要素の圧縮はおきない。

## Unification
Unificationは、二つの表現e1, e2が与えられた時、それを同じ表現にする共通の代入σを求める操作/アルゴリズムのことである。
この

```定義:Unifier
表現e1,e2について、次の条件を満たす代入σをunifierと呼ぶ。
e1*σ = e2*σ
```

```Unification
σ = <e1:e2>

σをmost general unifier(mgu)と呼ぶ
```




