20200412

1. 代入の2つの表現の違い
  a) [vi←ei]もvs←esも、それで演算が決まってしまうわけではない。*であれ@であれ。
  　その表現から、直感的に実装が想像できるという違いだけだろう。
  
[vi←ei]は、property listのような線形のデータ構造を想像させる。検索に時間がかかるだろう。
vs←eiは、hash-table/Dictionaryのようなアクセスが高速だけどメモリは余分に必要といった実装を想像させる。


2. unifyでは、e□σと σ□σの2種類の演算が使われる。
　e□σはdisagreementで違っている場所さえわかればよいのと、基本代入しかでてこないし、eがあるので、比較的単純。
　σ□ςは、mguをaccumulateするための演算であり、resolventを作るときに適用されるときの演算との整合性が重要である。
　ςは基本代入だが、そうして集められたmgu(μ)は、resolventを作るときはe◇μとして適用されるので、□と◇には整合性がなくてはならない。

3.  処理量を考えると、*よりも@が単純なので、処理量は少なくなる。(e1に対するσ2の適用がない。σ2が基本代入であっても同じ)
　μをつくる処理とμを適用する処理の回数は、適用する回数のほうが多いので、難しいことはunifyの□でやっておきたい。

　ということは、resolvent作成時は、@が望ましく、それは、E(μ)*σ=E(μ)となるということだろう。
　言い換えると　V(E(μ)) ∧ V(σ) = φとなるようにμを計算したい。
　ということは、unifyでは@を使っていては足りない。もちろん、@を使って計算して、最後にs形式に直すという手もあるが、それは結局二度手間になるのではないか。


　μ*σは、2つの処理があり、同じ変数の代入要素を除外する処理と、E(μ)にσを適用する処理がある。
　unifyでのμの計算では、disagreeが表現ベースのe*σ1なので、一度でた変数は二度とでてこないから、前者は不要。
　問題は、μtで変数xを置換したetの変数がdisagreeになるかどうかだが、それはありうる。
　だから、mguの合成計算では、変数の重複テストは不要だが、e1*σ1は必要である。(e1はμtの右で、σ1はdisagreeから求められた基本代入)。
　だから、@ではなく*で合成しなくてはならない。


5. disagreeとmguの合成で重複する処理
　ある時点tのdisagreeをDt=(d1,d2)とすると、これが解消できた場合、Dよりも左側は一度同じになっているので、二度と違うことはない。
　Dより右側の部分表現についてdisagreementをとればよい。同じ表現ならば、μtをこの左部分表現に毎回適用する必要はない。
　では、右部分表現についてはどうか。disagreeを求める処理において、μtを常に適用する必要があるのかどうか。

　一方が変数の場合(x:t) xに対してはμtをかけて、(x*μt:t)のdisagreeを求めれば良い。
　ただし、変数xにμtを適用しても変化しなかった場合はこの基本合成の変数側は決定なので、disagreeは<x:t*μt>でよい。
　このt*μtについて、insideチェックは必要であるが、

　t側にも代入する必要があるかだが、(x*μt:t*μt)の計算をした場合、
    - (f():g()) でNOになるのであれば、tは変数ではないので、t=g()だから、代入をしなくてもNOになる。
    - (f(t1):f(t2))でNOになるのであれば、tを展開するのは必要になったときでよい。
  だから、t側への代入は必要になったときでよい。
  
　両方が異なる変数の場合(x:y)は、(x*μt:y*μt)のdisagreeを求める。

課題は
　・前の続きができるかどうか
　　　coroutineあるいはcontinuationを使うのかな。処理量はどうなのか?

　・この処理が最速かどうか
　　 いまのところ、無駄なことをしていないので、これが最速に思える。

　・ s記法がよいかp記法がよいか
　　これは処理とは関係なさそう。
　　cheaplogicなら、varsがあるのでp記法ということになるだろう。


