ちなみに load_viewprover.jlで動かすと、readcoreしたものは変数coreにはいる。
QEDは☕️でしめす。
バグは🕷でしめす。「ばぐ」
重要なことは🎂でしめす。「こう」
何かの影響を🕸でしめす。「す」

20190817土
1. maxでなく、そのリテラルの前のwhendoit+1にしてみた
今の例では,partialもabortもうごく

結局、サイクリックにまわすことになる

同じwhendoitの中から、ランダムに選ぶようにしても、根拠がないので
今のままにするしかないか・・・

2. よくみると、V40_R1[8,y]にすると、L41_R11[y,z]になってしまう

355  σo = getσo(varc, varg, pm)
357  σo = apply(varc, σo, gvar)
のところでgvarがclauseのvarsになっていて、長さがvarcと違う。
varcはcano(unitclause)のvarsなのでliteralの変数の数だが
gvarはちがう

たぶんgatmの引数部分だけをもってくるべき

357  σo = apply(varc, σo, gatm.args[2:end])
とした。

3.Viewで入力すると、そのインスタンスが一回残っていて、confirmさせられる。
　これでいいのか 🎂

4. 今はViewでCanoリテラルをすべて消去したあとResoに進む
   少なくとも1つViewを解決したらResoに進めばよいような気もするが
　順番はいるのはよくないような気がする
　今のままがよいか



20190816金
1. viewでabortやpartialのとき、次は別のリテラルを選ぶようにしたい
2. しかし、他に選択肢がないときはよい
3. goalの各リテラルについてtouch valueをつける。
　　基本は0。partialやabortやFailしたときはgoalのそのliteralのtouch valueを増やす。
　　0でないものだけ管理すればよい。Dictで。
　　次に対象とするliteralを選ぶとき、touch valueの一番小さいものから選ぶ。

4. まず現状を調べる
 1) V+Rがないので、C21で作る
 2) まちがえて-P4,-R4と-R4(5),-R4(6)とやったが[]になった
    CanoのP4について -P4()と+P4()-R4()という定義にしたためで、-R4にいっていなかった。
　　-R4()と相手のいない場合の例を作った
🕷 3) V[6,-] => viewlogic.jl:324でException varc,σo,varg = [W,Z],[8,Z],[y]
    [W,Z]なのに[y]が1つしかないから。
 4) V[-,5] => これもループ。V[5,5]で[]。
 5) V[-,9] => これもループ。V[5,9]と入力するとcan't progress.
 6) abortするとずっと同じリテラルでループする

5. choosecanoid()を修正した
global DIL = Dict()
global maxdil = 0
を追加した。
関数を追加した
doitlater(glid) glidのカウントを設定する
doitlater(glid, wdi) glidのカウントをwdi+1にする。
どちらもmaxdilを最大値にする

whendoit(gid) gidのカウントを参照する

abortのときは、glidのカウントをupする。
partialのときは、glidとridから新しいglidをもとめ、前のglidのカウント+1にする

choosecanoid()では、lidsをsortするときby=whendoitを指定する。


6. chooseresolveid()を修正する



8. stringclause()でRがCの中にまじっていた。ltid()をRとCを区別するように修正した


20190812月
週末は、小説の整理をしていた。

🎂証明の進展ではなく、proving attemptsについて変化を調べなくてはならない。

証明とmguは対応するけれども、<L:R>がfailしたという情報は、proving attemptsが進んだ
ということを意味するのであり、存在しないmguを見ているだけではわからない。

input literalsのすべての組み合わせ以外に証明で使われるpairはない
(axiomsが変化しない場合)
だから、Lpairsを列挙すると、証明の全体像がみえるはず。
命題とそれに制約をつけた述語。

proving attempts=Lpairsの並びあるいはLpairsの木がprovingの進展状況を示している。


🎂 NTPのワードベクトルのように、input literalでベクトルを作ってうれしいことがないか??
どのようなベクトルを作れば良いか
literalには変数を含むものがあるが、
何で区別するのか

述語記号
リテラル記号
input リテラル

たとえばclauseが似ているということを定義できるか?

literalは述語記号と符号が一致していれば似ているのか

全input literalのベクトルというのが素朴な考えとしてありそう。

変数はどうするか?

cheaplogicの最初の頃に作ったproverもどきは似ているかも







20190809金
viewでかえりのとき、isgroundでなけれぱliteralを消さないようにした。
1. 一部の値を入れてgoalは変化した。🎂
2. 次も同じリテラルのviewになり、🕷
3. 値の決まっていないところはcano変数がでていた。🕷
4. そのcanoViewの値のはいっていなかったところに55を代入したら
2019-08-09 19:24:59:ERROR:Main: ICMP(:Y, 55, :unify0sn)
　となった。変数リストがうまくいっていない。
 vargは[]。
5. view後の新goal(R1のL50のvarsが[]になっている

[ Info: noabort
┌ Info: after_apply
└   (catm2, varc, catm, σo) = (:(P(22, Y)), Any[:X, :Y], :(P(X, Y)), Any[22, :Y])
┌ Info: after_unify
└   (σg, varg, gatm, catm2) = (Any[22, :Y], Symbol[:x_C3, :y_C3], :(P(x_C3, y_C3)), :(P(22, Y)))
[ Info: (:factify_clause, :L50, Any[22, :Y])

applyはいいみたいだが、Yをy_C3に変える代入がない
🎂σgをつくる前にσoにvarc.<catm:gatm>をかけておく

うまくいった





* 直接いけるか? 
 http://localhost:8000/go?op=readcore&corepath=vdata%2Fvev002.cnf
 いけるみたい。

20190730火
vlogicのソースの整理ができた

アルゴリズムの見直しが必要


20190803土
1. viewの制御を見直した。
1.1. viewでliteralを消していいのはViewのもどりがgroundになっているとき
1.2. giveup条件がいくつかある。そこでもgroundが条件になる
1.3. viewで入力しつくしたあとにresoをするようにしたい
1.3.1 ∵ resoでバックトラックが発生したときviewにまで戻れない
1.3.2 バックトラックなのか、総当たりなのかはまだ未定

2. isground()を作成した。with tests

3. viewlogic.jlとviewreso.jlにコメント追加。特に関数のコメント
重要な修正はまだ。

4. stringcore()でclauseの表示順を数字にあわせた。つまり
  今はC12のあとにC2がくるのをC2のあとにC12がくるようにした。
　桁数の少ないものを前にした


20190721日
1. 見てみるとおかしな点はすぐにわかった。修正する(20分)
2. vev002.cnfで確認する

🎂 ViewでだめなときにValidでうまくいったときContradictionはおかしいので
　　UIとしては「証明不可能」とか「証明済」といったメッセージがよいはず。
　　そうなるとHorn clause的な表現がよいことになる。まあそうか。

🕷 vev002/C12 x=8,y=1
[ Info: postview
[ Info: postview
[ Info: postview
2019-07-21 09:19:40:ERROR:Main: type Char has no field lcmap
2019-07-21 09:19:40:ERROR:Main: /go?op=postview&X=8&Y=1&how=confirm 500

2019-07-21 09:19:40:CRITICAL:Main: type Char has no field lcmap
getproperty(::Any, ::Symbol) at ./sysimg.jl:18
cidof(::Nothing, ::Char) at /Users/shin/Projects/github/cheaplogic/Prover/newcore.jl:227
lvarsof(::Nothing, ::Char) at /Users/shin/Projects/github/cheaplogic/Prover/newcore.jl:205
postview(::Dict{Symbol,Any}) at /Users/shin/Projects/github/cheaplogic/Prover/vlogic/viewlogic.jl:322
(::getfield(Main, Symbol("##79#80")))() at /Users/shin/Projects/github/cheaplogic/Prover/vlogic/viewlogic.jl:78

☕️ resolvelid()の中でcatchしていたunifyのfail
　　だがresolvelid()はgidとcoreを返すもので、failからfailview()::htmlが
　　かえってきてもタイプミスマッチになっていた。
    resolvelid()を読んでいる側でcatchするようにした。

🕷 C18のビューがおかしい。

GLID: L31_R1のビューで
{X=x_C14, Y=y_C14}
になり、値を入れてconfirmすると

2019-07-21 10:08:45:ERROR:Main: ICMP(:x_C14, 8, :unify0sn)
2019-07-21 10:08:45:ERROR:Main: /go?op=postview&X=8&Y=2&how=confirm 500

2019-07-21 10:08:45:CRITICAL:Main: ICMP(:x_C14, 8, :unify0sn)
unify0(::Array{Symbol,1}, ::Symbol, ::Int64) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:34
unify0(::Array{Symbol,1}, ::Expr, ::Expr) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:67
unify1(::Array{Symbol,1}, ::Expr, ::Expr, ::Array{Symbol,1}) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:215
unify(::Array{Symbol,1}, ::Expr, ::Expr) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:302

🎂 x_C14とかが変数になっていないのではないか






20190720土
1. addnewclauseなどの関数をみなおす
2. addstepを各ruleについて作る(引数違うからできるのでは)
3. 夜中にaddnewclause, addstepで全部書き換えたが、ちゃんと動かない
　細部は明日にする


20190714日
1. 処理を見直す
2. 不要なコードをコメントアウト
🕷 昨日の修正でViewのabortすると、次に他の処理に移らない。
   あるliteralのViewでabortしたら、次はviewでもresoでも別のliteralにしてほしい
　 おなじliteralのresoに進む道もあるかも　要考
🕷 項目に値を入れずにconfirmした場合どうなるべきか
　　1) 今は、その値は無視してliteralが消える。それでいいような気もするが
　　2) 値がないのに消えていいのか?
　　　　- 人間がその値を指定しなかったのは、いずれ決まると考えているからか
　　　　- かといって、その項目を理由にview literalを消さないと、すでに入力した
　　　　　値が無駄になる。その場合は、literalを消さずに残すということになると
　　　　　abortと同じ問題がある
🕷 askUのあとのpostview->factify_clause()の中でevaluate_literals()を繰り返して
　　いるがこれのproofを作っていない
🎂 factify_clause()の367行以降はどこかでもやっていた
　addnewclause()かな
🕸 


20190713土

1. about_viewprover.txt <- howto_viewlogic.txt
  viewproverの概要説明とvev002.cnfのclauseの概要

2. viewで失敗して次のviewにいくかresolveに進むかするような制御を考えようとしたが
　自分の意図が不明確だった
  ViewはFactを作るわけではないので、askU()をすると必ずliteralが消えてしまう。
　C10でP-viewにx,y=10,100などといれると、結果goalはvalidになる。

  ということはViewで中断した場合、literalを消す操作自体をやめなくてはならない。

  askU()が作るhtml(in goalprover():viewlogic.jl)で cancelをしたとき
  たどりつくtargetで、goalprover()のchoosecanoid()を再度実行して
　次のcanoidをみつけられるとよい。
　choosecanoid()をclosureにするか、どこまで確認したかのindexを持つか。
　indexは、resolveに進んだときはresetする。

　ややこしすぎ
　たんにおわればよい

  askUで次のtargetはpostviewになっているが、そこでcancelしたときの
　処理をすればい。

　cancelは、今は入力をなしにすることになっている。
　abortみたいなのが必要かも。
🎂🎂🎂 inputタグのtypeにabortはないか? value??

　makeView2()にabortボタンを追加した。

<input type=\"submit\" name=\"how\" value=\"confirm\"></br>
<input type=\"submit\" name=\"how\" value=\"abort\"></br>

 name属性は、サーバにname=>valueを送信する。

 postview(pm)で、このpm[:how] == "abort"のとき
　goalを変更せずに次のステップに進むようにした。
 htmlは前のをコピーしただけ。

🕷 C12でViewをabortしたら同じ画面にもどった。
　resolveにすすむ予定。
　全体制御を誤解しているかも
🕷 入力に空があったらabortとみなすようにする



  


*** Genieがabandanされた場合にどうするか。
 a) Genieのrepositoryをとっておく
 b) route("/go") とGenie.AppServer.startup()だけ作り直す。
    他のhttpサーバを使って、作れるか???
 c) Genieのかわりのものを作る(bは一部だけ)


20190707日
🎂@showを@infoに変更
🎂ValidのときExceptionににならないようにした
　Validの扱いはこれでいいのだろうか???
🎂-P(x,y)->View->+S(x,y) -> ge(x,y) で[]が出るようなgoalを追加したが
proofはそうなっていないようだ

C15:[].[L28:+(S2(1,2))]
C16:[x_C16,y_C16].[L29:-(P2(x_C16,y_C16))]
C17:[x_C17,y_C17].[L15:+(P2(x_C17,y_C17)),L16:-(S2(x_C17,y_C17))]
C18:[x_C18,y_C18].[L40:+(S2(x_C18,y_C18)),L41:-(ge(x_C18,y_C18))]

P2のcanoを作った

このとき
P2Viewでx,y=1,2の場合はC15で[]
x,y=100,20のときはC17で[-S2(100,20)]になり
C18で[-ge(100,20)]となり
evaluateしてfalseなのでリテラルが消えて[]になる

resolventはできるが、proofができないのはViewだからだろうか。


20190706土
しばらく進展がなかった。resolutionをどうするかでなやんでいたので。

🎂evaluate, view, resolveの処理はいちおう作った。
まったく賢くない。

🎂制御の変更
　1. evaluateは、評価できるものすべてを一気に評価していたが
　　それをするとproofが作れなくなるので、1つevaluateで消すたびに
　　proofを追加するようにした。
　　毎回結果をuserに見せるような制御にした
　2. resolveは、1ステップだけ先に進めるようにした。

  (evaluate^*+view+resolve)^* という感じ。

　revolveの相手はoppositof()で求めるので、ループにはいってしまう
　可能性もあると思う。

　理論的には重要だが、応用の対象をGUIによる質疑応答にしているので、
　実際に、どれくらい複雑なclause集合を使うのだろうかと思う。

　3. Viewでliteralを消す時、proofを作るためにはFact clauseを作った
　ほうがよいような気がする。はっきりしない。
　

🎂P(x,3)からViewのYに3がはいるようになっていた。
　



20190630日
昨日のつづき。

|gvars|=4で|cvars|=2 の差かな

たしかにそうだ。
varg.remにσoをかけようとするとvargとvarcの長さが違うのでこうなる。

lvarの長さを持つσoをclauseのvarsのサイズに拡張しなくてはならない。

σoはbindingまで含めると varc.(varc←σo)

varcとσoの順番とlengthは同じ。(by cnf def)

1. varc.σoをvarg.σgに変換する手順

varcとvargは長さは違うかもしれない。
一致しているものは

gatmのargsをとってくると、|varc| = |gatm.args|
∵ canoはそのように定義するから。

まず順番をそろえる。
(下のclitはcatm, glitはgatmでもよい)

clit2 = varc.(clit*σo)
σg = varg.<glit:clit2>

bindingを示すと

σg = varg.(varg←σg)


ここでnew goalの形はこうなる

vars.rems

このことから

varg ∈ vars なのでvars.σsは

σs=varg.(vars*σg)

と計算できる。
これは、vargの範囲では
varg.σs = vars.σs
それ以外の範囲では等価代入
ε=vars.σs
という意味での拡張になる。


さて、
glitのbindingは varg.glit
goalのgindingは vars.goal

であり

σg = varg.varg*σo

となる。

ここで、varg in vars なので

σs=varg.(vars*σg)

newgoal = vars.(rem*σs)

である☕️

C12は進んだが、reso作っていないようなので、[]まではいかない
C2で例外・・・addstep()でglid0[1]はevalを除いたあとが[]のときindex Exceptionになる。
親のgidl[1]をparentにした

C1から確認
C1 Valid OK
C2 Contradiction OK
C3 View入力でなんでも[] OK
C4 2つのViewでなんでも[] OK
C5 View先、残りevalで[] OK
C6 evalで残り1Viewで[] OK
C7 Viewは後出し。ViewPでx>=yなら[] OK
C7 ViewPでx<yなら[]ができない => validview OK ... 入力が代入されていない
   clauseがcoreに登録されていない
C8 ViewPは先出し。ViewPで>=yなら[] OK
C8 ViewPでx<yなら[]ができない => validview OK... 入力が代入されていない
C9 ViewP{x,y}とViewR{z,w}があり、x>yなら[]、OK
   そうでないならValid... OK 入力が代入されていない
C10  {x>=y}、ViewP{x,y}, ViewR{z,w}, S(y,w) 
　　　y = 1, w= 2, x >=1 なら[] NG Sのresoができず途中
     それ以外はValid ... OK

C12 {x>=w}、ViewP{x,y}, ViewR{z,w}, S2(1,2) 
　　a x>=2, y=1, w=2 なら [] NG Sのresolutionできず。Viewとevaluate部分はOK
    b それ以外はValie(かな) OK 

ここまででいったんcommit

goresolve()追加
うごかない
 


20190629土
・xxxview()でstringclauseを表示するようにした
・/startのところでglobal変数を初期化するようにした。
　続けていると値がおかしくなっていたので(gidが残っているために
　stepを続けているとみなしている)

・lidの表示で、literalも表示しよう
・xxxview()で/startに戻るようにしよう

fixing
・R1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))] cant progress more
ということはProcリテラルは、viewやresoにかからない(resoはまだない)のと
evaluateで変数が残っているから実行できないのでこうなる。

?変数は置き換わらないのか

C7:[x_C7,y_C7].[L15:-(ge(2,1)),L16:-(ge(x_C7,y_C7)),L17:-(ge(5,2)),L18:-(P(x_C7,y_C7))]
なので、まずPのViewがでなくてはならない。
なぜでないのか。
evalauteだけで終わっているらしい。


logをみると

stringcore(core) = "CORE: vdata/vev002.cnf\nCLAUSES\nC2:[x_C2,y_C2].[L4:-(ge(12,5)),L5:-(ge(114,55)),L6:-(ge(115,9))]\nC10:[].[L10:+(S(1,2))]\nR1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))]\nC8:[x_C8,y_C8,z_C8,w_C8].[L1:-(ge(x_C8,y_C8)),L2:-(P(x_C8,y_C8)),L3:-(R(z_C8,w_C8))]\nC1:[x_C1,y_C1].[L7:-(ge(2,5)),L8:-(ge(4,55)),L9:-(ge(5,9))]\nC4:[x_C4,y_C4,z_C4,w_C4].[L20:-(P(x_C4,y_C4)),L21:-(R(z_C4,w_C4))]\nC5:[x_C5,y_C5].[L26:-(P(x_C5,y_C5)),L27:-(ge(2,1)),L28:-(ge(4,2)),L29:-(ge(5,2))]\nC9:[x_C9,y_C9,z_C9,w_C9].[L22:-(ge(x_C9,y_C9)),L23:-(P(x_C9,y_C9)),L24:-(R(z_C9,w_C9)),L25:-(S(y_C9,w_C9))]\nC6:[x_C6,y_C6].[L11:-(ge(2,1)),L12:-(ge(4,2)),L13:-(ge(5,2)),L14:-(P(x_C6,y_C6))]\nC7:[x_C7,y_C7].[L15:-(ge(2,1)),L16:-(ge(x_C7,y_C7)),L17:-(ge(5,2)),L18:-(P(x_C7,y_C7))]\nC3:[x_C3,y_C3].[L19:-(P(x_C3,y_C3))]\n\nPSYM: [P,R,S,ge]\nCANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))\n"
:goalprover1 = :goalprover1
gid = :R1
glids = Any[:L16_R1]
nlids = Expr[:(-(ge(x_C7R1, y_C7R1)))]
:askU = :askU
chooselid = chooselid
gid = :R1
lids = Any[:L16_R1]
lid = :L16_R1
:nocano = :nocano
v = Inf
ix = 1

なので
R1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))]

★canoのL18:-(P(x_C7,y_C7))が無視されている。

C8は、Viewliteralを先頭に持ってきたが
R1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))] cant progress more
となり

stringcore(core) = "CORE: vdata/vev002.cnf\nCLAUSES\nC2:[x_C2,y_C2].[L1:-(ge(12,5)),L2:-(ge(114,55)),L3:-(ge(115,9))]\nC10:[x_C10,y_C10,z_C10,w_C10].[L4:-(ge(x_C10,y_C10)),L5:-(P(x_C10,y_C10)),L6:-(R(z_C10,w_C10)),L7:-(S(y_C10,w_C10))]\nR1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))]\nC8:[x_C8,y_C8].[L8:-(P(x_C8,y_C8)),L9:-(ge(2,1)),L10:-(ge(x_C8,y_C8)),L11:-(ge(5,2))]\nC1:[x_C1,y_C1].[L12:-(ge(2,5)),L13:-(ge(4,55)),L14:-(ge(5,9))]\nC11:[].[L15:+(S(1,2))]\nC4:[x_C4,y_C4,z_C4,w_C4].[L16:-(P(x_C4,y_C4)),L17:-(R(z_C4,w_C4))]\nC5:[x_C5,y_C5].[L18:-(P(x_C5,y_C5)),L19:-(ge(2,1)),L20:-(ge(4,2)),L21:-(ge(5,2))]\nC9:[x_C9,y_C9,z_C9,w_C9].[L22:-(ge(x_C9,y_C9)),L23:-(P(x_C9,y_C9)),L24:-(R(z_C9,w_C9))]\nC6:[x_C6,y_C6].[L25:-(ge(2,1)),L26:-(ge(4,2)),L27:-(ge(5,2)),L28:-(P(x_C6,y_C6))]\nC7:[x_C7,y_C7].[L29:-(ge(2,1)),L30:-(ge(x_C7,y_C7)),L31:-(ge(5,2)),L32:-(P(x_C7,y_C7))]\nC3:[x_C3,y_C3].[L33:-(P(x_C3,y_C3))]\n\nPSYM: [P,R,S,ge]\nCANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))\n"
:goalprover1 = :goalprover1
gid = :R1
glids = Any[:L10_R1]
nlids = Expr[:(-(ge(x_C8R1, y_C8R1)))]
:askU = :askU
chooselid = chooselid
gid = :R1
lids = Any[:L10_R1]
lid = :L10_R1
:nocano = :nocano
v = Inf
ix = 1

であり
R1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))]
だからView リテラルが無視されている

★★★ evaluateのあとでgoalを作るときに、Procリテラル以外のものを残すのを
忘れているらしい

evaluateの中でisProcでない場合のelseが抜けていた。
修正したらViewがでるようになった

今度は、
1. R1にはview リテラルのみになった
R1:[x_C8R1,y_C8R1]. L8_R1.-(P(x_C8R1, y_C8R1))

evaluate => R1のとき、今度はevaluateですべて消された
elseのときrgidsにgidをついかするように修正

すると

PSYM: [P,R,S,S2,ge]
CANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))
GOAL
 R2:[x_C8R1R2,y_C8R1R2].[L10_R2:-(ge(x_C8R1R2,y_C8R1R2))]

X,Yへの代入がremにapplyされていない
σoのあつかいがおかしい


viewのσoがもどってきたとき、goalのremの変数名を新しいgidでrenameしているので
canoのX,Yへの代入はヒットしないのだが、
そこはvarsをこのremのvarsにすれば解決するはずでは??

factify_clauseの冒頭で
glid = :L8_R1
σo = Any[:x_C8R1, :y_C8R1]
glit = :(-(P(x_C8R1, y_C8R1)))

σoは入力値の代入だから[5,3]みたいになるはずではないか
R1のvarsもほしい

★ σoを作るときの変数をcanovarsof()にしたら、[]までいったC8,C7

そのあと、変数の数が違うためかExceptionが発生するようになった

そこで今日は力尽きた



20190628金
最初、何度やってもすぐにKeyerror(:R1)で終わった
裏で別のload_viewprover.jlを実行していた。

C7,C8で-ge(-,-)が消えなかった
どうも先にaskUで消えたリテラルのσが残りのgoalにapplyされていないようにみえる

20190623日
load_viewprover.jl 
 - vlogic
  - viewlogic.jl -- html view を作る部分
  - viewreso.jl  -- resolution の部分。logicと分けるのは難しいのか
  - vhtmls.jl    -- html生成関数
  - factify.jl   -- postviewでviewで消したclauseを作り登録する

手順
 include("load_viewprover.jl")

 一方

 vdata/vev002.cnf
 gid = C1 -> eval and => Valid
 gid = C2 -> eval and == Contradiction
 gid = C3 -> 1 Views and => Contradiction <= now here

 after View, Exception occured...

 gid = C4 -> 2 Views and => []
 gid = C5 -> View + exec => []
 gid = C6 -> exec + View => []
 gid = C7 -> exec + View with var => []

global gidやcoreに設定していなかった

それを直したらC4までうまくいった
C5はviewがでてほしいのに、何もしなくても[]になった

julia 再起動してやってみるも同じ
PのViewがなぜかできている

C6も同じ

C7 は空白画面になってしまった


20190616日
*** viewlogic uses a Web Page for a tool for getting FACT, 
I assume the inputs from an human is a fact.
Of cource, human may mistake. The reasonable treatment the input
should be cross check it with Base(Axioms).

*** The problem for an huge number of fact is not cleared.

viewlogic.jlはvlogic.jlをコピーしたが、まだ作っていないので動かない。

vlogic.jlが動く

・Viewの初期値がはいっていない。(defaultvalue? value?)
  修正した
　isvar@goal でないとき初期値にする

・viewreso.jlとvhtmls.jlを思に修正
  viewを作るために、goalからCanoを抜き出して、invarの数(canoにて)が一番少ないものを
　viewのliteralとする。
・ただし、invarの数が0のものがあったら、即決でそれをViewにする。

・askyouを作ろうとしているところ
　ここでhtml作成関数を呼ぶことはできるが、表示はviewlogic.jlからなので
　本当は、そこからaskyouを呼ぶようにする必要がある。ううむ



20190615土
viewreso.jlがsyntaxこわれていたので整理

vlogic0.jlとvhtmls.jl はGenieで targetを/go一個にし
targetの区別をopで行うようにした

実質的には前のvlogic.jlと同じような気もするが、
分岐を1つのrouteで表現できるのでましか。

vlogic.jlはvhtmls.jlと整合しなくなったので、動かない

globalを使っている箇所をsessionID+sessionDataで表現すれば
複数のcnfも扱える


証明の分岐の解決ができていない。




20190614金
・isCano(x,core)を作るためcanoのlsymのリストを作っておくことにした
　これはcoreにいれよう(なくてもなんとかなりそうだけど)

・isProc(x,core)は、procがevalされているので
　isa(lsym, Function)で判定する。このlsymはSymbolではなく関数名で
　あり、未定義の名前だと例外が発生するのでtry-catchで補足する

これらの関数をviewreso.jlに追加し、testviewreso.jlを作った
load_viewprover.jlを作成した。

・vlogic/vlogic.jlはviewとlogicが混じっているので分離したい
とりあえず、geneを使わないバージョンを作ってそれに

genieを組み合わせたい。
 ファイルの再構成
 vlogic.jl => vlogic0.jl (記念にのこす)
 viewlogic.jl を新しいvlogic.jl相当にしたので、vlogic.jl == vlogic0.jlになった


20190609日
・factify_clause()の関数名を昨日かえてしまったのだけれど
  genieで動かすvloigc.jlで呼んでいたのでもどした。
  viewreso.jlにこの関数だけはいっていたので、factify.jlという名前で
　追加し、動くことを確認した。

・Viewで入力した値は、fact literalを作っておくとproofに残るという点が
　メリット



20190608土
みなおし

関数名をrefute_goal()とし、glidでなくgoal全体を対象として[]を目指す関数と
とらえた。

3つのステップ
1. remove_false() or revmove_by_evaluation() or compIt()
 juliaの式としてevaluateし符号も含めてfalseならそのliteral=式を消す。
 trueならclause全体がtrueとなるので、refutation全体が無効になる。
　これを:FAILという名前の例外を飛ばしてよいのか???
 自然な前提として、このようなliteralはground literalである。
 groundかどうかをチェックしてからevalするかどうか。同じようことを二度する
　ことになるので、ground checkは不要。


  1) 実行可能なliteralは定義のある述語のliteralなので、CORE.procにある関数は
　　残りの述語として数えなくていい。その変数はresolutionがだめでも
　　askyouで必ず消せるから。消せなかったらrefute失敗

    残りのliteralがすべてproc述語で、groundなものが残っていれば
　　refute失敗。(か、その条件を満たす変数を不定の解として) と考えられる。

　　proc literalはoppositeにあっても、分岐条件なのでresolutionする必要がない。
　　それは+P(x)と-P(x)のモデルが共有されないということ。つまり同じxが両方の
　　clauseで存在できないので、resolutionする意味がない。

　　resolutionするときliteralを消せるのは、共通のxのモデルがあるから。
　　分岐では、それらのliteralには
　　　1) 共通のモデルがない
　　という条件を前提としていて、executableというのはまさにそういういみ。
　　現実世界で、p(x)かつ!p(x)がないのだから、resolutionには意味がないということ。

　　resolutionでは形式的にでもそのようなxがあるとして、矛盾すると言っている。
　　しかしそのようなxが存在できないのなら、p(x)と!p(x)で分けてrefuteすればよい。
　　・・・というようなことか。よくわからない。

2. remove_with_base() or remove_by_resolution() or inferIt()
 これは、goalのliteralをcoreのbaseで消す。
　グラフでは、goalのpsymのopponentにぶら下がるノードがあれば実行できる。

 いくつか問題
 1) ぶらさがるノードの中で1つだけが適用可能なら、安心してresolutionしてみればよいが
　そうでない場合もありうる
 2) resolutionでglitを消すと、goalのliteralが増える場合もある。
 
 3) 複数のnodeがあると、それぞれについて新しいgoalがありうる。
　・あるgoalのrefuteに失敗した場合、バックトラックして別のgoalを試す(Depth first)か
　・ひととおりの新goalを作っておいて、順番にトライしていくか(breadth first)

　・複数のgoalがあったとき、refuteできそうなgoalを優先して行う。という方法もあるかも。
  　そのとき、「refuteできそうな」の評価方法は?

  ・(literalが増えたとき、)ground literalでevaluateできるものがあれば、減らせる。
　・グラフにoppositeがないliteralがあればaskyouで値を求める。
　・

 4) どのliteralから消していくか


 5) 消す方法は、viewにすべきかresolutionにすべきか
    判断基準はoppositeのリテラルの状態とclauseの状態が材料になりそう。
    一番簡単な場合
　　　oppositがground unit clauseでunifiable
　　　oppositがunit clauseでunifiable

　　そういうものが複数あったらどうなるか。
　　　a) groundの場合、unifiableなら同一のliteralということなので
　　　　そのliteralはviewにしても意味がない(つまりconfirmしか得られない)
　　　　だから、そのliteralについてはresolutionしか必要ない。

　　　b) 変数があるときは、標準形の変数が減るようなlitralがあったら
　　　　resolutionは有望かもしれない。
　　　　resolventができたときのlitral数は少ないにこしたことはないが
　　　　evalで消えるものなら数えなくていい。


　評価基準案
  ・案1) 式に含まれる変数の数をみて、0に近いものはgroundに近いとする。
　・案2) Canonicalを情報1とし、ground clauseはすべて0とするのもある。
    これを<:>で評価できるか??
    空代入φは<P^c:P^c>=<P_g:P_g>=φ
　　P_gはgroundliteralであり、同じliteralの場合
　　ground literalは異なるものがいろいろあり、
    <P_{g_1}:P_{g_1}>は常にφであり(これはなんでもこう)
    <P_{g_1}:P_{g_2}>は失敗する。
    canonをP^cと書くとすると、<P^c:P^c> = φであり、

　　何かリテラルPが与えられたとき、

　　<P^c:P> = φは必ず存在する。

　 このφの形によって、[]に近いかどうかを判定できないか??


3. remove_with_askyou()
 これは、goalのliteralをcoreでは消せないとき、Viewでexternalに問い合わせる。
 externalが人間の場合のこと(AIプログラムが世界に対する判断をこのような形
で受け取ることが一つのテーマだが、それは難しいのでこの方法で試している)

 グラフでは、goalのpsymのopponentにぶら下がるノードがあれば実行できる。
 opponentにぶら下がるノードがあっても実行して悪いわけではないとも思う。
★　たとえば、resolutionで進展しないときに、人間に問い合わせるとか

 この考え方はよいのだがコードについて。
 literalからPageのhtmlを作り、そのurlをBrowserで開いて
人間が入力し、confirmすると別のurlでその値を受け取る。

htmlを作るところと、値を受け取るところは、同じ計算環境(session)
だが、計算のブロックとしては別になってしまう。

このような位相のπ/2のずれのようなことをわかりやすい形で記述できないか。
htmlの前と後で分けた時、一連の処理なのにもかかわらず計算が
分割されてしまう。

schemeかlispで何かフレームワークがあったような気がする。
具体的には知らないので、すこし考えてみよう。

★そのほかの問題
 1) resolutionとaskyouの順番
   removebyevaluation()はgroundに対してしか行われないので、この2つとは独立
　 resolutionとaskyouの場合、どちらも変数をinstance化していく。

   resolutionでいくつかの変数に定数が入った後にaskyouをすると、
　わかっている項目に初期値が入るようなことに対応して、おもしろい

　しかし、人間に聞いてわかることであれば、askyouで変数の値を決めて
　おけば無駄にresolutionしなくてもよい。つまり、resolutionを効率よく適用
　できたり、resolutionを回避できたりする。

　





20190606木
applytemp()の末尾
map(rid->lidsof(rid, core),rids)
の部分は正しいのか?
ridのlidsof()をとるのはいいが、グラフのPにぶらさがっているliteral
すべてにこれをしてどういう意味が??

viewreso.jlに追加
evalation(glid, core) を作ってみたが、この関数は何をすべきか。
glidがevalしてfalseになったとき、goalからglidを消したい。
その点はできていない。

go_resolution()は、graphでglidの相手がいたら、resolutionで
消去する。



20190605水
・unify(vars, array, array)を追加した。testも
・testnewcoreが昨日の分未修正だったので修正した

20190604火
・COREにcanonicalを追加
・printcore()の修正など

20190602日
・goalの引数に定数があるときの処理を考えた。
標準リテラルが必要になり、ややこしくなる。

今のままで、GUIダケでなんとかならないか考えたが、やはり無理そう。

・goalが[]になったとき、confirmすると/startlogicに戻るようにした。
　readcoreをしたとき、フラグをもう一度trueにする修正必要


20190601土
今週は、vlogic.jlとviewreso.jlをnavinavi/genieで作っていた。

coreやclausesをhtmlで表示するためにcorestring.jlを作ったのは今週ではなかっただろうか。

いちおう動くようになったので、vlogicをcheaplogicにコピーした。

動かしかた
@Prover
$ julia
> include("load_vlogic.jl")
vdata/vl002.cnf だと、2回glitを使えば[]になる

TODO:
1) goal literalの消去の方法は3つある
　(1) baseとのresolution
  (2) executeしてfalseになるとき消去
  (3) Viewで消滅させる
　* 消していく順番を決定する方法

1) もとのliteralの引数が定数の場合、その定数がviewに反映されない。
2) cancelまたは ViewのFactが -Pであるような場合
3) lvarsofがvarsofと同じになっている。
　 変数をliteralにあわせるには、標準literalが必要


20190512日
{GoalKeeper- Genie- SQLite}
ここ数日、webのViewとproverをつなぐ仕組みを考えていた。
clauseの集合Baseと、アプリの目的を示すclause Goal(B+G)を与えて
Viewで何かを決定すると、対応するFactが作られて
それをつかってF+B+GでGoalを変化させていくというイメージ。

外部でFactを作るという考えを試すのによいのではないか?

考えたこと
0. B+Gで、どの述語にViewを対応させるかは、あらかじめ定義しておく必要がある。
　　動的にPageを作るというのであれば、ここは自由だが・・(*ここ不十分)

1. Goalに対してBaseを適用して、Goalのリテラルが、Viewを持つものになるまで
　 変形していく。

2. すべてがViewを持つ=Factになりうる必要はないように思うが(*ここ不十分)
　 複数のLiteral in GoalがFactableになるまで変形すると、(*ここ不十分)
   FactableでないLiteralをのぞいて、
   Goalに対してPageの集合が対応し、Web画面が起動する。

*Factableは造語
 (factorialと似ているので、似た言葉がすでにあるのかもしれない
  ちょっと調べたがfactableは辞書にはなかった)

3 Factはground unit clauseかどうか
  -ViewでEntry Sheetみたいなものを考える。
　 そのとき、入力の必要のない項目は、変数のままにしておけばいいはずなので
　 GroundでないFact clauseがあってもいいのではないか。
　 Partial Fact。
　 Unit ClauseはPartial Factということか。

4. Factable LiteralとViewの対応はvarsになる。
　 FL と Vの間は、標準Literalを介してデータが相互に渡る。
   標準Literalは、引数がすべて異なる変数のリテラル。
　 Factable と標準をunifyすると、そのσはViewに表示すべき項目の値になる。
　 Pageはvarsを持つので、そのσをPageに適用すると、計算できる。

　 Pageで入力がconfirmされたときは、Pageのもつvarsに対する代入σも決まるので
　 pageのvarsは標準literalのvarsと同じであり
　 そのσをFactable≈標準に適用すれば、Viewから得たFactリテラルが作れる。

課題
・中間resolvent
  BにはFactableでないリテラルがあると思う。

  Viewから見ると、Logicに関連しており、画面遷移の論理ではあるが
　見た目とは関係ないもの。

・Viewの出現タイミング(Tabか遷移か)
  Goalの変換で、どこまでproofを進めればよいか?

  1) Goalに1つでもFactableがでてくるまで進めて、Factableに対応するViewを
　　 UIで示す。
     1Pageが遷移していくものになり、画面遷移をLogicで書きたくなるかもしれない。
     それは望まない。証明の都合で、画面遷移が変わるとか・・・

  2) GoalがすべてFactableになるまで証明を進めて、Goal単位でPageに変換する。
　　　並列でPageがでるので、Tab切り替えのようなものになるのではないか。

  3) Factの変換とViewの遷移のタイミング・・・

　4) Pageのある変数が別のPageの変数として使われているかもしれない。
　　そのとき、varsに対するσとして適用と反映をpageごとに行えば
　　同期がとれる。
　　この同期のとりかたは、Factとの同期と一致しているはず。

　5) Goalが複数のclauseになるとき
　　1 clause goalに対して、複数のclauseが適用でき、その結果
　  goalが複数になることはありうる。

　　Viewから見ると、tabで別れたPageが複数でてくる。
　　利用者はそれらのPageのどれか一つを入力しきればいい・・・

　6)条件のある場合、異なるPageになるはず。だがリテラルと条件の対応はわからない。

　7)





・executable literal に相当するのが factable.

・


▪️ Juliaで実装するとき、WebアプリのフレームワークとしてGenieというのがあって
Railsみたいにつかえる。WebからJuliaの関数を呼び出せるのはよい。
ということでGenieを調べている。

GenieでSQLiteを使っていたので、SQLiteをインストールした。
HPからとってきたファイルはsqlite3とsqldiff, analyzerのみ。
これですべてらしい・・・Liteだ。

DBは動くようなので、さらに、 Genieで, DB関連のものらしい
SearchLiteというモジュールを使っていたので
] add https://github.com/essenciary/SearchLight.jl
したが、途中でエラーになり中断。
LibPQで失敗しているらしい。

DBはなくてもよいし、 面倒なのでやめ。

きちんとドキュメントを読んでいないからかも。

▪️ Genieは Rendrerが使えれば十分だと思う。

View-Logicのお試し版はGoalkeeperという名前にした。
Goalを[]にする目的でrefuteしていくので。

### GoalKeeperについて

方法
まずは、単純な画面から作っていく。
20190504
Factを動的に追加してくシステムを作ろうかと思う。reactlogicと呼ぶことにする。

1 simpleproverを参考に考えてみたが、factを追加すると、cdb, ldb, templateを
updateする必要があり、 記号もふえるかもしれない。
evalonの処理は気にしなくてもいいような気がする。

2 factを追加する処理、updateと、factが追加されたら、goal x new Axiomsで
  証明を進める処理の2つが必要で、reactlogic.jlに枠だけ作っている。
  進められるところまで証明をすすめて、goal2ができる。
  それが[]なら、終わり。

　1ステップでなく、進められるところまで進めるのは、1つのgoalから
　共通の子供になる複数のresolventがでてくるのをとめるため。

　[g1,g2,g3] x {a1,a2,a3}で
　g1, a1 => 0
  g2, a2 => 0
　だったら、1ステップだと[g2,g3]と[g1,g3]ができてしまい、[g3]ができないとなると
　今できるはずの[g3]が次以降のステップにでてこなくてはならないことになり、ややこしい。

  そこで、[g2,g3]と[g1,g3]は途中ででるけれど、最終的なresolventとしては[g3]のみとする。
　これで問題になりそうなのは、新しいfactが前ステップにでてきたresolventを置き換えるような場合。
　上の例で考えると、次のステップでa4が加えられて、g2, a4 => 0となるとき
　もはやg2はないので、このa4は[]生成に関与しない。

　動的に変更されるaxiomという枠組みの中で、これは避けられない。

3. 現実的には、小さいaxiomsであれば、毎回、全axiomsから[]を導出するのでもよいかもしれない。

  ただし、途中のgoalを調べることで、まだ未解決の条件が何かを知りうるので、



20190503
 play.jlにあったreadstring()が未定義だったので、read(file, String)に変更した。
 1step proverを作ろうかと思ったかが、dostep1goalsがplay.jlで使われていて
 それの使い方を調べていた。
 テンプレートを一回適用する関数らしいので、だいたい目的にあっている。

 commitしようとしたら、未commitのdocsがたくさんあった。

---
実世界での操作から述語を生成(GUIとか機械学習による)し
それに基づいて証明を進めるという考え方の検討

runkb.jl, kb00[0-3].cnf
途中の状況があまり鮮明に描けないが、kb003.cnfで、作られたresolventを確認すると
必要なものはとれている。
原理が単純なのでよいと思う。

1. イベントからclauseが生成され
2. そのclauseを使って、goalから新しいresolventを作る
3. それが[]なら、完了

という仕組みはできるはず。

イベントの部分はreplを使えばよいだろう





20190424
1. in cheaplogic, unify0snとunify0nsでisvarの判定する引数が逆だった
naiveとcheapが同じ結果になる

20190421
1. check TPU of Chang&Lee
   the definition of substitution is different.
2. investigating ml007, what is different naive and cheap.
   naiveでは9個の[]ができるのに、cheaplogicでは1つもできない
   R10まではcheaplogicでもつくれているが、その先がないin cheaplogic.

20190420
Problem: How about the original algorithm?
Do for it.
1) preparation: reso.jl to reso.jl, unify.jl and others
2) test it
3) make naiveunify.jl for the original algorithm
4) test it

1. First, I think test_unify.jl is enough for naiveunify.jl
   But, some functions as fp_unify() should not need in naive,
   I made test_naiveunify.jl. 
   If I want to compare two unify(), I need common tests.
 


20190413
I clearfed the concepts about substitution-apply-unify.

1. Substitution(Σ) can have {x<-f(x)}
   Σ=VxT

2. apply(α) replaces a var with the corresponding term simulteniously.
   Because it, the substituion can be express unambiguously as 
    (v1,v2,v3) <- (t1,2,t3) without {}

   α: T x Σ → T
   α: Σ x Σ → Σ 

3. <x:f(x)> fails. It is caused by inside check.
   This doesn't except x<-f(x) from substitution.

   <> : T x T → Σ

I thought yesterday, this is not correctly implemented now.
But today reso.jl should be correct. 
I clearfy some tests around this.


