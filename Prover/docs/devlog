20190615土
viewreso.jlがsyntaxこわれていたので整理

vlogic0.jlとvhtmls.jl はGenieで targetを/go一個にし
targetの区別をopで行うようにした

実質的には前のvlogic.jlと同じような気もするが、
分岐を1つのrouteで表現できるのでましか。

globalを使っている箇所をsessionID+sessionDataで表現すれば
複数のcnfも扱える


証明の分岐の解決ができていない。




20190614金
・isCano(x,core)を作るためcanoのlsymのリストを作っておくことにした
　これはcoreにいれよう(なくてもなんとかなりそうだけど)

・isProc(x,core)は、procがevalされているので
　isa(lsym, Function)で判定する。このlsymはSymbolではなく関数名で
　あり、未定義の名前だと例外が発生するのでtry-catchで補足する

これらの関数をviewreso.jlに追加し、testviewreso.jlを作った
load_viewprover.jlを作成した。

・vlogic/vlogic.jlはviewとlogicが混じっているので分離したい
とりあえず、geneを使わないバージョンを作ってそれに

genieを組み合わせたい。
 ファイルの再構成
 vlogic.jl => vlogic0.jl (記念にのこす)
 viewlogic.jl を新しいvlogic.jl相当にしたので、vlogic.jl == vlogic0.jlになった


20190609日
・factify_clause()の関数名を昨日かえてしまったのだけれど
  genieで動かすvloigc.jlで呼んでいたのでもどした。
  viewreso.jlにこの関数だけはいっていたので、factify.jlという名前で
　追加し、動くことを確認した。

・Viewで入力した値は、fact literalを作っておくとproofに残るという点が
　メリット



20190608土
みなおし

関数名をrefute_goal()とし、glidでなくgoal全体を対象として[]を目指す関数と
とらえた。

3つのステップ
1. remove_false() or revmove_by_evaluation() or compIt()
 juliaの式としてevaluateし符号も含めてfalseならそのliteral=式を消す。
 trueならclause全体がtrueとなるので、refutation全体が無効になる。
　これを:FAILという名前の例外を飛ばしてよいのか???
 自然な前提として、このようなliteralはground literalである。
 groundかどうかをチェックしてからevalするかどうか。同じようことを二度する
　ことになるので、ground checkは不要。


  1) 実行可能なliteralは定義のある述語のliteralなので、CORE.procにある関数は
　　残りの述語として数えなくていい。その変数はresolutionがだめでも
　　askyouで必ず消せるから。消せなかったらrefute失敗

    残りのliteralがすべてproc述語で、groundなものが残っていれば
　　refute失敗。(か、その条件を満たす変数を不定の解として) と考えられる。

　　proc literalはoppositeにあっても、分岐条件なのでresolutionする必要がない。
　　それは+P(x)と-P(x)のモデルが共有されないということ。つまり同じxが両方の
　　clauseで存在できないので、resolutionする意味がない。

　　resolutionするときliteralを消せるのは、共通のxのモデルがあるから。
　　分岐では、それらのliteralには
　　　1) 共通のモデルがない
　　という条件を前提としていて、executableというのはまさにそういういみ。
　　現実世界で、p(x)かつ!p(x)がないのだから、resolutionには意味がないということ。

　　resolutionでは形式的にでもそのようなxがあるとして、矛盾すると言っている。
　　しかしそのようなxが存在できないのなら、p(x)と!p(x)で分けてrefuteすればよい。
　　・・・というようなことか。よくわからない。

2. remove_with_base() or remove_by_resolution() or inferIt()
 これは、goalのliteralをcoreのbaseで消す。
　グラフでは、goalのpsymのopponentにぶら下がるノードがあれば実行できる。

 いくつか問題
 1) ぶらさがるノードの中で1つだけが適用可能なら、安心してresolutionしてみればよいが
　そうでない場合もありうる
 2) resolutionでglitを消すと、goalのliteralが増える場合もある。
 
 3) 複数のnodeがあると、それぞれについて新しいgoalがありうる。
　・あるgoalのrefuteに失敗した場合、バックトラックして別のgoalを試す(Depth first)か
　・ひととおりの新goalを作っておいて、順番にトライしていくか(breadth first)

　・複数のgoalがあったとき、refuteできそうなgoalを優先して行う。という方法もあるかも。
  　そのとき、「refuteできそうな」の評価方法は?

  ・(literalが増えたとき、)ground literalでevaluateできるものがあれば、減らせる。
　・グラフにoppositeがないliteralがあればaskyouで値を求める。
　・

 4) どのliteralから消していくか


 5) 消す方法は、viewにすべきかresolutionにすべきか
    判断基準はoppositeのリテラルの状態とclauseの状態が材料になりそう。
    一番簡単な場合
　　　oppositがground unit clauseでunifiable
　　　oppositがunit clauseでunifiable

　　そういうものが複数あったらどうなるか。
　　　a) groundの場合、unifiableなら同一のliteralということなので
　　　　そのliteralはviewにしても意味がない(つまりconfirmしか得られない)
　　　　だから、そのliteralについてはresolutionしか必要ない。

　　　b) 変数があるときは、標準形の変数が減るようなlitralがあったら
　　　　resolutionは有望かもしれない。
　　　　resolventができたときのlitral数は少ないにこしたことはないが
　　　　evalで消えるものなら数えなくていい。


　評価基準案
  ・案1) 式に含まれる変数の数をみて、0に近いものはgroundに近いとする。
　・案2) Canonicalを情報1とし、ground clauseはすべて0とするのもある。
    これを<:>で評価できるか??
    空代入φは<P^c:P^c>=<P_g:P_g>=φ
　　P_gはgroundliteralであり、同じliteralの場合
　　ground literalは異なるものがいろいろあり、
    <P_{g_1}:P_{g_1}>は常にφであり(これはなんでもこう)
    <P_{g_1}:P_{g_2}>は失敗する。
    canonをP^cと書くとすると、<P^c:P^c> = φであり、

　　何かリテラルPが与えられたとき、

　　<P^c:P> = φは必ず存在する。

　 このφの形によって、[]に近いかどうかを判定できないか??


3. remove_with_askyou()
 これは、goalのliteralをcoreでは消せないとき、Viewでexternalに問い合わせる。
 externalが人間の場合のこと(AIプログラムが世界に対する判断をこのような形
で受け取ることが一つのテーマだが、それは難しいのでこの方法で試している)

 グラフでは、goalのpsymのopponentにぶら下がるノードがあれば実行できる。
 opponentにぶら下がるノードがあっても実行して悪いわけではないとも思う。
★　たとえば、resolutionで進展しないときに、人間に問い合わせるとか

 この考え方はよいのだがコードについて。
 literalからPageのhtmlを作り、そのurlをBrowserで開いて
人間が入力し、confirmすると別のurlでその値を受け取る。

htmlを作るところと、値を受け取るところは、同じ計算環境(session)
だが、計算のブロックとしては別になってしまう。

このような位相のπ/2のずれのようなことをわかりやすい形で記述できないか。
htmlの前と後で分けた時、一連の処理なのにもかかわらず計算が
分割されてしまう。

schemeかlispで何かフレームワークがあったような気がする。
具体的には知らないので、すこし考えてみよう。

★そのほかの問題
 1) resolutionとaskyouの順番
   removebyevaluation()はgroundに対してしか行われないので、この2つとは独立
　 resolutionとaskyouの場合、どちらも変数をinstance化していく。

   resolutionでいくつかの変数に定数が入った後にaskyouをすると、
　わかっている項目に初期値が入るようなことに対応して、おもしろい

　しかし、人間に聞いてわかることであれば、askyouで変数の値を決めて
　おけば無駄にresolutionしなくてもよい。つまり、resolutionを効率よく適用
　できたり、resolutionを回避できたりする。

　





20190606木
applytemp()の末尾
map(rid->lidsof(rid, core),rids)
の部分は正しいのか?
ridのlidsof()をとるのはいいが、グラフのPにぶらさがっているliteral
すべてにこれをしてどういう意味が??

viewreso.jlに追加
evalation(glid, core) を作ってみたが、この関数は何をすべきか。
glidがevalしてfalseになったとき、goalからglidを消したい。
その点はできていない。

go_resolution()は、graphでglidの相手がいたら、resolutionで
消去する。



20190605水
・unify(vars, array, array)を追加した。testも
・testnewcoreが昨日の分未修正だったので修正した

20190604火
・COREにcanonicalを追加
・printcore()の修正など

20190602日
・goalの引数に定数があるときの処理を考えた。
標準リテラルが必要になり、ややこしくなる。

今のままで、GUIダケでなんとかならないか考えたが、やはり無理そう。

・goalが[]になったとき、confirmすると/startlogicに戻るようにした。
　readcoreをしたとき、フラグをもう一度trueにする修正必要


20190601土
今週は、vlogic.jlとviewreso.jlをnavinavi/genieで作っていた。

coreやclausesをhtmlで表示するためにcorestring.jlを作ったのは今週ではなかっただろうか。

いちおう動くようになったので、vlogicをcheaplogicにコピーした。

動かしかた
@Prover
$ julia
> include("load_vlogic.jl")
vdata/vl002.cnf だと、2回glitを使えば[]になる

TODO:
1) goal literalの消去の方法は3つある
　(1) baseとのresolution
  (2) executeしてfalseになるとき消去
  (3) Viewで消滅させる
　* 消していく順番を決定する方法

1) もとのliteralの引数が定数の場合、その定数がviewに反映されない。
2) cancelまたは ViewのFactが -Pであるような場合
3) lvarsofがvarsofと同じになっている。
　 変数をliteralにあわせるには、標準literalが必要


20190512日
{GoalKeeper- Genie- SQLite}
ここ数日、webのViewとproverをつなぐ仕組みを考えていた。
clauseの集合Baseと、アプリの目的を示すclause Goal(B+G)を与えて
Viewで何かを決定すると、対応するFactが作られて
それをつかってF+B+GでGoalを変化させていくというイメージ。

外部でFactを作るという考えを試すのによいのではないか?

考えたこと
0. B+Gで、どの述語にViewを対応させるかは、あらかじめ定義しておく必要がある。
　　動的にPageを作るというのであれば、ここは自由だが・・(*ここ不十分)

1. Goalに対してBaseを適用して、Goalのリテラルが、Viewを持つものになるまで
　 変形していく。

2. すべてがViewを持つ=Factになりうる必要はないように思うが(*ここ不十分)
　 複数のLiteral in GoalがFactableになるまで変形すると、(*ここ不十分)
   FactableでないLiteralをのぞいて、
   Goalに対してPageの集合が対応し、Web画面が起動する。

*Factableは造語
 (factorialと似ているので、似た言葉がすでにあるのかもしれない
  ちょっと調べたがfactableは辞書にはなかった)

3 Factはground unit clauseかどうか
  -ViewでEntry Sheetみたいなものを考える。
　 そのとき、入力の必要のない項目は、変数のままにしておけばいいはずなので
　 GroundでないFact clauseがあってもいいのではないか。
　 Partial Fact。
　 Unit ClauseはPartial Factということか。

4. Factable LiteralとViewの対応はvarsになる。
　 FL と Vの間は、標準Literalを介してデータが相互に渡る。
   標準Literalは、引数がすべて異なる変数のリテラル。
　 Factable と標準をunifyすると、そのσはViewに表示すべき項目の値になる。
　 Pageはvarsを持つので、そのσをPageに適用すると、計算できる。

　 Pageで入力がconfirmされたときは、Pageのもつvarsに対する代入σも決まるので
　 pageのvarsは標準literalのvarsと同じであり
　 そのσをFactable≈標準に適用すれば、Viewから得たFactリテラルが作れる。

課題
・中間resolvent
  BにはFactableでないリテラルがあると思う。

  Viewから見ると、Logicに関連しており、画面遷移の論理ではあるが
　見た目とは関係ないもの。

・Viewの出現タイミング(Tabか遷移か)
  Goalの変換で、どこまでproofを進めればよいか?

  1) Goalに1つでもFactableがでてくるまで進めて、Factableに対応するViewを
　　 UIで示す。
     1Pageが遷移していくものになり、画面遷移をLogicで書きたくなるかもしれない。
     それは望まない。証明の都合で、画面遷移が変わるとか・・・

  2) GoalがすべてFactableになるまで証明を進めて、Goal単位でPageに変換する。
　　　並列でPageがでるので、Tab切り替えのようなものになるのではないか。

  3) Factの変換とViewの遷移のタイミング・・・

　4) Pageのある変数が別のPageの変数として使われているかもしれない。
　　そのとき、varsに対するσとして適用と反映をpageごとに行えば
　　同期がとれる。
　　この同期のとりかたは、Factとの同期と一致しているはず。

　5) Goalが複数のclauseになるとき
　　1 clause goalに対して、複数のclauseが適用でき、その結果
　  goalが複数になることはありうる。

　　Viewから見ると、tabで別れたPageが複数でてくる。
　　利用者はそれらのPageのどれか一つを入力しきればいい・・・

　6)条件のある場合、異なるPageになるはず。だがリテラルと条件の対応はわからない。

　7)





・executable literal に相当するのが factable.

・


▪️ Juliaで実装するとき、WebアプリのフレームワークとしてGenieというのがあって
Railsみたいにつかえる。WebからJuliaの関数を呼び出せるのはよい。
ということでGenieを調べている。

GenieでSQLiteを使っていたので、SQLiteをインストールした。
HPからとってきたファイルはsqlite3とsqldiff, analyzerのみ。
これですべてらしい・・・Liteだ。

DBは動くようなので、さらに、 Genieで, DB関連のものらしい
SearchLiteというモジュールを使っていたので
] add https://github.com/essenciary/SearchLight.jl
したが、途中でエラーになり中断。
LibPQで失敗しているらしい。

DBはなくてもよいし、 面倒なのでやめ。

きちんとドキュメントを読んでいないからかも。

▪️ Genieは Rendrerが使えれば十分だと思う。

View-Logicのお試し版はGoalkeeperという名前にした。
Goalを[]にする目的でrefuteしていくので。

### GoalKeeperについて

方法
まずは、単純な画面から作っていく。
20190504
Factを動的に追加してくシステムを作ろうかと思う。reactlogicと呼ぶことにする。

1 simpleproverを参考に考えてみたが、factを追加すると、cdb, ldb, templateを
updateする必要があり、 記号もふえるかもしれない。
evalonの処理は気にしなくてもいいような気がする。

2 factを追加する処理、updateと、factが追加されたら、goal x new Axiomsで
  証明を進める処理の2つが必要で、reactlogic.jlに枠だけ作っている。
  進められるところまで証明をすすめて、goal2ができる。
  それが[]なら、終わり。

　1ステップでなく、進められるところまで進めるのは、1つのgoalから
　共通の子供になる複数のresolventがでてくるのをとめるため。

　[g1,g2,g3] x {a1,a2,a3}で
　g1, a1 => 0
  g2, a2 => 0
　だったら、1ステップだと[g2,g3]と[g1,g3]ができてしまい、[g3]ができないとなると
　今できるはずの[g3]が次以降のステップにでてこなくてはならないことになり、ややこしい。

  そこで、[g2,g3]と[g1,g3]は途中ででるけれど、最終的なresolventとしては[g3]のみとする。
　これで問題になりそうなのは、新しいfactが前ステップにでてきたresolventを置き換えるような場合。
　上の例で考えると、次のステップでa4が加えられて、g2, a4 => 0となるとき
　もはやg2はないので、このa4は[]生成に関与しない。

　動的に変更されるaxiomという枠組みの中で、これは避けられない。

3. 現実的には、小さいaxiomsであれば、毎回、全axiomsから[]を導出するのでもよいかもしれない。

  ただし、途中のgoalを調べることで、まだ未解決の条件が何かを知りうるので、



20190503
 play.jlにあったreadstring()が未定義だったので、read(file, String)に変更した。
 1step proverを作ろうかと思ったかが、dostep1goalsがplay.jlで使われていて
 それの使い方を調べていた。
 テンプレートを一回適用する関数らしいので、だいたい目的にあっている。

 commitしようとしたら、未commitのdocsがたくさんあった。

---
実世界での操作から述語を生成(GUIとか機械学習による)し
それに基づいて証明を進めるという考え方の検討

runkb.jl, kb00[0-3].cnf
途中の状況があまり鮮明に描けないが、kb003.cnfで、作られたresolventを確認すると
必要なものはとれている。
原理が単純なのでよいと思う。

1. イベントからclauseが生成され
2. そのclauseを使って、goalから新しいresolventを作る
3. それが[]なら、完了

という仕組みはできるはず。

イベントの部分はreplを使えばよいだろう





20190424
1. in cheaplogic, unify0snとunify0nsでisvarの判定する引数が逆だった
naiveとcheapが同じ結果になる

20190421
1. check TPU of Chang&Lee
   the definition of substitution is different.
2. investigating ml007, what is different naive and cheap.
   naiveでは9個の[]ができるのに、cheaplogicでは1つもできない
   R10まではcheaplogicでもつくれているが、その先がないin cheaplogic.

20190420
Problem: How about the original algorithm?
Do for it.
1) preparation: reso.jl to reso.jl, unify.jl and others
2) test it
3) make naiveunify.jl for the original algorithm
4) test it

1. First, I think test_unify.jl is enough for naiveunify.jl
   But, some functions as fp_unify() should not need in naive,
   I made test_naiveunify.jl. 
   If I want to compare two unify(), I need common tests.
 


20190413
I clearfed the concepts about substitution-apply-unify.

1. Substitution(Σ) can have {x<-f(x)}
   Σ=VxT

2. apply(α) replaces a var with the corresponding term simulteniously.
   Because it, the substituion can be express unambiguously as 
    (v1,v2,v3) <- (t1,2,t3) without {}

   α: T x Σ → T
   α: Σ x Σ → Σ 

3. <x:f(x)> fails. It is caused by inside check.
   This doesn't except x<-f(x) from substitution.

   <> : T x T → Σ

I thought yesterday, this is not correctly implemented now.
But today reso.jl should be correct. 
I clearfy some tests around this.


