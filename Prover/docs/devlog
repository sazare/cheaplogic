20190512日
{GoalKeeper- Genie- SQLite}
ここ数日、webのViewとproverをつなぐ仕組みを考えていた。
clauseの集合Baseと、アプリの目的を示すclause Goal(B+G)を与えて
Viewで何かを決定すると、対応するFactが作られて
それをつかってF+B+GでGoalを変化させていくというイメージ。

外部でFactを作るという考えを試すのによいのではないか?

考えたこと
0. B+Gで、どの述語にViewを対応させるかは、あらかじめ定義しておく必要がある。
　　動的にPageを作るというのであれば、ここは自由だが・・(*ここ不十分)

1. Goalに対してBaseを適用して、Goalのリテラルが、Viewを持つものになるまで
　 変形していく。

2. すべてがViewを持つ=Factになりうる必要はないように思うが(*ここ不十分)
　 複数のLiteral in GoalがFactableになるまで変形すると、(*ここ不十分)
   FactableでないLiteralをのぞいて、
   Goalに対してPageの集合が対応し、Web画面が起動する。

*Factableは造語
 (factorialと似ているので、似た言葉がすでにあるのかもしれない
  ちょっと調べたがfactableは辞書にはなかった)

3 Factはground unit clauseかどうか
  -ViewでEntry Sheetみたいなものを考える。
　 そのとき、入力の必要のない項目は、変数のままにしておけばいいはずなので
　 GroundでないFact clauseがあってもいいのではないか。
　 Partial Fact。
　 Unit ClauseはPartial Factということか。

4. Factable LiteralとViewの対応はvarsになる。
　 FL と Vの間は、標準Literalを介してデータが相互に渡る。
   標準Literalは、引数がすべて異なる変数のリテラル。
　 Factable と標準をunifyすると、そのσはViewに表示すべき項目の値になる。
　 Pageはvarsを持つので、そのσをPageに適用すると、計算できる。

　 Pageで入力がconfirmされたときは、Pageのもつvarsに対する代入σも決まるので
　 pageのvarsは標準literalのvarsと同じであり
　 そのσをFactable≈標準に適用すれば、Viewから得たFactリテラルが作れる。

課題
・中間resolvent
  BにはFactableでないリテラルがあると思う。

  Viewから見ると、Logicに関連しており、画面遷移の論理ではあるが
　見た目とは関係ないもの。

・Viewの出現タイミング(Tabか遷移か)
  Goalの変換で、どこまでproofを進めればよいか?

  1) Goalに1つでもFactableがでてくるまで進めて、Factableに対応するViewを
　　 UIで示す。
     1Pageが遷移していくものになり、画面遷移をLogicで書きたくなるかもしれない。
     それは望まない。証明の都合で、画面遷移が変わるとか・・・

  2) GoalがすべてFactableになるまで証明を進めて、Goal単位でPageに変換する。
　　　並列でPageがでるので、Tab切り替えのようなものになるのではないか。

  3) Factの変換とViewの遷移のタイミング・・・

　4) Pageのある変数が別のPageの変数として使われているかもしれない。
　　そのとき、varsに対するσとして適用と反映をpageごとに行えば
　　同期がとれる。
　　この同期のとりかたは、Factとの同期と一致しているはず。

　5) Goalが複数のclauseになるとき
　　1 clause goalに対して、複数のclauseが適用でき、その結果
　  goalが複数になることはありうる。

　　Viewから見ると、tabで別れたPageが複数でてくる。
　　利用者はそれらのPageのどれか一つを入力しきればいい・・・

　6)条件のある場合、異なるPageになるはず。だがリテラルと条件の対応はわからない。

　7)





・executable literal に相当するのが factable.

・


▪️ Juliaで実装するとき、WebアプリのフレームワークとしてGenieというのがあって
Railsみたいにつかえる。WebからJuliaの関数を呼び出せるのはよい。
ということでGenieを調べている。

GenieでSQLiteを使っていたので、SQLiteをインストールした。
HPからとってきたファイルはsqlite3とsqldiff, analyzerのみ。
これですべてらしい・・・Liteだ。

DBは動くようなので、さらに、 Genieで, DB関連のものらしい
SearchLiteというモジュールを使っていたので
] add https://github.com/essenciary/SearchLight.jl
したが、途中でエラーになり中断。
LibPQで失敗しているらしい。

DBはなくてもよいし、 面倒なのでやめ。

きちんとドキュメントを読んでいないからかも。

▪️ Genieは Rendrerが使えれば十分だと思う。

View-Logicのお試し版はGoalkeeperという名前にした。
Goalを[]にする目的でrefuteしていくので。

### GoalKeeperについて

方法
まずは、単純な画面から作っていく。
20190504
Factを動的に追加してくシステムを作ろうかと思う。reactlogicと呼ぶことにする。

1 simpleproverを参考に考えてみたが、factを追加すると、cdb, ldb, templateを
updateする必要があり、 記号もふえるかもしれない。
evalonの処理は気にしなくてもいいような気がする。

2 factを追加する処理、updateと、factが追加されたら、goal x new Axiomsで
  証明を進める処理の2つが必要で、reactlogic.jlに枠だけ作っている。
  進められるところまで証明をすすめて、goal2ができる。
  それが[]なら、終わり。

　1ステップでなく、進められるところまで進めるのは、1つのgoalから
　共通の子供になる複数のresolventがでてくるのをとめるため。

　[g1,g2,g3] x {a1,a2,a3}で
　g1, a1 => 0
  g2, a2 => 0
　だったら、1ステップだと[g2,g3]と[g1,g3]ができてしまい、[g3]ができないとなると
　今できるはずの[g3]が次以降のステップにでてこなくてはならないことになり、ややこしい。

  そこで、[g2,g3]と[g1,g3]は途中ででるけれど、最終的なresolventとしては[g3]のみとする。
　これで問題になりそうなのは、新しいfactが前ステップにでてきたresolventを置き換えるような場合。
　上の例で考えると、次のステップでa4が加えられて、g2, a4 => 0となるとき
　もはやg2はないので、このa4は[]生成に関与しない。

　動的に変更されるaxiomという枠組みの中で、これは避けられない。

3. 現実的には、小さいaxiomsであれば、毎回、全axiomsから[]を導出するのでもよいかもしれない。

  ただし、途中のgoalを調べることで、まだ未解決の条件が何かを知りうるので、



20190503
 play.jlにあったreadstring()が未定義だったので、read(file, String)に変更した。
 1step proverを作ろうかと思ったかが、dostep1goalsがplay.jlで使われていて
 それの使い方を調べていた。
 テンプレートを一回適用する関数らしいので、だいたい目的にあっている。

 commitしようとしたら、未commitのdocsがたくさんあった。

---
実世界での操作から述語を生成(GUIとか機械学習による)し
それに基づいて証明を進めるという考え方の検討

runkb.jl, kb00[0-3].cnf
途中の状況があまり鮮明に描けないが、kb003.cnfで、作られたresolventを確認すると
必要なものはとれている。
原理が単純なのでよいと思う。

1. イベントからclauseが生成され
2. そのclauseを使って、goalから新しいresolventを作る
3. それが[]なら、完了

という仕組みはできるはず。

イベントの部分はreplを使えばよいだろう





20190424
1. in cheaplogic, unify0snとunify0nsでisvarの判定する引数が逆だった
naiveとcheapが同じ結果になる

20190421
1. check TPU of Chang&Lee
   the definition of substitution is different.
2. investigating ml007, what is different naive and cheap.
   naiveでは9個の[]ができるのに、cheaplogicでは1つもできない
   R10まではcheaplogicでもつくれているが、その先がないin cheaplogic.

20190420
Problem: How about the original algorithm?
Do for it.
1) preparation: reso.jl to reso.jl, unify.jl and others
2) test it
3) make naiveunify.jl for the original algorithm
4) test it

1. First, I think test_unify.jl is enough for naiveunify.jl
   But, some functions as fp_unify() should not need in naive,
   I made test_naiveunify.jl. 
   If I want to compare two unify(), I need common tests.
 


20190413
I clearfed the concepts about substitution-apply-unify.

1. Substitution(Σ) can have {x<-f(x)}
   Σ=VxT

2. apply(α) replaces a var with the corresponding term simulteniously.
   Because it, the substituion can be express unambiguously as 
    (v1,v2,v3) <- (t1,2,t3) without {}

   α: T x Σ → T
   α: Σ x Σ → Σ 

3. <x:f(x)> fails. It is caused by inside check.
   This doesn't except x<-f(x) from substitution.

   <> : T x T → Σ

I thought yesterday, this is not correctly implemented now.
But today reso.jl should be correct. 
I clearfy some tests around this.


