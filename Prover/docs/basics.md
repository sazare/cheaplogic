# 記号について
## 動機
Unification について考えている。
いろいろなUnificationのアルゴリズムが存在し、それらを比較するのがややこしい。
エルブランの論文では、Unificationは規則として定義されているようなことが書かれていた(Unification Theoryという、一章in a book。検索して発見)

Unificationについて何かを言う時、表現の定義、代入の定義、変数の意味、そしてそれらの上にUnificationアルゴリズムが定義される。

たとえば変数をどうやって判定するか、それを表現の中に持つのかどうか、代入は順番に処理するのか、並行に処理するのか、Unificationのinside checkは変数の概念と切り離せない。表現の等価、代入の等価、renameの定義などなど、定義したとしてそれがwell definedかどうかもよくわからない。
そこで、一から考えてみようというのが、ここの意図　動機である。

## 表現
表現はsymbolから構成される。
面倒なのでS-式を表現だと考える。symbolがatom。

expr::= symbol | expr*

expr* ::= () | (symbol . expr*)

例) a, x, (f x), (f x (g y)). ((a) (f x) (g h))は表現ではない。


まだ、変数は考えない。
変数はLogicからくる概念であり、表現と代入の世界は記号だけの世界なので、変数をいれずに考えてみる。
限界がきたら、導入するが、どういう不都合があるのかをみたい。

### 表現の同一性
e1 = e2は、表現の定義に従って定義する。

e1,e2がsymbolであり、同じsymbolならe1=e2はtrue
片方がsymbolでない表現なら e1=e2はfalse
両方がsymbolでない場合は、expr*の長さが同じで、すべての要素が同じなら e1=e2はtrue。
そうでなければe1=e2はfalse。

symbolの同一性は定義されているとする。

### 部分表現
e1の一部としてe2が出現していたら、e2はe1の部分表現になっている、というような言い方をする。
e2 < e1 というふうに書く。四角い<がよいのだけど、キーボードにないので、<にする。

同じeについては、e <= eということにしておく。


### 表現の同値
表現の同値関係、e1〜e2みたいなのは、変数がなければ登場しないと思うので、まだでてこない。

## 代入
代入は、ふつうは{変数i<-表現i}のような形で導入され、表現に対する代入操作をへて、表現+代入という世界に至ると思うが、その代入操作のバリエーションがいろいろあったり、明確に定義されていなかったりしてややこしいので、一歩一歩定義したい。

### 代入の表記
a) [s <- e] を基本と考える。記号sを表現eで置き換えるということを意味する。
　　任意の表現Eに対して、E*[s<-e]は、Eに出現する記号sをeに置き換える。
　この定義の曖昧なところは、eの中にsが出現している場合、どうするのかということ。

b) [s1 <- e1, s2 <- e2, ..., sk <-ek]
c) [s1,s2,...,sk] <- [e1,e2,...,ek]

#### 注意点
代入を{v <- t,...}のように書くことがあるが、集合として書くということは
表現の順番は重要ではないということだが、代入は非可換な操作であり、
順番を無視するには他にも制約条件が必要である。
だから、ここでは[]として、リスト表現にする。

定義
σ= [s1 <- e1, s2 <- e2, ..., sk <-ek]
のとき
L(σ) = {s1,s2,...,sk}
R(σ) = {e1,e2,...,ek}

S(e) : eに出現するsymbolの集合
SL(σ) = S(L(σ)) = L(σ)
と書く。
SR(σ) = S(R(σ)) 
は、代入のe側に出現するsymbolの集合である。


### 代入操作の定義
いくつかの定義が考えられる

a) e*[s <- e] 

b) (e*[s1 <- e1])*[s2 <- e2]

c) e*([s1 <- e1]*[s2 <- e2])


性質1)
σ1*σ2 は σ2*σ1と等しいとは限らない　非可換


*代入操作案1
e*[s1 <- e1, s2 <- e2, ..., sk <-ek] = (...((e*[s1 <- e1])*[s2 <- e2])...)


*並列代入(仮
σ=σ1+σ2+...+σk
のとき、
σ1からσkを入れ替えたすべての組み合わせについて、任意のeについて
e*σi1*σi2*...*σik
が同じ値のとき、そのσは並列代入可能であると考え
[s1,s2,...,sk]<-[e1,e2,...,ek]
と表記する。

このような定義に意味があるのだろうか?
たとえば、並列代入可能な代入の集合は定義できるだろうか。
そのような集合Σcが存在したとして、その要素の二つのσ1とσ2は可換だろうか。

並列代入は必要だろうか。ないとどれくらい議論の展開が大変になるだろうか。

一般に定義にはいくつかの方法がある。
1) 表現の定義。代入を[s<-e]と表記するとかいうこと
2) 代入操作の定義。
3) 表現の間の関係や操作の間の関係
4) 直感的な概念に適合しているかどうか

注意すべき点
1) 代入の意味は、代入操作が適切に定義されるかどうかによってきまる。
   well definedかどうか
2) 定義できたとして、それが役に立つか、議論を進める上で無駄なステップが発生しないか。


*空代入を[]と書くとすると、
空代入は、代入の合成において、単位元であり
a) e*[] = e
が成り立つ。

[]と書いているが、本当はすべてのsymbol siについて
[s1<-s1,s2<-s2,...](無限)
と書いているのと同じである。

{無限の表現は操作によって代用される}

### [e1 <- e2]について
左側をsymbolに限定しているのは、変数に到達することを見込んでの話だが
代入としてはそういう必要はない。
σ=[e1 <- e2]は、記号の上でよく定義できるだろう。

表現e*σは、eに出現するe1をすべてe2に置き換える操作である。
変数がなければ、これは厳密に定義できる。

この場合でも e1 < e2だと、e1を置き換えたe2の中のe1をどうするかという
問題がでてくる。

代入としては、一度だけ適用するという定義でもよく、その場合何も
矛盾しない。

(x*[x<-f(x)])*[x<-f(x)] => (f(x))*[x<-f(x)] => f(f(x))
になるだけである。
*unificationでは繰り返し代入を適用する必要があるので、
このような代入は無限に繰り返しが発生するので
NGとすることになる。

σ=[e1<-e2]は、term rewriting systemとも考えられる。
まだ変数を導入していないので、[add(1,2) <- 3]のような
concreteな計算はできるが、完全な計算システムにはならない。

代入の左側をsymbolに限定すると、表現に代入を適用したとき、
その表現は必ずもとの表現よりも複雑になる。
instanciateされるとも言える。

表現のlatticeを考え、複雑な表現が下にいくようにレイアウトすれば
代入の適用は下降のみを可能にする。
symbolどうしの代入では、同じレベルでの移動はできるが、
上昇不可である。

### rename
代入の単純な例について考える。
[s<-e]のsもeもsymbolであるものをrenameと呼ぶ。

これは、表現の木(パーザーでの表現木は一つの表現を木で表すが
ここでの表現木は表現をノードとする木になっている)

表現上、rename ρには、<-の両側を逆にすることで逆変換にあたる
ρ^-1を定義できる。つまり
ρ=[x<-y]のとき
ρ^-1 = [y<-x]

この定義は
ρ*ρ^-1=[x<-x,y<-x]
ρ^-1*ρ=[y<-y,x<-y]

であり、第一要素を見ているかぎりは空代入に見えるが
第二要素があるので、空代入とはならないから
任意の表現eについて
e*ρ*ρ^-1 = e
や
e*ρ^-1*ρ = e
が成り立つわけではない。

([x,y]*ρ)*ρ^-1=[y,y]*ρ^-1=[x,x]
[x,y]*(ρ*ρ^-1) = [x,y]*[x<-x, y<-x] = [x,x]

であり、代入の合成としては同じ結果になるので
上に書いたように
ρ2=ρ*ρ^-1 = [x<-x,y<-x]
であるが、
e*ρ2 != e
ではないので、空代入にはならならい。
つまり、
ρ*ρ^-1 != []

#### 注意
すべての表現について成り立つかどうかと考えると
[x,y]が判例になってしまうが
[x]だけを考えると、ρ*ρ^-1は[x]に対する空代入である。

ρ^-1*ρは[y]に対する空代入だが、この二つは等しくないので
非可換の例になってもいる。


### renameの合成
例1)
ρ1=[x<-y]
ρ2=[z<-y]
のとき、
([x,y,z]*ρ1)*ρ2 = [y,y,z]*ρ2 = [y,y,y]

なので、ρ=ρ1*ρ2 = [x<-y,y<-y,z<-y] である。

[y<-y]はないのと同じなので、単純にρ1とρ2の和集合のようにみえる。
R(ρ1)∧L(ρ2)なのは、二つのrenameが直交しているようなものか。


例2)
ρ1=[x<-y,y<-z]
ρ2=[z<-y]
の場合は
([x,y,z]*ρ1)*ρ2)=[y,z,z]*ρ2=[y,y,y]
例1と同じ結果だが、y<-yはない。

y<-z * z<-yがy<-yになっているように見える。
個々のsymbolについて変化を追うと

xについては、x=>y=>y
yについては、y=>z=>y
zについては、z=>z=>y

と変化している。

### 一般的な代入の逆
σ^-1を考えると、同じ記号xが場所によってy,別の場所でzにもどる必要があるかもしれない。
σ4={y<-x, z<-x}の場合
[x,y,z]*σ4=[x,x,x]
となるが、σ4^-1が[x,x,x]を[x,y,z]にもどすには、そういうことが必要なので逆元は一般的には存在しない。

### 等冪
では、
ρ1=[x<-y, y<-z, z<-x]
のような巡回置換なら
[x]*ρ1*ρ1*ρ1=[x]
となる。
ρ^-1=ρ1*ρ1
なのか?

ρ1*ρ1=[x<-z,y<-x,z<-y]
であり、表現上は変数の入れ替えによる逆元になっている。

これも、同時に解決しないからうまくいくのであり
ρ5=[x<-y, y<-x]
の場合は
([x,y]*ρ5)*ρ5=[y,x]*ρ5=[x,y]
になる

e*ρ!=e

#### 代入[s<-e]
* [x<-x]を消していいのか
　Logicalなレベルで<e1:e2>を計算するときは、変数をローカルに持つほうが計算しやすい。
その場合は[x<-x]を残すほうがよいのではないか。
(実装として、Dictionaryを使うというのはありうる)

*fixed pointとかclosureとか呼んでいた現象について。

σ^2!=σのとき、繰り返しσをかけてくと、σをσ^n=σ^n-1となるか。
そのσ^nは最初のσと何が違うか、何が同じか。
* L(σ) ∧ R(σ) = φ
この場合は、eに出現しているL(σ)はσを適用するとすべて消えてしまうので、e*σ*σでは、二度目のσは何も変化させない。

* L(σ) ∧ R(σ) != φ
このときは、なんらかのeについて、e*σ*σ != e*σとなる。
なぜなら、共通の変数vについて、v<eとなるeを考えると
e*σにはvが残るが、そのvはもう一度σを適用すると、[v<-e']のe'に置き換わるので、e*σとe*σ*σは同じでないから。
e*σとe*σ*σの違いは何か?

証明は、次のようになる。
* L(σ)とS(R(σ))の数を数える
* e*σによって、だいたいeのL(σ)変数は減っていく。

σ=[x<-f(y,z),y<-g(w,z),z<-h(n)]
L(σ)={x,y,z}
S(R(σ))={y,z,w,n}

y,zが共通

このとき、σを一度適用すると、xが消える。
変数がどう変わるかは、σによって決まり、次のようになる。
x->{y,z}
y->{w,z}
z->{n}
もしすべての変数を含むeにこれらの代入を繰り返し適用したとすると、変数は次のようにかわる。
関数記号、定数記号は無視する。

{x,y,z}=>{y,z,w,z,n}={y,z,w,n}=>{w,z,n,w,n}={w,z,n}=>{w,n,n}={w,n}=>{w,n}
=>はBagとして重複を残し、=は集合として重複を除いた。

となり、変数が変化しなくなる。これらの変数はL(σ)に属さないので(属する変数はすべて代入で消えていく)
代入によってeが変化しなくなる。


### では、σ^n=σ^n-1となるσの形は?
上の証明のスケッチからは、
SL(σ)∧S(R(σ)) = φであれば、ループが起きない。
その条件は強すぎるのではないか。

e*σのとき
1) S(e)∧SL(σ)
  =φならσによってeは変化しないのでおしまい
  !=φの場合、σの代入でeは変化する。[x<-x]の形以外のものがあれば。
2) SL(σ)∧SR(σ)
  =φなら、σを2度以上適用しても代入結果は変わらない。
  !=φならば、idempotentではない。

3) SL(σ)∧SR(σ)!=φの場合、S(e)∧SL(σ)∧SR(σ)が
　=φならば、σは1度適用すると変化しなくなる。
  !=φならば、σ^nで変化しなくなるとすると、その時間は下記の計算になるが・・・


例)
 σ=[x<-f(y,z),y<-g(w,z),z<-h(n)]
 [y,z]*σ*σ=[g(w,z),h(n)]*σ=[g(w,h(n)),h(n)]
で収束する。

 (([x,y,z]*σ)*σ)*σ=([f(y,z),g(w,z),h(n)]*σ)*σ=[f(g(w,z),g(w,h(n)),h(n))]*σ
  = [f(g(w,h(n))),g(w,h(n)),h(n)]
で収束する。

xが収束するまでの時間をt(x)と書くとすると、L(σ)のそれぞれについて計算できて
t(x)=max(t(y),t(z))+1
t(y)=t(z)+1
t(z)=1

この式は、σの右辺を一度トラバースすればわかる。


となるから、具体的な値は。
t(z)=1
t(y)=2
t(x)=3
となり、σ^3=σ^4である。

例inside)
σ=[x<-f(y), y<-g(z), z<-h(x)]の場合のtは?

t(x)=t(y)+1
t(y)=t(z)+1
t(z)=t(x)+1

であり、t(x)=t(x)+3 となるから、insideがあるとわかる。

わかるのか??


###代入のまとめ

#### idempotentの形を持った代入を自動的に作るようなunificationアルゴリズムがあるか
代入を作るアルゴリズムはunificationのみである。
unificationは、代入の中でもmguを作る。

unificationの前提条件
1) <e1:e2>で、V(e1)∧V(e2)=φ
2) σ=<e1:e2>のときは、e1*σ=e2*σ
3) <e1:e2>が失敗するばあい、例外発生するようなパスで失敗する。
  <e1:e2>が失敗する場合は、DS(e1,e2)=(t1,t2)のとき
　t1,t2が定数で異なる。
  t1<t2か t2<t1のとき

DSでドライブしていく
 雑
ρ1*[z<-y] => [x<-y, z<-y]

可換図を書くと
([x,y,z]*ρ1)*[z<-y] = [y,y,y]

ρ2=[x<-z]
[x,y,z]*ρ2 = [z,y,z]
([x,y,z]*ρ2)*[y<-z] = [z,z,z]

ρ2*[y<-z] => [x<-z, y<-z]


となり、[x,y,z]の3つのeを同一にするという意味で
ρ1*[z<-y]とρ2*[y<-z]は等価である。

このあたりで変数を考えなくてはならないような気がしている。
まず、[y,y,y]と[z,z,z]が同じであると考えたい。



rename ρ1, ρ2で、S(ρ1)∧S(ρ2)=φの場合、

[x<-y] * [z<-w]


### 消える情報
e*σは、eの構造を壊していく。

σ1=[x<-y]
を
[x,y]
に適用すると
[y,y]
になる。本来独立した項であるxとyに同じであるという条件を適用することで
どのような代入によっても本の形には戻せない。

[y,y]の方が条件がかけられているので、エントロピーは低くなっていると考えられる。
それは、代入で変換できるかどうかと同じことになる。
σ: e1->e2
となるとき、e2からe1に戻せる代入が存在しないという点で、情報が失われたとも考えられる。

renameの場合は、戻せそうな気がするが、



