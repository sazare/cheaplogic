例)回路

課題
　何かについての質問と、それへの答を返すものを考え、
　知識を論理式でどう表現するかを考える

背景
　QAシステムは、ViewProverの枠組みでできるかもしれないと思う。
　だが、View Proverにはいろいろ制約がある。
　より具体的に必要な機能を検討するため。

認識している制約
　ViewはCanoのあるもののみ
　ひとつのリテラルはViewかResoかどちらかによってしか消えない

　

問題
いくつかの簡単な電気回路を考える

1. base:     *sw -- battery -- lamp ->*
2. direct:   *sw1 -- sw2 -- battery -- lamp ->*
3. para:     *->1,2,1--sw1->3,2--sw2->3,3--battery--lamp->*
4. para-lamp:*->1,2,1--sw1--lamp->3,2--sw2--lamp->3,3--battery->*

component: switch(sw), battery(pow), lamp(lamp), wire(-)

各コンポーネントは機能と部品を持つ。
回路の機能は、「スイッチをonにするとlampが点く(light)」というように書いてみる。
これは述語 C2(on, lamp)を使って、C2(on,light)とかける。


各部品の状態は次のようにする。
sw:   on/off
pow:  empty/charged
lamp: ligth/black
wire: conn/discon

wireは配線を表している。

1) 質問1
今、baseの回路で、スイッチをonにしてもlampがつかなかった。
という質問が考えられる。
質問の意図はその原因を知りたい。

1-1) まず、正常か異常かの判断ができるか?

質問というか、現在の状態は
 (1) C2(on, black)
と書ける。

swをonにしたとき、lampはligthであることが期待されている。
この質問から、powやwireについての状態表現を導けなくてはならない。

そして、powやwireの状態テストを促せるとよい。この部分はViewを使うことになる。

a) 正常状態と異常状態は、基準によって決められなくてはならない。
　基準はFactとはまた違う状態の記述で与えられる。
　これをPremiseと呼ぶことにする

C2で書ける回路の正常状態は次の2つである。
Premise1:
 (2) +C2(on, light)
 (3) +C2(off, black)

この文脈では(1)は実際に観測された状況なのでこれをFactと呼ぶ。
(1)+Premiseで証明を作る。== ¬(1)+Premiseから[]を求めようとすると

 <1:2> = <light:black>がFailする
 <1:3> = <off:on>がFailする

ことから[]が得られない=(1)の証明ができない故に、(1)は異常であるといえる。

これができる前提は、Factはともかく、Premise1がUnitであり、すべての総当たりが
有限だから。


ここまでをまとめると、
1) ユーザに回路の状態を尋ねて(View) Fact(1)を求める。
2) あらかじめ回路について定められている状態のPremise1から(1)の証明を求める。
3) 証明が不可能であることから、(1)が異常状態であることがわかる。


1-2) どの部品がおかしいかを知りたい
各部品が正常か異常かはどう判定できるか。
また、どの部品の異常が回路の異常の原因か。

この例では次の二つの原因が考えられる。

a) バッテリーが空になっている
b) 配線のどこかが断線している

a)は、バッテリーの異常と考えるか、バッテリー自体が壊れているわけではないので
　ひとつの正常な状態に過ぎないと考えるかで、考え方/枠組みがかわる。

b)は配線が切れているかどうかなので、配線の異常であり、正常な状態とは言えない。
　これもなにかの見方をすると正常のうちとみなされるのかもしれない。

この部品に対する述語として次のものを導入する。

SW(z)  : zはon(on)/off(off)
WIRE(w): wはconnect(conn)/discononnect(discon)

C2(sw,lamp)にこれらの部品との関係を記述できるようにするためには

C2(x,y) ≡ C4(x,y,z,w)

が必要。

(1)は次の(1')に書き換えられる。

 (1') -C4(on, black, z,w)

powとwireについては知らないので変数のままになる。
これはViewにすると、未定義の項目に対応する。

Premise1をC4で書き換えると
Premise2:
 (2') +C4(on, light, charged, conn)
 (3') +C4(off, black, z, w)

なので、(1'),(2'),(3')から[]の証明を試みると
　<1':2'> = <black:light>でFail
  <1':3'> = <on:off>でFail
となりC2の場合と同じく全試行でFailになり異常であると判定できる。

🎂

ここまでのPremiseでは、正しいほうだけを記述していた。
原因究明には、正しくない場合も記述する必要がある。
「正しくない」というのは適切ではない。回路の全性質の記述が必要という意味。
つまり、「sw=on & lamp=light」を正しいと考えているが回路には正誤はない。

回路の性質として次の組み合わせが分かっているので、 Premiseに次が追加できる。

 (4) +C4(on, black, empty, conn)
 (5) +C4(on, black, charged, discon)
 (6) +C4(on, black, empty, discon)

(6)はpower, wireの両方の原因が重なって異常になっている場合である。
すべての組み合わせをPremiseに書くのはたいへんなので
変数を使ってコンパクトにする必要がある。それは2)で検討する。

ここで、(1'),(2'),(3''),(4),(5)で[]の証明を試みると

　<1':2'>  = <black:light>でFail
  <1':3''> = <on:off>でFail
  <1':4>   = <z,w:empty,conn>
  <1':5>   = <z,w:charged,discon>
  <1':6>   = <z,w:empty,discon>

<1':4>,<1':i5>,<1':6>では[]が証明できて、それぞれ
z,wつまりpower, wireがどのようなときに、スイッチをいれても
ランプがつかないのかの原因の可能性がわかる。

ここまでをまとめると
 (1) C4を使ってPremiseを書き換えると、新しい部品に関しての
　  異常時の関係が記述に不足しているので、Premiseを充実させる。
 (2) ¬(1)から(1')の証明をすべて作る
 (3) []のmguから原因の可能性がわかる

どの証明が実際におきているのかがわかれば、原因を究明できる。
それは、Premiseの(4),(5),(6)の中のどれがFactであるかを
判定できればよい。

それはProverの中だけでは判別できない。

単純な方法としては、すべての[]を求めてそのmguからテストの
組み合わせを生成し、それを元にテストすればよい。

そして、そのテスト結果をFactとして追加し
証明していけばよい。

しかし、それをProverの枠組みの中でできるとおもしろい。
以下はその方法の案である。

1-3) Viewでテストを促がし、原因をたどる方法

まず、FactはProverの外部に問い合わせる必要があり、
現状、 それをする仕組みがViewである。

Viewは対応するCanoがある場合に発生するようにしているので
そのようなCano リテラルを書いておくか生成できるようにする必要がある。

そして、それぞれのCanonical literalが、各部品のテストに対応する。
(複数の部品の関連をテストするケースは今は除く)

部品のテストをうながすCanonicalリテラルを次のように定義する。

TestSW(SW)
TestLamp(LAMP)
TestPow(POW)
TestWire(WIRE)

これらとGoalをつなぐには
Goalを次のように書き換えればよい

[-C4(on, black, z, w),-TestPow(z),-TestWire(w)]

理論上は、-TestPow(z)からViewが生成され、テスト結果がchargedなら
Fact +TestPow(charged)が発生し、このFactと上のGoalから

[-C4(on, black, charged, w),-TestWire(w)]

が生まれることになる。

今のProverの手続きではFactは作らず、そのままリテラルを消しているので
Viewの入力後、直接このgoalになる。

現在のProverの手順では、Viewを全部処理してからResoに進むので


から






2) 部品の正常異常の観点
一方で、各部品が正常か異常かというテストも考えられる



その状態は work/broken とする。

部品がworkでも、期待した状態にならないなら、それは回路の設計が間違っている。



###
goalに
-C(on,black,z,w)
と書いたとき、Premiseに
+C(off,black,z,w)
があるので
goalを
-C(x,black,z,w)
と書いてもいいような気がする。
C(x,black,z,w) == C(on,black,z,w) ∧ C(off,black,z,w)
だから。
これは、一見
∀x,z,w.C(x,black,z,w)
という意味のような気がするが
xとz,wの意味が違う
xについてはすべてのinstanceについて分かっていることを述べているが
z,wについては、具体的な状態はわからないけれど、というような
保留つきの∀のような気がする。
それを
-C(x,black,z,w),-TestPow(z),-TestWire(w)

と書くのではないか。
Factの部分と、Unconfirmedな部分がある。
ここではそれを別途確認=テストする必要があるから、TestXXXと書いてみているが
-C(x,black,z,w),-UNCPow(z),-UNCWire(w)
みたいななにか表現か?

UNCかどうかはどうやってわかるのか???

機械的にわかるものならば、次の質問の自動生成ができるはず⭐︎


#############
CNFに書いているgoal以外の部分をどう呼ぼうか。
Axiomsと呼ぶのもありだが、想定していることが違うように思う。
全体がFactでもない。

Description(desc) 記述

と呼ぶことにする。

記述は「何かについての」記述であり、そのような「何か」の
「モデル」を定義しているというような言い方もできそうだが
見当はずれな誤解を与えるのでそれは言わないでおこう。


#############
        みため
Fact    Unit,Ground
Premise Unit,Ground 
Unconf  Unit,UnGround

今、記述をclauseの集合と考えている。
個々のclauseは、次のようなタイプに分かれる。

[Fact]
Factは、実際に世界に対して観測されたことがら、あるいは人間に聞いて得た回答。
だから、変数を含まない。
人間に聞いた回答は変数を含むこともありうるが、それがなんらかの方法によって
∧に分解できるものでなくてはならない。変数を含まないclauseの∧にできるという
意味で変数を含まない。

このシステムの外側での推論によって得られたFactもありうる。
人間の持つ独自の知識から得られた結論であり、十分正しいことが確認されて
いるので、証明機で証明する必要のないもの。
別の証明機による結論。
など

対象世界に対して人間が影響を与えられない場合、 そこについて成り立つ事柄は
受動的に観測されるだけであり、それをFactと呼ぶ。
形の上では、Factは推論の形/ルールの形をしていないのでunit clauseになる。

[Premise]
対象世界(モデル化しようとしているもの)が、人間の作成したものである場合、
観測以外の方法で、というか、それが満たすべき条件として人間が意図した関係を
Premiseと呼ぶ。
Premiseは実際に観測されなくても、そう作られているので成り立つと言える事柄。
Factと同じく、Unit clauseでgroundとする。
変数を含んでいてもよいが、個別の場合のほうが人間は答えやすそう。
ちがうかも

Premiseは観測によって真偽の判定ができる。異なる複数の方法で性質を
確認できる場合である。

Premiseと観測の間に食い違いがあると、それはバグとよばれるたぐいの
不整合であり、Factが優先され、Premiseは成り立たない場合になる。
人間が作った部分についての人間の意図と現実の差にあたる。

観測が正しくない可能性もある。観測結果を表現するときに間違いが入る場合も
ある。

[Unconfermed]
上のz,wのような変数。
論理式では表現できないが、
Ground だと言っているにもかかわらず、groundではないclauseであるような
Factの中に現れる変数の中で、∧-分解しても変数のまま残るようなもの。

未観測という意味の変数。

goalで考えると、そのような変数は、答えとして知りたい。

sw=off, lamp=blackはpremiseにあるので、特に情報は不要。
[-C(x,black,z,w)]
で知りたい情報は
sw=x=on, lamp=blckとなる条件


ground は事実として知りたいが、もしもある変数がすべてのdomainの要素で
成り立つのなら、変数をかわりにおいておいてもよい。そのほうが必要な証明が
簡単になる。

この経済性は何か?

つまり

Z,Wをドメインとしたとき
P(Z,W)
という形式について
Z={a,b}
W={b,c}
の場合、
premiseとして

1) +P(a,b)
2) +P(a,c)
3) +P(b,b)
4) -P(b,c)

が成り立つとする。
これを簡潔に

5) +P(a,y)
6) +P(b,b)
7) -P(b,c)

と書くと

g) [-P(a,y)]
とpremiseからは

a) [] <g:1> {y=b}
b) [] <g:2> {y=c}
c) [] <g:5> {}

が得られる。これらはgoalで反証できるもののすべてだが
a)とb)は個別の証明から個別の情報がひきだせているが
c)は特に得られる情報がない。

P(a,-)の場合、Wのすべてについて成り立つので、+Pだというのなら
それ以上細かい情報はいらないという意味でc)が望ましいだろう。
a),b)は冗長になる。

g2) [-P(b,y)]
の場合は、
d) [] <g2:3> {y=b}

sw=on, lamp=blackのようにあってはならない状態のgoalからその原因を
知りたいというので、circ群を使い調べていること。

e) <g2:4>はfailになる
いまは、<g2:4>がfailになるので、よって、問題がc=yにあると考えている

goalを[+C(b,c)]とすれば元の世界で-C(b,c)つまり、C(b,c)で
エラーが起きているとできるが、premiseにnotをいれるということは
そういうことは起きないと言っていることになるので使えるかも


どうしたらいいか
いろいろな書き方がありそう





