例)回路

課題
　何かについての質問と、それへの答を返すものを考え、
　知識を論理式でどう表現するかを考える

背景
　QAシステムは、ViewProverの枠組みでできるかもしれないと思う。
　だが、View Proverにはいろいろ制約がある。
　より具体的に必要な機能を検討するため。

認識している制約
　ViewはCanoのあるもののみ
　ひとつのリテラルはViewかResoかどちらかによってしか消えない

　

問題
いくつかの簡単な電気回路を考える

1. base:     *sw -- battery -- lamp ->*
2. direct:   *sw1 -- sw2 -- battery -- lamp ->*
3. para:     *->1,2,1--sw1->3,2--sw2->3,3--battery--lamp->*
4. para-lamp:*->1,2,1--sw1--lamp->3,2--sw2--lamp->3,3--battery->*

component: switch(sw), battery(pow), lamp(lamp), wire(-)

各コンポーネントは機能と部品を持つ。
回路の機能は、「スイッチをonにするとlampが点く(light)」というように書いてみる。
これは述語 C2(on, lamp)を使って、C2(on,light)とかける。


各部品の状態は次のようにする。
sw:   on/off
pow:  empty/charged
lamp: ligth/black
wire: conn/disc

wireは配線を表している。

1) 質問1
今、baseの回路で、スイッチをonにしてもlampがつかなかった。
という質問が考えられる。
質問の意図はその原因を知りたい。

1-1) まず、正常か異常かの判断ができるか?

質問というか、現在の状態は
 (1) C2(on, black)
と書ける。

swをonにしたとき、lampはligthであることが期待されている。
この質問から、powやwireについての状態表現を導けなくてはならない。

そして、powやwireの状態テストを促せるとよい。この部分はViewを使うことになる。

a) 正常状態と異常状態は、基準によって決められなくてはならない。
　基準はFactとはまた違う状態の記述で与えられる。
　これをPremiseと呼ぶことにする

C2で書ける回路の正常状態は次の2つである。
Premise1:
 (2) +C2(on, light)
 (3) +C2(off, black)

この文脈では(1)は実際に観測された状況なのでこれをFactと呼ぶ。
(1)+Premiseで証明を作る。== ¬(1)+Premiseから[]を求めようとすると

 <1:2> = <light:black>がFailする
 <1:3> = <off:on>がFailする

ことから[]が得られない=(1)の証明ができない故に、(1)は異常であるといえる。

これができる前提は、Factはともかく、Premise1がUnitであり、すべての総当たりが
有限だから。


ここまでをまとめると、
1) ユーザに回路の状態を尋ねて(View) Fact(1)を求める。
2) あらかじめ回路について定められている状態のPremise1から(1)の証明を求める。
3) 証明が不可能であることから、(1)が異常状態であることがわかる。


1-2) どの部品がおかしいかを知りたい
各部品が正常か異常かはどう判定できるか。
また、どの部品の異常が回路の異常の原因か。

この例では次の二つの原因が考えられる。

a) バッテリーが空になっている
b) 配線のどこかが断線している

a)は、バッテリーの異常と考えるか、バッテリー自体が壊れているわけではないので
　ひとつの正常な状態に過ぎないと考えるかで、考え方/枠組みがかわる。

b)は配線が切れているかどうかなので、配線の異常であり、正常な状態とは言えない。
　これもなにかの見方をすると正常のうちとみなされるのかもしれない。

この部品に対する述語として次のものを導入する。

SW(z)  : zはon(on)/off(off)
WIRE(w): wはconnect(conn)/disconnect(disc)

C2(sw,lamp)にこれらの部品との関係を記述できるようにするためには

C2(x,y) ≡ C4(x,y,z,w)

が必要。

(1)は次の(1')に書き換えられる。

 (1') -C4(on, black, z,w)

powとwireについては知らないので変数のままになる。
これはViewにすると、未定義の項目に対応する。

Premise1をC4で書き換えると
Premise2:
 (2') +C4(on, light, chgd, conn)
 (3') +C4(off, black, z, w)

なので、(1'),(2'),(3')から[]の証明を試みると
　<1':2'> = <black:light>でFail
  <1':3'> = <on:off>でFail
となりC2の場合と同じく全試行でFailになり異常であると判定できる。

🎂

ここまでのPremiseでは、正しいほうだけを記述していた。
原因究明には、正しくない場合も記述する必要がある。
「正しくない」というのは適切ではない。回路の全性質の記述が必要という意味。
つまり、「sw=on & lamp=light」を正しいと考えているが回路には正誤はない。

回路の性質として次の組み合わせが分かっているので、 Premiseに次が追加できる。

 (4) +C4(on, black, empty, conn)
 (5) +C4(on, black, chrg, disc)
 (6) +C4(on, black, empty, disc)

(6)はpower, wireの両方の原因が重なって異常になっている場合である。
すべての組み合わせをPremiseに書くのはたいへんなので
変数を使ってコンパクトにする必要がある。それは2)で検討する。

ここで、(1'),(2'),(3''),(4),(5)で[]の証明を試みると

　<1':2'>  = <black:light>でFail
  <1':3''> = <on:off>でFail
  <1':4> = <z,w:empty,conn>
  <1':5>   = <z,w:chrg,disc>
  <1':6>   = <z,w:empty,disc>

<1':4>,<1':i5>,<1':6>では[]が証明できて、それぞれ
z,wつまりpower, wireがどのようなときに、スイッチをいれても
ランプがつかないのかの原因の可能性がわかる。

ここまでをまとめると
 (1) C4を使ってPremiseを書き換えると、新しい部品に関しての
　  異常時の関係が記述に不足しているので、Premiseを充実させる。
 (2) ¬(1)から(1')の証明をすべて作る
 (3) []のmguから原因の可能性がわかる

どの証明が実際におきているのかがわかれば、原因を究明できる。
それは、Premiseの(4),(5),(6)の中のどれがFactであるかを
判定できればよい。

それはProverの中だけでは判別できない。

単純な方法としては、すべての[]を求めてそのmguからテストの
組み合わせを生成し、それを元にテストすればよい。

そして、そのテスト結果をFactとして追加し
証明していけばよい。

しかし、それをProverの枠組みの中でできるとおもしろい。
以下はその方法の案である。

1-3) Viewでテストを促がし、原因をたどる方法

まず、FactはProverの外部に問い合わせる必要があり、
現状、 それをする仕組みがViewである。

Viewは対応するCanoがある場合に発生するようにしているので
そのようなCano リテラルを書いておくか生成できるようにする必要がある。

そして、それぞれのCanonical literalが、各部品のテストに対応する。
(複数の部品の関連をテストするケースは今は除く)

部品のテストをうながすCanonicalリテラルを次のように定義する。

TestSW(SW)
TestLamp(LAMP)
TestPow(POW)
TestWire(WIRE)

これらとGoalをつなぐには
Goalを次のように書き換えればよい

[-C4(on, black, z, w),-TestPow(z),-TestWire(w)]

理論上は、-TestPow(z)からViewが生成され、テスト結果がchargedなら
Fact +TestPow(charged)が発生し、このFactと上のGoalから

[-C4(on, black, charged, w),-TestWire(w)]

が生まれることになる。

今のProverの手続きではFactは作らず、そのままリテラルを消しているので
Viewの入力後、直接このgoalになる。

現在のProverの手順では、Viewを全部処理してからResoに進むので


から






2) 部品の正常異常の観点
一方で、各部品が正常か異常かというテストも考えられる



その状態は work/broken とする。

部品がworkでも、期待した状態にならないなら、それは回路の設計が間違っている。






