#Rubbish

##Function
### substitution
1) 特徴
 S-記法
　本での代入の定義。
　Herblandの学位論文では、また違う定義になっているようなことを読んだが、未確認。

 P-記法
　並列代入。この代入の定義はややこしい。
　でも高速に実行できるはず。S-記法代入の順序に依存した部分をあらかじめ解決しておくのでそうなる。

### unification
 P記法とS記法とvars.expとvars.psを共通のvarsなのでpsからvarsをはずす件
　p記法では、varsの順番は重要ではない。
  unificationでは、mguのvarsはexpのvarsに一致させるのが自然。
  だから<v1.e1:v2.e2>を<vs.e1:vs.e2>としてvs.<e1:e2>としたとき
　mgu=vs<-tsをtsだけで表記し、たとえば
  (vs.E)*(vs.<e1:e2>)はvs.(E*<e1:e2>)と書いてしまう。

　varsの管理はunificationの処理とは直交しているということか。たぶん違う

### S記法とP記法は代入の表記および操作を意味するが、unificationの実装で
　どちらの記法でmguを作るかというのは設計の問題になる。

　unifictionpはそれ独自のアルゴリズムがあるが、unificationsの結果をs2pで
  p記法にするという方法でp記法のmguを求めるunificationspを考えた。
　アルゴリズムをながめるかぎり、こっちのほうが性能がよさそう。
  実際の性能比較はこうなった
　unifications<unificationsp<unificationp

　p-記法の代入よりもs-記法の代入のほうが高速になるはずなので、
　unificationも代入も含む、resolution全体の性能比較もしたい。

　unification中に代入を行うから、混在した処理としてはunificationだけで
　完結しているようにも思うが、代入はunificationで対象としない残りのリテラル
　に対して行うので、影響が及ぶはず。

### resolveとrename
　C1=L1vR1, C2=L2vR2のとき、<-L1:L2>=σを計算して、R=(R1vR2)*σを作るのがresolve。

　課題
　・C1とC2に共通の変数があってはならない(Chang&Leeのtpuでは前処理としてrenameする)
　　- renameの回数を数えると、resolutionに失敗した場合もrenameしているので前処理はやめたい。

　　- 後処理にすると、ほかのすべてのclauseと変数が混ざらないようにする必要がでてくる。
　　　それは(gensym)。ただ、変数の数がふえすぎるかもしれない。どっちがいいか。

　・-L1とL2にする必要があるが、L1, L2の符号を除いたatomにして<A1:A2>とするほうが話は簡単。?

### リテラル
　resolventに出現するすべてのリテラルは、入力clauseのリテラルの生き残りである。
　つまり、証明の中のリテラルを遡るとすべて入力clauseのリテラルにたどり着く。
　これにこだわる必要があるかどうかわからない部分もあるが、その情報を残すとすると

       ren     res     ren     res     ren     res     res
　L100 --> L99 --> L80 --> L79 --> L50 --> L49 --> ... --> L10 --> *
       ρ50     σ50     ρ40     σ40     ρ25     σ25     σ1   ↓     
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　Lit10
　という構造が考えられる。
　L100,L99,...はLiteralID。
　Lit10はリテラルそのもので(+ P a x (f x y) (g y))のようなもの。
　L100に対応するリテラルは Lit10*σ1*...*σ50*ρ50 で求められる。
　各LiterlIDに裸のリテラル(naked literal)を持たせることも考えられる。

　代入を適用するためにはvarsが必要であり、varsはリテラルでなくclauseに対応するので
　Ln から Cm(clauseid) を求め、Cmからそのvars_mを求める仕組みは必要になる。

### 変数管理
　resolveでは、両方のリテラルに共通の変数がないことを前提としている。はず。
　Chang&LeeのTPUでは、resolutionをする前に共通の変数をrenameしていたと思う。
　そもそも、変数リストは固定で、resolutionするときに変数名を付け替えていたようなきがする。

　rubbishでは、前処理のrenameはやらず、すべてのclause/resolventがDisjoined Variables Condition(DVC)
　を満たすようにする。
  そのため、入力clauseの変数はすべて異なる名前につけかえ、resolventは生成されたら変数名をつけかえる。
　このため、ρ_nをもとめる処理がはいっている。ρ_nの計算は簡単なので性能劣化にはつながらないはずだ。

　もしも前処理でrenameをすると、renameしたclauseを証明に残すか残さないかという設計判断も
　でてくるが、残さなくてもごまかせるような気はする。
　そうなるとresolventの数が半分になるので、やはり処理速度とメモリ使用量のトレードオフ。

### C1とC1のresolveでは共通変数がでてくるのではないか
　考えている証明の手順は、goalベースであり、この場合、自分とresolveすることはないので問題にならない。

　ではgoalベースの限界を超えるようなものはやらないのか??
　そのときはそのときまた考える。

### PvPvRからPvRを作るルール
　これをやろうと思うと、前処理のrenameがどうしても必要になる。
　どう考えていたのか忘れた。renameする必要はないと思う。

### リテラルID、ClauseID、mguid

概要
  Lid → Cid → Lid* (clauseを構成するliteralid)
　↓　　　↓
　Lit　 vars

詳細
　　　parent
　Lid   →   Lid | nil
       naked
　　　　→   Lit
       cid
　　　  → Cid

  LidのnakedのLitの変数は、Lidのcidのvars

--
  Cid left:  Lid
      right: Lid
      mgu:   Mid
      vars:  var*
      lids:  Lid*

varはatom/symbol
left, rightのcidでparent cidがわかる

--
　Mid naked : sig::term* ;; sig==vars<-term* varsはcidのvars

 mguはclauseに属する。そのclauseのリテラルは、resolveで生き残ったリテラルであり、
literalの変化を示すmguはつまり属するclauseのmguになる。
 lid が与えられたとき、lidのparentを辿って入力リテラルまでたどり着くと
そこにでてきたすべてのlid → cid → vars.mguを適用して今のlitを再構成できる。


設計が矛盾していないか?
DVCとproofにrename前と後のclauseを残すようにしているのに
なぜここにきてメモリを節約するのか・・・
まあ、cid, lid, midで実体があるのはliteralとmguだけだから、一貫してはいるのか・・・

litを作るときの途中計算は消えるよね・・・

resolventの実体であるリテラルは、作られることがない・・

ρはresolventを作るときにはLitに適用しない。
σもresolventに適用する必要がない。

printclauseみたいなことをしたとき、実体のliteralが出現する。
それは一時的であってほしい







### clauseの追加について




##Implementation

