UNIFICATION の整理

Google ScholarでみつけたUification theoryを読んでいると、ドラフトであるということも
あるのだろうが、厳密とはいえないように思えた。
Unificationの手続きはLogical Sysetmのようにルールで定義していて、ここの実装には
よらないように書かれていて、個々のアルゴリズムがそのルールを満たすことは示している
けれど、そもそも表現、代入の定義が明確でないことと、ルールから導かれる主要な性質が
直感的なUnificationに一致するかどうか。あるいは、同じことかもしれないが、
どういう前提でのUnificationなのかが明瞭に感じられなかった。

そういうこともあって、自分なりに整理しておこうと思う。


まず、unificationという操作? は単独では存在しえず、
expressionの定義の上で定義されるsubstitutionと
変数のbindingの方法が決まっていないといけない。
つまり

(U,Σ,E)

で定義の意味が決まる。

・Eは表現の集合で、同一関係と部分表現の関係が定義される。
・Σは代入の集合で、e*σとσ*ςの操作が定義される。代入の間の同値は定義できるか?
・Uはunificationという操作。

[表現の集合E]
Eには同一 e1 ≡ e2 と部分表現 e1 in e2 を定義する。
e1 in e2だとしても、e2の中に複数のe1が出現している場合、それらを区別していない。
それを区別するには、XMLのxpathのように、部分表現へのpathを定義するしかないだろう。
区別する必要があるのかどうかは、しばしば区別したくなるとしかいえない。
表現上の操作を考える時、同じ記号、同じ部分表現をすべて同じものとして扱いたいと
いう要求があるのだろう。でも、その操作について考える時は、区別できないと困ると思う。

他の方法で個別の部分表現あるいは記号を識別できればよいのだが、思いつかない。

プログラミング言語ならば、ASTだと思えば良いが、具体的すぎると煩雑になる・・・困った

[代入Σ]
Σは、代入の表現{(s e)}or {s←e}が定義されなくてはならない。 sはシンボル、eは表現。
()か←かの違いは大きくはないが、シンボルなのか表現なのかは少し影響がある。
そして、e*σとσ*ςの定義の関係が重要。どういう演算を行うかによって代入の意味が
決まるのだから。
代入表現には制約をつけず、すべて演算でかばーするほうが簡単だろうか。
制約なしにすると、操作の定義が煩雑になるのでやはりよくない。

■表現に変数を含む必要はない。変数はUnificationではじめて出現すればよい。
{s←e}が代入であるというとき、この操作においてsは定数であるとか変数である
とかいう意味は関係ない。変数はLogicの概念であり、代入は記号操作の概念だから。

では、定数に何かを代入するということにどのような意味があるのか。
という問いは、定数という概念にとらわれているので意味がない。
代入は、記号を表現で置き換えるという操作。
これの発展が、表現を表現で置き換えるという操作(置換)になる。


演算を定義する前に、代入表現自体の制約条件はあってもいい。
演算やunificationで、煩雑な処理を書かないために必要。
たとえば

代入の制約条件

{s_i←e_i}で、

1) i!=jのときs_i!=s_j。記号に重複がないということ。
　　これは実装上難しくないし、許すと煩雑になる。(Dictを使えば、自然に排除されるし、
　　代入は、左から順に適用するとかいった条件をつけないと、結果が異なり、
　　代入の適用がwell definedになくなるはず。

2*) s_i in e_iではない。inは部分表現。
　　実際には、ぐるりとまわってこうなる場合もあるので単にこれを禁じるだけでは不十分。
　　だから、代入表現の制約条件とするのは不都合なのか。
　　unification のinside checkがこれを排除することになるが、代入の定義の中で表現するには
　　σ*σ = σというidempotentの条件がこれを正確に表していると思う。条件の名前はUnification Theoryに書かれていた。

　　ただし、insideがなくても、e*σ != e*σ*σ になることはあって、それを解消するのはfixed pointを求めること
　　ではないかとcheaplogicでは考えている。
　　fixed pointが無限ステップでも決まらない場合、それがinside checkではじかれる。
　　inside checkではじかれるには、また別の条件があるのでそう言ってしまうのは条件がある。
    そもそも、代入は有限表現なので、σ*で変化しなくなるか無限に続くかは有限ステップで判定できる。
　　それが何ステップなのかはあらかじめ分からない。停止性はそこで決まる。
　　無限に続くかどうかはinside checkで判定することになるはず。
　　

3*) s_i≡e_iを含める(含めないという選択肢はある。Unification Theoryでは、代入の定義には含めているが
　σ*ςの結果には含めないというようなよくわからない定義になっていた。代入自体の定義では許しているのだろう)

* 記号かどうかは変数と関係なく判定できるので、この段階では変数はでてこない。と考えればよいと思う。
　代入の左にあるものを変数と考えるか、別に変数を判定する仕組みを用意するかとかいう選択肢はこの後の話で
　よいと思う。(ずっと変数だと思い込んでいたが、さっき、そうではないと気づいた)
  変数を判定する仕組みとして、Unification Theoryでは全変数の集合をあらかじめ与えていた。
　全変数の集合は可能無限なので、実装としては変数名の先頭を'v'にするとか、記号のpropertyに何か持つとか
　値が存在するかどうかとか、そういう判定方法になるだろう。
　

■e*σの定義
いくつかのバリアントがありうる。

a) σの左(右)から順に{s←e}を適用していく?

b) σのすべてを同時に適用する

c) σの要素をランダムに適用していく?

a)b)c)の実装では、結果が変わるだろう。

* eに対する変形は、途中結果は考えないので、eについてアトミックな処理である。

σの要素をどう適用するかという順序を考えている時、σについてはアトミックではなくなる。




■σ*ςの定義
Unification Theoryで、手順として書かれている。e*σは言葉だけではなかったか。
v←vのような要素を取り除くとかいう処理は、他の部分の処理との関係ででてくるのだろうし
全変数の集合が与えられているという条件も関係するのではないか。

eを使うと、

D1.0 
∀e (e*σ)*ς=e*(σ*ς)
が成り立つような(σ*ς)が代入の合成になるだろう。

1. s_i*ςを新しい左辺の集合とする。これで同じ変数が出現するかもしれないが
2. 同じになるということは、e1,e2両方に同じs1_i==s2_jがあったということになる。
　　その場合は、D1.0から、s1_iが優先されるので、e2の{s2_j←*}は捨てられる。
　　これが成り立つためには、元のe1_iにs2_*が出現せず、e2_jにs1_*が出現しないとか
　　いった条件が必要なはず。s1_*が他のe1_*に出現していたり、s2_*がe1_*に出現して
　　いるとややこしくなる。
　　だから、そういう代入の要素は含まないように代入の制約条件をいれないといけないはず。
　　そしてそういう制約をいれると、操作の中でそういうものが発生しないようにするか
　　発生したら消す処理が必要になる。

3. s_i←e_iをs_i*ς←e_i*ςに置き換える。
　　これをすると、σにあったs_i←の代入が消えてしまうがよいのか。よくないはず。

最初にもどって、

単純に考えればs1_i←e1_iを s1_i←(e1_i*ς)におきかえることになる。
e1_i*ςは、e1_iの中のs2_jをe2_jに置き換えるが、それは単純に表記できない。

σとςに同じシンボルがあったら、まずはςのその要素は効果がなくなる。

もしも、σ自体でそのシンボルが置き換わってしまうなら、ςのその変数の代入は残る。

s1_i←s1_iがあると条件が面倒臭くなりそう。

σ*ςはmerge


e1_iに出現する変数は、ςによって置き換わる。
さらに、 s1_iがe2_jに出現していたら、e2_jのs1_iはe1_i*ςで置き換える必要があるから

まず結果の代入要素が s3_k←e3_kだとすると






■代入のサブセットに変名(rename,Ρ)があって、それにもとづいてEを同値類にわけられる。
renameは{s1←s2}でs1,s2がともにシンボル。
ρがrenameのとき、ρ^-1が存在して、{s2←s1}である。
ε = ρ*ρ^-1 = ρ^-1 * ρ

Eの同値関係は
e1~e2 ⇔ e1=e2*ρ となるρ∈Ρが存在する。 

ρ1*ρ2 ∈ Ρ なので、遷移律もなりたつかな。


■また、Σも同値類になるのか?
σ1~σ2 ⇔ ∃ρ σ1*ρ=σ2
でよいか?

ρは、{s←e}∈σ1を{s*ρ←e*ρ}に変形する。でよいか?



