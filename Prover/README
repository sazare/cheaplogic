README

#3 prover
1. cheaplogic
    my original prover
2. naivelogic
    a prover with an old fashion unification
3. kplogic
    a prover feat. with keyword predicates

# usage
1) include("load_cheaplogic.jl") or 
   include("load_naivelogic.jl") or
   include("load_kplogic.jl")

2) running example script is
   include("data/rundata.jl") for cheap and naive
   include("kpdata/runkpdata.jl") for kplogic
   these files call simpleprover(). 

3) analyze with(coreprint.jl)
   1) printcore(core)                           : print a core components as readable form
       print_coreinfo(core)                   : print core info as readable form
   
   2) printproofs1(core)                      : print all proof trees pred level of all contradictions 
       printproofs0(core)                      : print all proof trees prop level of all contradictions 
       printaproof1(rid,core)                : print all proof trees pred level of rid 
       printaproof0(rid,core)                : print all proof trees prop level of rid 
       
   3) printmgus(core, orig)               : print all mgus in proof trees of all contradiction (orig==false shows outvar only)
       printmgu(rid, core, orig)           : print all mgus in proof trees of rid (orig==false shows outvar only)
   
   [misc]
   - printclause(cid, core)
   - printcdb(core.cdb)
   - printldb(core.ldb)
   - printproof(core.proof)
   - printtemplates0(core.level0, core) print equation in prop level
      printtemplates1(core.level0, core)  in pred level
   - traceof(core) ??? what is this???
   
*** namely, load a suitable prover, and run simpleprover

# FILES
misc.jl       -- nyi() ... something like this

config.jl     -- config for prover. evalon enable executable predicates

utils.jl      -- basic concepts and readclause/readcore
types.jl      -- basic types for unify
primitives.jl -- primitive difinitions and functions
subst.jl      -- apply
unifybase.jl  -- common functions for unify
unify.jl      -- dvc unify
naiveunify.jl -- naive unify
reso.jl       -- resolution operations -- almost uncompatibles
newcore.jl    -- new core concepts
coreprint.jl  -- print over core
dvcreso.jl    -- DVC based resolution and more

analyzer.jl   -- 
repl.jl       -- a experimental tool for repl 
merge.jl      -- old sample codes
setupdata.jl  -- just setup data 
play.jl       -- playgound

#tests
test_cheaplogic.jl -- run tests for cheaplogic
test_naivelogic.jl -- run tests for naivelogic
test_kplogic.jl -- run tests for kplogic

 other test*.jl's are tests for *.jl


# data basic axiom sets
*.cnf       -- test sets cnf form

common.fun  -- executable literal definition which included by < in cnf
rundata.jl  -- run simpleprover() with all *.cnf
allconds.jl -- get all contradictions after rundata.jl
fol.syntax  -- fol syntax idea not filan
*.exp       -- fol format formula ideas

-- cnf format
first character's meaning
1) [    : a clause whole line
2) !    : a form except ! will be evaluated.
3) <    : a filename excpet < is readclausefromfile()'ed
4) o.w. : comment/no special meaning

you can browse by following one liner
 $ grep -H '^@ ' *.cnf  # first line with @ is an general meaning
 $ grep -H '^@@' *.cnf   # leftmost @@ means something technical information
 $ grep -H '^#' *.cnf    # # is used usual comments. this may be tedious
 $ grep -H '^<' *.cnf    # < means include other cnf
 $ grep -H '^<data/common.fun' *.cnf   # It may use executable literals.

For these grep effective, when write a cnf, follow the such style.

### spec for LPS
load_lps.jl : load lps 
spec/runspec.jl demo lps with some examples

### KP logic is keyword-parameter unification and resolution based on it.
kptype.jl
kpbase.jl

load_kplogic.jl
test_kplogic.jl -- run tests for KP logic

play_kp.jl : demo for print as Japanese from KP formula

#### make
1. make testall -- run tests for cheaplogic, kplogic
2. make lps     -- run spec/runspec.jl for lps demo
3. make clean   -- remove temporal files

#### howtocode
experimantal codes
1. investigae Helbrand Model for clauses Sets and it's meaning...


