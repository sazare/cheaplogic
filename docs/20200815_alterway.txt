inputリテラル間のmguを先に計算したらどうなるか

A) 
 1. -P(x,z)
 2. -P(a,s1)+Q(a,1)
 3. -P(a,s1)+R(a,s2)
 3. -Q(a,n)+(a,s2)


clauseの意味がわからなくなってきた
-P(x,y)+Q(x,f(x,y))


P->Q,Rと分かれてQ,RからUに結合していくようなものをかけるか
1. -P(x)+Q(f(x))
2. -P(x)+R(g(x))

これはQ and R imply Uなのか??
3. -Q(a)-R(b)+U(f(a,b))
4. -Q(x)-R(y)+U(f(x,y))

これは処理手順とか状態遷移を描こうとしているが、それが表現できているのか??

0. nconjは-U(z)
初期状態は+P(a)や+P(k(x))など
5. +P(a)

そこで初期mguを求めると・・・
m1 = <5.1:1.1> = x←a 
m2 = <5.1:2.1> = x←a
m3 = <1.2:3.1> = ng
m4 = <1.2:4.1> = x'←f(x)
m5 = <2.2:3.2> = ng
m6 = <2.2:4.2> = y←g(x)
m7 = <3.3:0.1> = z←f(a,b)
m8 = <4.3:0.1> = z←f(x,y)

clauseに従ってmguをくっつける
m3とm5はngなのでこれらを含む解はない

goalの5から一筆書きをする。Lkからremof(Lk)につながるような。

5→1→4→0
m1@m4@m8

5→2→4→0
m2@m6@m8

mguからclauseのグラフを作る(literalがリンク)
0⇨1=3⇒3⇒{1:ng|2:ng}×

0⇒1=3⇒4⇒
 {1=2⇒51=
 |2=2⇒2

0⇒0.1:3.3⇒{3.2=2.2⇒ng+3.1=1.2⇒ng} :ng
0⇒0.1:4.3⇒{4.1=1.2⇒2.1+4.2=2.2⇒2.1}⇒5.1 □


★ mguを求めて、それらの間の関係をどうみるか。
　とにかくngの部分は除外できるので

  mguからngを除外したedgeリストを作り、再構成すれば可能性のあるグラフはできそう

 0⇒4⇒(1⇒5|2⇒5)

 0.1:4.3=[4.1:1.2=[1.1:5.1]+4:2:2.2=[2.1:5.1]]

というようなパスだけが□になる可能性のあることはわかる

<








