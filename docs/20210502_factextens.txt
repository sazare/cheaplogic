factのシーケンス-知識の変化-知識の記述方法

　知識=ground clausesの集合。

　・202104からのテーマは、factのシーケンス(Φ)によって、知識がどう変わっていくか。

###
　20の扉問題(ここでは次のようなゲームを想定する)
　　「20の扉」は、出題者が考えた「なにか」について、回答者がそれを当てるというゲームである。
　　「扉」とは、回答者と出題者の間の1回のやりとりのことをいい、
　　1回のやりとりでは、回答者が「質問/問」をだし出題者が、その「問」にyes/noで答える。
　　やりとりが20個以下の「問」で正解を導ければ回答者の勝ち、できなければ出題者の勝ちとなる。

末尾にこの資料での20の扉の扱い方を説明
###

　問題の定式化
　　初期知識をΣとし、factのsequenceをf_1, f_2, ...であらわすと、
　　　Σ0=Σ, Σ_t+1 = Σt*f_t という知識変化についての分析になる。

　　　* f_iには、同じものが出現しない。
　　　* fact f_iはground unit cluse。

　　　・factは、ground unit clause だから、Σに変数がなければ、 命題論理になる。
　　　　また、20の扉では、命題であれ述語であれ、対象とするものはひとつだけだから
　　　　変数がなくてもよいし、1引数の述語でことたりるように思う。
　　　　20の扉でない問題についても、具体的に条件をみていかないと、よくわからない。
　　　　問題の特徴/制約によって、必要な証明の方法が違ってくる。
　　　　汎用にすると、問題を証明の話にあわせなくてはならなくなるので、
　　　　最終的な証明器の作り方は自由になるのがよいと思う。

　　　・20の扉では、問の作り方はのぞいて、回答からfactのシーケンスを作る。
　　　　このとき、Φの要素factが相互に矛盾しないという特徴をもつ。
　　　　無矛盾なので、Σ_t+1 ⊂ Σ_t となる。

　　　　tが増えると、Σのclauseの数はへっていくし、clauseのliteral数も減っていく。(減るか同じ)
　　　　なので、Σで成り立つfact gが得られる。
　　　　Σをfact が侵食していくイメージ。染めていくというほうがニュートラルかも。

　　　　* あとのほうに書く複数の対象についての知識の場合は、必ずしも減らない。
　　　　　あるfactを適用して、知識のclauseは、literalが減ったり、clause自体が除去されたりして
　　　　　Σの一部は消えて小さくなるが、
　　　　　変数で書かれている全体から、観察のおわり個々の定数によって具体的に書かれた部分を差し引いた
　　　　　知識として残されるものがあると、増えたりする。
　　　　　表現として増えるが、中身は増えていない。

　　・　Σ, f |= Σ'
　　　となったΣ'に含まれるfact gは、初期の普遍的なfactではなく fを前提としたgである。

　　・Σ |= Σ', f からΣ, f|=Σ'に変形するようなイメージか。fの移項。

　　・そもそも「普遍的なfact」という「普遍的」にどれほどの意味があるのか?
　　　「前提の明記されたfact」/ "a fact with explicit assumptions"みたいな言い方が近いのではないか。
　　　前提のないfactもあるはず。書くか書かないかは書く人の自由であり、手続きで必要のないfactは書かなくてもよい。

　　　・また、複数のシーケンス f^1_i、f^2_j, f^3_kがあったとき、それぞれのシーケンスでことなるΣ^pができるが
　　　　たとえば、観察するオブジェクトごにf^iが変わるとすると、Σ^pはお互いに独立で、共存できて、世界の独立な側面
　　　　に対する知識が作られる。

　　** 変数を含むfactは存在し得ないか
　　　・factは、外部装置が世界を観察して報告する命題になる。
　　　　・そういう点では、ground unit clauseになるはず。

　　　　・　対象を観察するだけでは変数はでないな・・・

　　　  ・変数が出現するには、帰納的推論が必要ではないか?
　　　　　見えていない部分について仮定をおくことが帰納ということかな。
　　　　　その仮定のもっともらしさは、統計・確率論によるのか・・・

　　　　・あとにでてくる、複数の対象(a,b,c,...など)についてのfact seq.を扱う時は変数がありうる。
　　　　　そこでは変数は、「その他」を表す。
　　　　　変数のある知識の記述にすると、定数の数があらかじめわからないので、
　　　　　その他を意味する変数をずっと残さなくてはならない。

　　　・そもそも複数対象の扱いは必要だろうか?
　　　　個々の対象について、最初のΣから別々のfactのseqだとして処理してよいような気がする。

　　　しかし、同時に複数の対象が登場する場合はありそうだし、必要になるのかも。

　　　つまり、変数も対象を表す定数も書いていない最初の知識の書き方は、話題の対象が1つだけだからできること。

　　　たとえば、ある対象の部品aとbがあって、そのaとbによって全体cの性質が決まってくるようなことがあれば
　　　書く必要があるかも。


　　** 無矛盾なfact sequenceとは別に、factが矛盾する場合も考えられる。
　　　・対象が変化し、観察されるfactが矛盾する場合があるだろう。矛盾が「変化」を意味する。

　　　　このとき、f_tと矛盾するΣ_t-1の部分をどう変化させていくか。そんなことができないのか?
　　　<<調査中>

*****
　・知識は、事実によらない記述である。そこにfactが含まれていたら、それは普遍的な真実の表現ということになる。
　　
　　しかし・・・
　　　Σ, f |= Σ'
　　となったΣ'に含まれるfact gは、普遍的ではなく fを前提としたgである。

*** ここらへんで考えているように、rubbishではΣからでてくる個々の証明/conjectureではなく、全体としての変化が対象。
　　Σ全体のどのような性質が、特徴づけるのか?

　・ある証明pについて、pcode(p)は、pの有限特徴量となりうるのではないか。近似値ではあるけれど。
　　
　・知識の集合であるΣとfact fによるΣの変化
　　　Σ x f -> Σ'
　　20の扉的、無矛盾拡大の場合は、次のような操作が考えられる。(2021/5/1のconfactの実装)
　　　C in Σについて
　　　　〜f in C なら、Cから〜fを除いた(resolution)clauseでCを置き換える。
　　　　f in Cなら、ΣからCを除く
　　　　それ以外のCはそのまま継続する。

  * x in Cとは、Cの中にxとunifiableなliteralがある場合
　* factはground unit clauseなので、

　*前提: fact fはCとresolutionしたとき1つのresolventしか生成しない。
　　　　L1vL2vβ = Cで、L1とL2が同じfactとresolvableとなるということは、L1とL2がお互いにinstanceになっている
　　　　が、factなので一意に決まる・・・ようなきがする

　* RDBはデータ=ground wffで書かれている。
　　変数はqueryでのみ使える。
　　というようなもの。

　・この観点から懐中電灯の問題を見直すとなにか得られるかも。
　　　懐中電灯の知識(仕様)にたいして、現場で調査した結果を順番に適用していくと、何が残るか・・・


****　知識の書き方

　　5/1までに調べたのは
　　　+What(elef) <=> +BIG() and +LONGNOSE() and ...
　　　この表現はいろいろな前提がある。

　　　　1) 象というものは、象の性質の合計(∧)と同値である
　　　　2) 象以外の知識で、-LONGNOSE()はでてこないだろう。孤児リテラルだがfactでひっかかる。
　　　　　　これは、問を作る時の基準になりうる。(longnoseがelephantを同定してしまうということは
　　　　　　Whatで決め打ちした場合と得られる情報が同じであり、回答により得られる知識が少ない、
　　　　　　などという評価)
　　　　3) 知識をもとに問を作るので、述語記号が違っていて実は同値という場合でも、違う述語記号の間で
　　　　　　resolveしないので、問題にならない。

　　他の書き方
　　　+What(elef) <=> +Is(BIG) and +Is(LONGNOSE) and ...
　　　　* Isを導入すると、証明するとき+Pのoppoである-Pを探すのが大変だからIsを使わない書き方にしているが
　　　　confact.lispの方法は、opposを使わないので、ISでもよい。
　　　　* Whatを使っているのは、問題の対象となるWhatとそれの性質(Is)と区別できるようにするため
　　　　　しかし、What固有の処理はないので、WhatもIsで十分。
　　　　　ただし、問-答-FACTのループで、終わりを判定するため目印としてWhatが必要だと思う。
　　　　　ループの終わりを人間が判定するのなら、不要。

　　　+Is(elef) <=> +Is(BIG) and +Is(LONGNOSE) and ...
　　　　* だからWhatのかわりにIsでも問題ない。再び。
　　　　　
　　　+What(x, elef) <=> +BIG(x) and +LONGNOSE(x) and ...
　　　　* 変数を使わなかったのは、問題の対象が1しかないので、明記する必要がないと思ったから。
　　　　  複数対象の書き方は別の箇所に書いた。
　　　　　そのような記述/知識に意味のある問題があるか?　

　　　* 概念の階層を書くことはどうか
　　　Animal(x) <= What(Elef) 
　　　Animal(x) <= What(Whale) 

　　　Is(Big) => What(Elef)
　　　Is(Big) => What(Whale)

　　　から

　　　Is(Big) => Animal(Elef)
　　　Is(Big) => Animal(Whale)

　　　-Is(Big)のとき、-Animal(Elef)+Is(Big) と-Animal(Whale)+Is(Big)が除去されるのは適切。

　　　What(mice) <= Is(small) and Is(longtail)
　　　が働くためには、

　　　　+Is(Big)　<=> -Is(small)

　　　が必要で、これは有限domain場合の公理。
　　　　-Is(Big)　v -Is(small)
　　　　+Is(Big)　v +Is(small)

　　　ここに+Is(Big)をfactとしてresolveすると
　　　　+Is(small)
　　　が得られ、-Is(Big) v -Is(small)は除去される。

　　　この新しい +Is(small)を使ってresolutionを行う必要があるかも。今のconfact.lispは不十分かな
　　　これは生成されたfactをΣに適用する話。

　　　Σxf = Σ'
　　　Δ(Σxf) = Σ - Σ'

　　　と書くとすると、
　　　Δがφになるまで、繰り返すのか・・・普通のresoliutionだ。

　* もしもΣにfactが含まれていたら、ΣxΣも必要になりそう。

?? What述語が質問/回答のInterface用の述語だと考えると

  +What(x) <=> +Is(x)
  +Is(Elef) <=> Is(Big) and Is(Longnose)
  +Is(Whale) <=> Is(Big) and Is(Water-life)

みたいにするのはありそう。
この場合は、短期的に生成されたfactの再適用が必要になりそう。ということは、再適用ループは必須か・・・

どう書くかを制限するという方法もありそう。

?? 性質のnotは必要か? not Bigと Smallを関連づける必要があるか?(再掲)
　質問するときの語彙は知識表現の中の述語であり、回答はそれに基づいてyes/noなので、性質述語間の関係は不要。

　いまは、そういう多段のfact適用は不要としよう。つまり
　Is(small)とIs(Big)の間に関係はないとする。

　*** 性質述語間の関係は記述しない。
　
20の扉的にはそれでよさそう。

?? eqvでよいか?または否定のfactについて。

  P(x) <=> Q(x) and R(x)
から
  (1) +P(x) -Q(x) -R(x)
  (2) -P(x) +Q(x)
  (3) -P(x) +R(x)

が発生し、factが+Q(a)のときは、(1)がresolveされ、(2)が除去される。
問+Q(a)? に対してNoの場合、-Q(a)がfactとなり、(1)が消えて(2)から-P(x)が残る。
このfactは否定だから、20の扉の答えではない。ということは、(2)(3)は不要なのか?
左向きのimplyは不要ということか?

?? 否定形のfactは何か?

・「象ではない」ということはfactかもしれないが、20の扉はpositiveなfactを求めているので
(2)(3)は不要になる。

・問を作る時に、+What(象)を出すのは、効率が悪いから行われないが、必ずしも無効になっているわけではない。
そこで、この否定のfactを使うことで、+What(象)を問から外すことができる。
知識としては価値がある。

これを「裏狩り」となづけよう。

問を作るところまで考えないとその価値がわからない。

+Bigがfactになったとき、-What(ネズミ)は除去される。not -Big がfactだから。
ということだろう。

-What(ネズミ) +Is(Big)

ということだが、Is(Small)で知識が書かれていたら、こういうclauseはないので+Is(Big)にはひっかからない。

+What(ねずみ) <=> -Is(big) and -Is(bigteeth)

だとすると、-Is(Big)がfactになったとき、

+What(ネズミ) or +Is(big) or +Is(bigteeth)

が

+What(ネズミ) or +Is(bigteeth)

になる。

問は、知識をもとに作られるので、知識に書いてある述語記号が対応する知識と合致すればそれでよい。
smallとbigの関係は、いらない・・・あってもよいはず　→ □ そういう知識を書いてみる。

問に対する答によっては、negative factが生まれる。

□ *******
・知識にfactを適用することで出現するfactの扱いをどうするか
  知識に
　　+Small <=> -Big
　と書いてあるとclauseは
　(1) +Small or +Big
  (2) -Small or -Big
となり、-Bigがfactだと (1)ら+Smallにおき変わって、これが知識の中のfactになる。
これはどうみても普遍的なfactではない。

　最初の知識Σは、世界の観察から得られるfactを含まない。
　なんらかの観察が反映さているΣでは、そこに出現するfactは普遍的なfactではなく
　反映さた観察gのもとでのfactになる。
　汚染されたfactというか、観察世界で成り立つfact。

****
+/-両方のfactは、知識clauseでのそれぞれのリテラル使われ方によって、役に立ったりそうでなかったりする。
****


============
## その他の書き方　試み
　　　+What(x,elef) <=> +Is(x,BIG) and +Is(x,LONGNOSE) and ...
　　　+Is(x,elef) <=> +Is(x,BIG) and +Is(x,LONGNOSE) and ...

はどうか?
20の扉では設問者の考えているのは1つのモノだが、この形の知識では複数の
モノについての知識が扱える。
　対象aやbについての知識を書いていると考えれば良さそう。

　+Is(a,BIG)?  aは大きいですか?
  +Is(b,LONGTAIL)? bの尻尾は長いですか?

という問に対するyes/noで決まるfact。

aについてのfact、bについてのfactが追加されていく。
　(f) +Is(a,BIG)と
　(1) +Is(x,elef)-Is(x,BIG)-Is(x,LONGNOSE)
から
　(1') +Is(x,elfe)-Is(x,LONGNOSE)
が生まれる。

　この場合、xがaでない知識は使われておらず、否定できないから(1)も残る。
　できれば、(1) if x!=aみたいにかけるとよい・・・

　(1) if x!=aは、x=aであるfact(+Is(a,BIGTAIL))とはresolveできない。(1')とresolveする。
　このようなルールは等号に関するものであり、今は扱わない。□

正解はこう書かれる。

　+Is(a, elef)


============

* What述語は、なんのために必要だっか
　20の扉で、問題の回答となりうる対象をそれの性質と区別したかった。
　回答がyesだった場合、それでセッションが終わるのかどうかを判定するには
　Whatを特別扱いするしかないのでは?

*****
複数対象の知識をIsなどを使わずにシンプルに書いたとすると

(1)  +IsElef(x) <=> +IsBig(x) and +IsLongnose(x) and +IsAnimal(x)
(2)  +IsRat(x) <=> -IsBig(x) and +IsLongtail(x) and +IsAnimal(x)

という書き方は複数の対象(たとえばa,b,...)についての記述になるのであり。
だが、20の扉の対象にはならない。

(1)は、次のふたつの式をまとめたものと考えられる。

(1a)  +IsElef(a) <=> +IsBig(a) and +IsLongnose(a) and +IsAnimal(a)
(1b)  +IsElef(b) <=> +IsBig(b) and +IsLongnose(b) and +IsAnimal(b)

(1)はこれの省略形という解釈。

*****
・知識clauseを、それにfactを適用した結果で置き換える、または除去するという
　処理を続けたいという気持ちがある。
　次のようなことがらがその動機。

　1) resolventのliteralはすべて入力literalのインスタンスである。
　2) 知識DBはfactによって彫られていく
　3) 話題の対象が1つなら、それでうまくいっている

変数がでてくると、これが破られる。話題の対象を変数で表す場合。
(性質に変数を使いたい場合はあるか?)

回避する方法
　1) Is(a,Big), Is(b,Big)など定数を使って変数を展開したものを知識とする。
　　　この場合、置き換えでいけるが、定数が増えると知識を追加していくことになる。
　　　　変数を分解して、知識clauseを増やすのは、論理の外側でやっていもいいと思う。
　　　　　テキスト変換として。テキスト変換は、そのルールが正しければ論理の外側で使いうる。
　　　　　　機械学習との連携も論理の外側の話なので、ここでいっていることは、たぶん
　　　　　　論理と外側をうまくつなぐ方法について考えているのではないか。

　2) 一段上の処理で考えると、
　　・定数ごとに知識DBをコピーして、ひとつのコピーでは1つの対象しか考えないようにする。
　　・個々の知識DBについては、特定の対象しかでてこないので、知識xfactによる置き換えができる。

　3) 謎は、複数の対象について一つのclauseで書いた知識というものがありうるか?
　　話題の対象という考えをしていると、そういうのはありそうにないが、なくもないのではないか?
　　□　それを考える。

　4) 上のどこかにも書いたが、変数のある場合、なぜ元のclauseを残さなくてはならないか。
　　a) resolventができるとき(〜factとunifyできるとき)
　　　factがL1であり、対象のclauseがRv〜L2だとする。
　　　<L1:L2>=σでありかつL1はgroundなので、σはv=tという形になっている。

　　　だから、resolvent Rσ が新しい知識になる。
　　　一方で残るclauseは実は、Rv~L2 if ~σ　である。
　　　σ={v<-c}のとき、~σは{v!=c} という論理式とする。
　　　　残るclause : Rv~L2 {v!=c}

　　　resolventは{v=c}という条件がついているともみなせる。
　　　　rsolvenrt : Rv~L2 {v=c}
　　　このとき、<~L2:L1>なのでL1≡L2(syntactical)(以下、=Lとかく)となり
　　　Rv-L and L
　　　になって、Rがresolventとなる。

　　　さて、Rv~L2{v!=c}に、どういう形をあたえれば、処理できるようになるか。

　　　L2はL[v]とかける。次のfactとしてL[b]が与えられた時、
      <L[v]:L[b]> {v!=c}
　　　を計算することになる。

      <L[v]:L[b]> {v!=c}
　
　　　は、b!=cならば、普通のunificationになる。
　　　もしも相手がL[a]というfactの繰り返しになっていたら(20の扉ではそれはない。
　　　知識からL[a]というリテラルが消滅しているので、次以降の問にこのリテラルは出てこない。　
　　　問が知識DBから作られるとしたらのはなしだが)
　　　{v<-c}{v!=c}はfailになるようにする必要がありそう。

　　　*置き換えられたclauseにはもうLはないので、resolutionの対象にはならない。

　　b) clauseを除去するとき(factを含むclause)
　　　CvL　のLがfactのL[c]とunifiableならCvLを除去してよいというルール。
　　　残っていてL[c]とunifiableなliteralは、変数のあるliteralのみだから

　　　CvL[v]{}とCvL[v] {v!=a}の2パターン
　　　・CvL[v] {v!=a}の場合(他のfactでインスタンス化されたclause)
　　　　　<L[v]:L[c]> {v!=a}
　　　　　　　これは{v<-c}が可能なのでunifiableとになりclauseを消す。

　　　　　<L[v]:L[c]> {v!=c}
　　　　　　　{v<-c} {v!=c}なのでfail。clauseを消さない。

　　　・CvL[v]{}の場合(input clauseの場合)
　　　　　L[v]:L[c]は{v<-c}でunifiableなので除去しない。


　というようなルールになる。
　それはそれでいいのだけれど、実装する価値があるか?? == 具体的な例はどうなるか??

　・{v<-a}{v!=b}
　　の実装について。

　　{v!=b}は、{v<-m}のmがb以外のものだけ可能という意味。

　　{v<-a}{v<-m}は、<a:m>となり、この条件から、<a:b>=∃σならfailという計算でできる。
　　<v:t>のvがどちらかに出る形のdisagreementがでてきたら
　　{v!=b}のチェックつまり<b:t>の計算をするという実装か?

　　disagreementの片方が{v!=b}の変数と同じときにトリガーされる判定処理・・・
　　処理性能に影響しないような実装をどうすればよいか?
　　unifcationは、性能の大きな部分を締めている。
　　(proverとしては、limitで制限しているので性能の影響範囲はそれほどでもない。不完全かもしれないが)

　　unificationは、表だけを計算して、裏側は無視することで、性能を得ている。
　　等号を処理するということは裏表両方考えなくてはならないので、性能がおちる。
　　しかし、証明のループのように底無しではないから、いいのかな。
　　一歩間違えると、底無し沼にはいってしまうので、気をつければよいかな。

　　□ {v!=b}の関数を作るのは面白いし、作れそうだけれど、役に立つのかどうか。使う範囲は?(20210503)

　20の扉の知識表現としてはいらないようだし・・・

*　まとめ
　20の扉問題(再掲)
　　「20の扉」は、出題者が考えた「なにか」について、回答者がそれを当てるというゲームである。
　　「扉」とは、回答者と出題者の間の1回のやりとりのことをいい、
　　1回のやりとりでは、回答者が「質問/問」をだし出題者が、その「問」にyes/noで答える。
　　やりとりが20個以下の「問」で正解を導ければ回答者の勝ち、できなければ出題者の勝ちとなる。
　
　　この資料では、この問題を次のように「知識」の変化として考える。
　　つまり、「知識」の初期値としてなにか論理式/clauseの集合(Σ)を考える。
　　問(の論理式表現をqとする)を作る部分は人間が行い、
　　出題者の回答がyesかnoかによって、qまたは~qを新たなfact(f)として与えられると考える。

　　すると、Σは新たなfact fによって変形され、そこで「なにか」についての記述がfactになれば成功という
　　ような仕組みを考える。

　　Σはどのように変形されていき、それはどういう解釈が可能か・・・

　前提条件
　　・factはground unit clauseである。factをf、clauseをCと書く。
　　　これによって、Σのclause Cは Cxfで置き換えてもよい。(Cxfは、Cによって変化したC)
　　　Cをfで変化させるというのは、上記の条件から導かれる。

　　・factについては命題でしかない。

　　・20の扉では、Σに変数が出現しないものを主に考えている。
　　　変数がでてくる場合についても、考察しているが、20の扉の問題を超えている。


　factとは何か?
　　・ここでは出題者がfactをコントロールしている。
　　・もともとは機械学習と証明器を連携させるシステムを考えていたので、
　　　機械学習システムが世界を観測し、述語表現に変換すれば、それがfactになると思っている。
　　・しかし、機械学習に限らず、論理システムの外側で得られ、論理式に変換されたものは、
　　　真なる命題(述語の命題も含む)とみなすしかなく、それ故にfactと呼んでもよいはず。

　・unit clauseであること
　　・世界に対する観測で得られる論理式は、or、implyなどでつながれたものではない。
　　　P v Qは、その時点での世界を観測して得られた情報であればPかQのどちらかであるはず。

　　　量子的な世界についての記述ならP v Qがあるかもしれないが、それでも観測できるのは
　　　PかQのどちらかなので、今はunit clauseと仮定してもよいだろう。

　　　P and Qについては、ありうる。ふたつの観点から世界を観測して、片方はP、もう片方はQ
　　　であるという場合は考えやすい。そのときは、2つのunit clauseの集合{P, Q}が観測されたと
　　　考えればよい。なのでfactの最小単位はunit clauseとみなせる。

　・groundであること(factが変数を含まないこと)
　　factがその時点での世界についての観測結果であるならば、そこに変数は必要ない。
　　だから、ground clauseと仮定する。

　　もしも外部システムがいくつかの観測結果から変数を含む論理式を導けるかもしれないが、どうだろうか。
　　たとえば
　　(a) ∀x.P(x)
　　　・Dom(x)が無限の場合
　　　これは、すべてのxがPだと言っているわけだが、xに入る定数のすべてが無限であるということは
　　　帰納をしなければわからない。はずだ。
　　　外部システムが帰納を行わないという仮定を今は置いておく。

　　　・Dom(x)が有限の場合
　　　あるいは、xのとりうるすべての値=定数が有限個しかない場合、それを全部観察してxという変数に
　　　置き換えたのかもしれない。これは帰納を使わない。
　　　これは 
　　　　P(a) or P(b) or P(c) or ...
　　　と同じことのように思われるが、どう表現するのが正解かはよくわからない。
　　　ある時点では、a,b,cのどれかなのでorかもしれないが、それはa,b,cのどれなのか決められないという
　　　意味でfactではない。だから、
　　　　P(a) v α
　　　　P(b) v β
　　　　P(c) v γ
　　　という複数の式になり、andで結ばれるものとも考えられるが、そこは「同時性」という情報が失われる
　　　ので当初想定していたfact(今の状態の論理式化)とも違うようだ。

　　今は、factはgroundなものと考えたい。

　　この資料では、知識に変数を含む場合を少し考えている。
　　そこでも、変数のDomainが有限要素である場合、それを明記することの難しさ(レーヴェンハイム・スコーレムの
　　定理からたぶん不可能)があるので、知識での変数の使用にも困難がありそう。

　　論理の外側で、たとえば人間が与えた知識として、その真偽を問わないという世界で変数が現れるのは
　　ありうる。だから、知識に変数を含むことは拒否しない。
　　20の扉のサンプルでは、対象を示す変数は使ってみたが、対象の性質を変数で表すことまではしていない。
　
　　ちなみに、すべての論理式が同じ何かについての記述であるならば、その「何か」を変数で示す必要がない。
　　変数でそれを表し、同じようなモノが複数あってもよいようなケースについてはこの資料で検討したが
　　同時に複数の「モノ」について記述するような例は考えていない。

　　そういう意味では、単一のモノについての記述で変数を導入すると、全記述の変数は同じ何かを表すことに
　　なるのではないか。つまり、clauseごとにことなる何かを示すから、resolutionでは共通の変数がないと
　　するのだが、実はすべて同じモノをさすのなら、同じ変数でよいはず。

　　∀xがclause setの外側についているようなイメージになる。
　　その場合は実質的に変数でなく定数で表す。

　　という意味で、定数ごとに別の知識DBを用意して、20の扉的プロセスを行うことは理にかなっている。


　　・述語でP(x,y,z)と書くとき、x,y,zにはどのような関連性がありうるのか?
　　　- xの部分としてy,zがある
　　　- xの性質としてy,zがある
　　　- xとyの関連性にzという名前をつける。Pがx,y,zの関連性の名前なので、これはないかな。
　　　- 



