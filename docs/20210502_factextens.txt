factのシーケンス-知識の変化-知識の記述方法

　知識=ground clausesの集合。

　・202104からのテーマは、factのシーケンス(Φ)によって、知識がどう変わっていくか。

　　初期知識をΣとし、factのsequenceをf_1, f_2, ...であらわすと、
　　　Σ0=Σ, Σ_t+1 = Σt*f_t という知識変化についての分析になる。

　　　・20の扉では、問の作り方はのぞいて、回答からfactのシーケンスを作る。
　　　　このとき、Φの要素factが相互に矛盾しないという特徴をもつ。
　　　　無矛盾なので、Σ_t+1 ⊂ Σ_t となる。

　　　　tが増えると、Σのclauseの数はへっていくし、clauseのliteral数も減っていく。(減るか同じ)
　　　　なので、Σで成り立つfact gが得られる。
　　　　Σをfact が侵食していくイメージ。染めていくというほうがニュートラルかも。

　　　　* あとのほうに書く複数の対象についての知識の場合は、必ずしも減らない。
　　　　　あるfactを適用して、知識のclauseは、literalが減ったり、clause自体が除去されたりして
　　　　　Σの一部は消えて小さくなるが、
　　　　　変数で書かれている全体から、観察のおわり個々の定数によって具体的に書かれた部分を差し引いた
　　　　　知識として残されるものがあると、増えたりする。
　　　　　表現として増えるが、中身は増えていない。

　　・　Σ, f |= Σ'
　　　となったΣ'に含まれるfact gは、初期の普遍的なfactではなく fを前提としたgである。

　　・Σ |= Σ', f からΣ, f|=Σ'に変形するようなイメージか。fの移項。

　　・そもそも「普遍的なfact」という「普遍的」にどれほどの意味があるのか?
　　　「前提の明記されたfact」/ "a fact with explicit assumptions"みたいな言い方が近いのではないか。
　　　前提のないfactもあるはず。書くか書かないかは書く人の自由であり、手続きで必要のないfactは書かなくてもよい。

　　　・また、複数のシーケンス f^1_i、f^2_j, f^3_kがあったとき、それぞれのシーケンスでことなるΣ^pができるが
　　　　たとえば、観察するオブジェクトごにf^iが変わるとすると、Σ^pはお互いに独立で、共存できて、世界の独立な側面
　　　　に対する知識が作られる。

　　** 変数を含むfactは存在し得ないか
　　　・factは、外部装置が世界を観察して報告する命題になる。
　　　　・そういう点では、ground unit clauseになるはず。

　　　　・　対象を観察するだけでは変数はでないな・・・

　　　  ・変数が出現するには、帰納的推論が必要ではないか?
　　　　　見えていない部分について仮定をおくことが帰納ということかな。
　　　　　その仮定のもっともらしさは、統計・確率論によるのか・・・

　　　　・あとにでてくる、複数の対象(a,b,c,...など)についてのfact seq.を扱う時は変数がありうる。
　　　　　そこでは変数は、「その他」を表す。
　　　　　変数のある知識の記述にすると、定数の数があらかじめわからないので、
　　　　　その他を意味する変数をずっと残さなくてはならない。

　　　・そもそも複数対象の扱いは必要だろうか?
　　　　個々の対象について、最初のΣから別々のfactのseqだとして処理してよいような気がする。

　　　しかし、同時に複数の対象が登場する場合はありそうだし、必要になるのかも。

　　　つまり、変数も対象を表す定数も書いていない最初の知識の書き方は、話題の対象が1つだけだからできること。

　　　たとえば、ある対象の部品aとbがあって、そのaとbによって全体cの性質が決まってくるようなことがあれば
　　　書く必要があるかも。


　　** 無矛盾なfact sequenceとは別に、factが矛盾する場合も考えられる。
　　　・対象が変化し、観察されるfactが矛盾する場合があるだろう。矛盾が「変化」を意味する。

　　　　このとき、f_tと矛盾するΣ_t-1の部分をどう変化させていくか。そんなことができないのか?
　　　<<調査中>

*****
　・知識は、事実によらない記述である。そこにfactが含まれていたら、それは普遍的な真実の表現ということになる。
　　
　　しかし・・・
　　　Σ, f |= Σ'
　　となったΣ'に含まれるfact gは、普遍的ではなく fを前提としたgである。

*** ここらへんで考えているように、rubbishではΣからでてくる個々の証明/conjectureではなく、全体としての変化が対象。
　　Σ全体のどのような性質が、特徴づけるのか?

　・ある証明pについて、pcode(p)は、pの有限特徴量となりうるのではないか。近似値ではあるけれど。
　　
　・知識の集合であるΣとfact fによるΣの変化
　　　Σ x f -> Σ'
　　20の扉的、無矛盾拡大の場合は、次のような操作が考えられる。(2021/5/1のconfactの実装)
　　　C in Σについて
　　　　〜f in C なら、Cから〜fを除いた(resolution)clauseでCを置き換える。
　　　　f in Cなら、ΣからCを除く
　　　　それ以外のCはそのまま継続する。

  * x in Cとは、Cの中にxとunifiableなliteralがある場合
　* factはground unit clauseなので、

　*前提: fact fはCとresolutionしたとき1つのresolventしか生成しない。
　　　　L1vL2vβ = Cで、L1とL2が同じfactとresolvableとなるということは、L1とL2がお互いにinstanceになっている
　　　　が、factなので一意に決まる・・・ようなきがする

　* RDBはデータ=ground wffで書かれている。
　　変数はqueryでのみ使える。
　　というようなもの。

　・この観点から懐中電灯の問題を見直すとなにか得られるかも。
　　　懐中電灯の知識(仕様)にたいして、現場で調査した結果を順番に適用していくと、何が残るか・・・


****　知識の書き方

　　5/1までに調べたのは
　　　+What(elef) <=> +BIG() and +LONGNOSE() and ...
　　　この表現はいろいろな前提がある。

　　　　1) 象というものは、象の性質の合計(∧)と同値である
　　　　2) 象以外の知識で、-LONGNOSE()はでてこないだろう。孤児リテラルだがfactでひっかかる。
　　　　　　これは、問を作る時の基準になりうる。(longnoseがelephantを同定してしまうということは
　　　　　　Whatで決め打ちした場合と得られる情報が同じであり、回答により得られる知識が少ない、
　　　　　　などという評価)
　　　　3) 知識をもとに問を作るので、述語記号が違っていて実は同値という場合でも、違う述語記号の間で
　　　　　　resolveしないので、問題にならない。

　　他の書き方
　　　+What(elef) <=> +Is(BIG) and +Is(LONGNOSE) and ...
　　　　* Isを導入すると、証明するとき+Pのoppoである-Pを探すのが大変だからIsを使わない書き方にしているが
　　　　confact.lispの方法は、opposを使わないので、ISでもよい。
　　　　* Whatを使っているのは、問題の対象となるWhatとそれの性質(Is)と区別できるようにするため
　　　　　しかし、What固有の処理はないので、WhatもIsで十分。
　　　　　ただし、問-答-FACTのループで、終わりを判定するため目印としてWhatが必要だと思う。
　　　　　ループの終わりを人間が判定するのなら、不要。

　　　+Is(elef) <=> +Is(BIG) and +Is(LONGNOSE) and ...
　　　　* だからWhatのかわりにIsでも問題ない。再び。
　　　　　
　　　+What(x, elef) <=> +BIG(x) and +LONGNOSE(x) and ...
　　　　* 変数を使わなかったのは、問題の対象が1しかないので、明記する必要がないと思ったから。
　　　　  複数対象の書き方は別の箇所に書いた。
　　　　　そのような記述/知識に意味のある問題があるか?　

　　　* 概念の階層を書くことはどうか
　　　Animal(x) <= What(Elef) 
　　　Animal(x) <= What(Whale) 

　　　Is(Big) => What(Elef)
　　　Is(Big) => What(Whale)

　　　から

　　　Is(Big) => Animal(Elef)
　　　Is(Big) => Animal(Whale)

　　　-Is(Big)のとき、-Animal(Elef)+Is(Big) と-Animal(Whale)+Is(Big)が除去されるのは適切。

　　　What(mice) <= Is(small) and Is(longtail)
　　　が働くためには、

　　　　+Is(Big)　<=> -Is(small)

　　　が必要で、これは有限domain場合の公理。
　　　　-Is(Big)　v -Is(small)
　　　　+Is(Big)　v +Is(small)

　　　ここに+Is(Big)をfactとしてresolveすると
　　　　+Is(small)
　　　が得られ、-Is(Big) v -Is(small)は除去される。

　　　この新しい +Is(small)を使ってresolutionを行う必要があるかも。今のconfact.lispは不十分かな
　　　これは生成されたfactをΣに適用する話。

　　　Σxf = Σ'
　　　Δ(Σxf) = Σ - Σ'

　　　と書くとすると、
　　　Δがφになるまで、繰り返すのか・・・普通のresoliutionだ。

　* もしもΣにfactが含まれていたら、ΣxΣも必要になりそう。

?? What述語が質問/回答のInterface用の述語だと考えると

  +What(x) <=> +Is(x)
  +Is(Elef) <=> Is(Big) and Is(Longnose)
  +Is(Whale) <=> Is(Big) and Is(Water-life)

みたいにするのはありそう。
この場合は、短期的に生成されたfactの再適用が必要になりそう。ということは、再適用ループは必須か・・・

どう書くかを制限するという方法もありそう。

?? 性質のnotは必要か? not Bigと Smallを関連づける必要があるか?(再掲)
　質問するときの語彙は知識表現の中の述語であり、回答はそれに基づいてyes/noなので、性質述語間の関係は不要。

　いまは、そういう多段のfact適用は不要としよう。つまり
　Is(small)とIs(Big)の間に関係はないとする。

　*** 性質述語間の関係は記述しない。
　
20の扉的にはそれでよさそう。

?? eqvでよいか?または否定のfactについて。

  P(x) <=> Q(x) and R(x)
から
  (1) +P(x) -Q(x) -R(x)
  (2) -P(x) +Q(x)
  (3) -P(x) +R(x)

が発生し、factが+Q(a)のときは、(1)がresolveされ、(2)が除去される。
問+Q(a)? に対してNoの場合、-Q(a)がfactとなり、(1)が消えて(2)から-P(x)が残る。
このfactは否定だから、20の扉の答えではない。ということは、(2)(3)は不要なのか?
左向きのimplyは不要ということか?

?? 否定形のfactは何か?

・「象ではない」ということはfactかもしれないが、20の扉はpositiveなfactを求めているので
(2)(3)は不要になる。

・問を作る時に、+What(象)を出すのは、効率が悪いから行われないが、必ずしも無効になっているわけではない。
そこで、この否定のfactを使うことで、+What(象)を問から外すことができる。
知識としては価値がある。

これを「裏狩り」となづけよう。

問を作るところまで考えないとその価値がわからない。

+Bigがfactになったとき、-What(ネズミ)は除去される。not -Big がfactだから。
ということだろう。

-What(ネズミ) +Is(Big)

ということだが、Is(Small)で知識が書かれていたら、こういうclauseはないので+Is(Big)にはひっかからない。

+What(ねずみ) <=> -Is(big) and -Is(bigteeth)

だとすると、-Is(Big)がfactになったとき、

+What(ネズミ) or +Is(big) or +Is(bigteeth)

が

+What(ネズミ) or +Is(bigteeth)

になる。

問は、知識をもとに作られるので、知識に書いてある述語記号が対応する知識と合致すればそれでよい。
smallとbigの関係は、いらない・・・あってもよいはず　→ □ そういう知識を書いてみる。

問に対する答によっては、negative factが生まれる。

□ *******
・知識にfactを適用することで出現するfactの扱いをどうするか
  知識に
　　+Small <=> -Big
　と書いてあるとclauseは
　(1) +Small or +Big
  (2) -Small or -Big
となり、-Bigがfactだと (1)ら+Smallにおき変わって、これが知識の中のfactになる。
これはどうみても普遍的なfactではない。

　最初の知識Σは、世界の観察から得られるfactを含まない。
　なんらかの観察が反映さているΣでは、そこに出現するfactは普遍的なfactではなく
　反映さた観察gのもとでのfactになる。
　汚染されたfactというか、観察世界で成り立つfact。

****
+/-両方のfactは、知識clauseでのそれぞれのリテラル使われ方によって、役に立ったりそうでなかったりする。
****


============
## その他の書き方　試み
　　　+What(x,elef) <=> +Is(x,BIG) and +Is(x,LONGNOSE) and ...
　　　+Is(x,elef) <=> +Is(x,BIG) and +Is(x,LONGNOSE) and ...

はどうか?
20の扉では設問者の考えているのは1つのモノだが、この形の知識では複数の
モノについての知識が扱える。
　対象aやbについての知識を書いていると考えれば良さそう。

　+Is(a,BIG)?  aは大きいですか?
  +Is(b,LONGTAIL)? bの尻尾は長いですか?

という問に対するyes/noで決まるfact。

aについてのfact、bについてのfactが追加されていく。
　(f) +Is(a,BIG)と
　(1) +Is(x,elef)-Is(x,BIG)-Is(x,LONGNOSE)
から
　(1') +Is(x,elfe)-Is(x,LONGNOSE)
が生まれる。

　この場合、xがaでない知識は使われておらず、否定できないから(1)も残る。
　できれば、(1) if x!=aみたいにかけるとよい・・・

　(1) if x!=aは、x=aであるfact(+Is(a,BIGTAIL))とはresolveできない。(1')とresolveする。
　このようなルールは等号に関するものであり、今は扱わない。□

正解はこう書かれる。

　+Is(a, elef)


============

* What述語は、なんのために必要だっか
　20の扉で、問題の回答となりうる対象をそれの性質と区別したかった。
　回答がyesだった場合、それでセッションが終わるのかどうかを判定するには
　Whatを特別扱いするしかないのでは?

*****
複数対象の知識をIsなどを使わずにシンプルに書いたとすると

(1)  +IsElef(x) <=> +IsBig(x) and +IsLongnose(x) and +IsAnimal(x)
(2)  +IsRat(x) <=> -IsBig(x) and +IsLongtail(x) and +IsAnimal(x)

という書き方は複数の対象(たとえばa,b,...)についての記述になるのであり。
だが、20の扉の対象にはならない。

(1)は、次のふたつの式をまとめたものと考えられる。

(1a)  +IsElef(a) <=> +IsBig(a) and +IsLongnose(a) and +IsAnimal(a)
(1b)  +IsElef(b) <=> +IsBig(b) and +IsLongnose(b) and +IsAnimal(b)

(1)はこれの省略形という解釈。

*****


