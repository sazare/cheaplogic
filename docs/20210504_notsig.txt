what is negation of unifier

1. clause set ΣとΣの外側から与えられるfact f=L2を考える。
　20の扉の場合、
  cluase (1)  α v ~L1 と (2) fact L2
　　∃ σ12=<L1:L2> 
　なら、Σの(1)をresolvent(3) α・σ12 で置き換えてよい。
　なぜなら、同じ形のL2は二度と登場しないから、L1を消す相手はL2以外にないと言えるので。

2. もしもL1に変数があるならば、このような置き換えはできない。
　　つまり、L1[x]で、L2[a]であったとしてもL2[b]というfactが登場する可能性があるから。

　　L2[b]の相手を残しておくために、通常の証明器のように(1) をそのまま残しておき、
　　Σに(3)を追加する、という手続きがありそう。

3. しかし、L1[a]の部分についてはもう解決しているので、x!=aの部分についてだけ(1)を残せればよい。
　　それを
　　(a) L1[x]{x!=a}
　　と書くとすると、clause(1)は
　
　　(4) α[x]v~L1[x]{x!=a}

　　と書くことになる。{x=a}をif x!=a　と解釈すれば単純になるが、それはよいのか?

### 検討
　　{x<-b}{x!=a}をどう処理するか。
　　{x<-b}{x=a}ならばmguの結合として {x<-b}{x<-a}がfailすればよいように思うが、
　　代入の合成は、先に実行したほうが有効になるだけでfailはしない。例えば
　　rubbishのsubsubは、代入を続けて実行するるだけなのでfailはない。だから、これとは違う。

　どうなってほしいか。これはunificationであり
　　<L[x]if x!=a :L[b]> であり、 <L[x]:L[b]> if x!=a とも書けるとする。

　　unification/disagreementで<x:b> if x!=a がでてきて、(if x!=aはunification中常にある)
　　このときxに対して=bと!=aがあるので、<b:a>を計算する。

　　<x:b> if x!=a は<b:a> がfailしたとき successでmguは{x<-b}となる。

　　これが成り立つためには
　　<x:t> if x!=s なども考えたくなるが20の扉の範囲では不要。

#####
　　もしもやるとしたら
　　<t:s> = ∃σ　なら、failで、σがなければ{x<-t}が残る。
　　　このσ が存在するとはどういうことか。
　　　　<t:s>によって{x<-a, y<-b, ...}みたいに分岐したらどうなるのか?
　　　　{x<-s}でカバーしきれない範囲になるのであれば、有効にしなくてはならないはずだが・・・
　　　　sとtがunifiableであるということは、sのinstanceでもあるので、このtは除外してよい!

　　　だから、∃<t:s>ならばfailで、なければ{x<-t}が残る　でよいようだ。
#####

　　本来やりたいことは、<L[x]:L[a]>でα v ~Lから~Lが除去されると
　　a以外の部分についてはまだ情報を取れていないから、元のclauseを残しておきたいというこ。
　　だから
　　~a = dom(x) - {a}
　　をのこすような元clauseの制限を書きたいということ。
　　元clauseは出現変数も書くとこうなる。

　　(1') α[x] v ~L1[x]

　　これに対してresolvent α[a] のカバーできていない範囲を表したいということをこう書くということ。
　　　
　　(1'') α[x] v ~L1[x] if x!=a

　　になる。~L1[x]if x!=aとなるのか (α[x]v~L[x])if x!=a となるのか?
　　変数xの出ている範囲で有効になるべきだから後者だろう。

　　(1'')の処理をするとき、xが関係するunificationで、常にif x!=a をつけて処理するということか。
　　

　普通のresolution proverでは、Σにresolventを追加していくだけだから、こういうことには悩まない。
　もしも同じL2を持つ別のclauseがあって、それと(1)をresolutionする場合、両方のresolventがほしい
　ならば、こういうことを悩まない。
　20の扉では、
　　1) factが相手(つまりunit resolutionか)
　　2) 同じfact/同じ述語記号のliteralは二度とでてこない

　同じclauseから複数のresolventがでるのはよい。
　L1が同じmguで消されるとき、得られる情報が同一ではないのか?

　  (1.1) +P(x) -R(x,x)
　　(1.2) +R(a,y) -Q(f(y))
　　(1.3) +R(a,y) -Q(g(y))

という場合がありそう
(1.2)と(1.3)は条件のついていない代替である。
条件がついていると、(1.1)をresolventで置き換えてしまうのはまずい。
しかし、(1.2)や(1.3)はfactではないので20の扉ではおきないわけだ。

###



　　　




　　(5) L2[b]

　　のresolutionでは

　　<L1[x]{x!=a} : L2[b]>
　　を行う。これは次のように処理する。
　　1) <L1[x]:L2[b]>=∃{x<-b}
　　とmguをもとめて、これとx!=aの矛盾チェックになる。
　　mguなので片方は必ず変数だから、矛盾といっても同じ変数について相方がunifiableかどうかの確認になる。
　　unifiableなら失敗。

　　2) x<-bは(x){x<-b}=(b)で判別され、(b)と(x!=a)を比較して矛盾しないので{x<-b}が残る。 
　　　という処理にしたい。だとすれば、
　　　L[x] if x!=aは、x=a v L[x] というclauseにはならない。
　　　そもそもmguはclauseの外側なので、それを中にとりこむのには無理があるのでは?

　　　clauseにしなければ、x!=aはmguのxの相手がaのときに失敗するだけなので、比較的容易に判別できる。

　　* L1[x]ifx!=a は、L1[x] and  x!=a に似ている。
　　　が、これは x!=aが別clauseになってΣに登録されそう。そうなると、xが繋がらないので役に立たない。
　　　** だから L1[x] if x!=aはこの形で扱うしかない。

　　　L1[x] if x!=aは、L1のunificationにx!=aという制約をつけるようなもの。

　　もしも L2[a]がもう一度出現した場合は、x<-a と x!=a が矛盾するのでそのuifcationはfailとする。

　　L2[b]の場合、{x<-b}|x!=a 

　　




　
