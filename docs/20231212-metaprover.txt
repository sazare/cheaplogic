20231212-metaprover

[動機]
証明プログラム適当に作った。その正当性証明について考えてみたら、「証明」の定義がはっきりしなかったので、整理してみることにした。

古めの教科書しか見ていないが、私のもとめる厳密な定義はみつからなかった。読み方がゆるいだけかもしれない。ただ、普通の言葉で定義されていて細かいことは読者の常識にゆだねられているかんじがした。厳密な定義は論文として書かれているのかもしれない。だが、論文にすると長くなるので、結局どこにも書かれていないのかもしれない。博士論文ならあるかも。

たとえば、表現をEとしてそこに出現する変数xがあるときE[x]でそのxの出現に注目したEを表すようなことを書くが、その定義はよくわからない。たとえば項の定義に遡って、E[x]を定義しているような本があるのだろうか。さらに、そのxにtを代入したE[x/t]みたいな表現についても言葉で説明するだけだ。

*余談
Herbrandの学位論文では、unificationアルゴリズムが推論規則として書かれているということをどこかで読んだ。学位論文(元はフランス語)の英訳をチラッと見たけれど、どこに書かれているのかわからなかった。もしそうなら、アルゴリズムと推論規則の関係が垣間見られて面白いと思う。
*余談おわり

正当性と言っても、効率のことを考えてプログラムにしているので、元の定義と実装の間の関係をはっきりさせるのは難しい。

まずは、証明の「素の定義」を考える。性能については、メモ程度に書くかも。

[動機2]
証明プロクラムを作ろうと思ったのは、一階述語論理で何をどのように表現できるのかが知りたかったからだ。

SATの分野で使う論理は、問題を分析してその基本的な部分を論理式で表現しようとする。

たとえば、センサーと人工知能の間での知識の共有を考えた時、センサーで検知する世界の


0. 前提
　一階述語論理で、Resolution Refutaionで証明を作ることを考えていた。
　証明の定義としては、Gentzen的なものやHirbert的なものも考慮する。

　プログラミング言語としてはCOMMON LISPを使ったが、そのコードの正当性の証明をしようとは思っていない。アルゴリズムが妥当かどうかを考えたいだけ。

1. 証明を定義するために必要な概念にはこういうものがある。
　記号、表現、表現の操作、推論規則、証明手続き

1.1 簡単にまとめるとこうなる。
・記号、定数、関数、述語、変数など。
・表現としては、対象を表す項、論理式、などがある。

　表現はデータ、代入がその上の操作

　代入と代入操作、σとEσ
　E[x]、E[t]
　unification、mgu<s:t>
　　関係
　　　e1≡e2 e1〜e2 e1>e2などのうち必要なもの
　代入に必要な条件
　　σ1=σ2はどう定義するとよいか。必要か？

　証明についての議論は、どういうのが考えられるか
　　

　推論規則、resolution

　証明

2. 記号やシンタックス
　記号から論理式までの表現を定義するには、たとえばBNFによる定義が考えられる。
　論理学の古典的な教科書ではBNFを使うことはなかった。最新の教科書については知らない。
　BNFを使うような詳細について、教科書で触れる必要はないだろうから、普通はBNFなど使わないのだろう。

3. 代入
　代入(substitution)という言葉は、代入を行う操作とともにその代入の表現、たとえば{x/f(y), y/a}というものも意味させている。
　ここでは代入{表現}と代入操作と呼ぶことにする。

3.1 代入表現は曖昧さなく定義できるだろう。だが、その意味は代入操作と切り離しては考えられない。
　たとえば、σ={x/f(y), y/a}を表現Eに適用するとき、この二つの要素は同時に適用されるのだろうか。代入の表現が集合の{}で書かれているから、パラレルに適用されると考えるべきだろうか。つまり{x/f(y), y/a} ={y/a, x/f(y)}と考えてよいか。
 τ={y/a, x/f(y)}とすると、代入の要素を左から順に適用するのだとすると、f(x,y)に対してσとτは適用した結果が違ってしまう。ということはσ≠τとなるような代入操作の定義が存在する。

　σとτは、yについてサイクリックな形になっているから、それが不一致の原因なので、それを禁止するという定義が一般的な気もする。よく覚えていない★
　たとえばunificationは代入するたびに、最も左の項から順番に処理し、同じ項を繰り返し比較するというような定義だったと思う。そのときの代入は単に左から置き換えていくものを考えていて、矛盾は起きないはず。

　あるいは代入操作が、すべての要素をパラレルに実行し、f(x,y)に対するσやτの代入結果がf(f(y), a)となるという定義もありうるだろう。

　代入は、unificationによって生成されるので、unificationがそのような代入を生成しなければ問題は起きない。代入の生成-適用サイクルで矛盾しなければよい。

　そうすると、代入というものは無制限ではなくなんらかの制限のついたものになるので、それがどのような制限か明確にする必要がある。

　unificationで生成される代入といっても、そのunificationが代入操作を前提として構成されるのだから、よく考えなくてはならないだろう。

　どんな代入操作でもunificationアルゴリズムはuniqueに決まるのだろうか。

　一方で、制限のない代入を定義できるので、それについて考えるのも面白いと思う。
こうすると、σ=τになる。この場合でも、サイクリックな代入が出現しないように

　代入の同値について考えないという道もあるかもしれない。代入が一時的な存在であり、その同値関係を考えても有用ではないという考え方がありそうだが、ないような気がする。

　ここらへんの代入話はなかばいいがかりのようなものなので、unificationと代入操作に矛盾がなければよいはず。

　代入代数みたいなものを考えたくなった時また考えるべきかも。

　代入については、その性質を詳細に議論したものを読んだことがないか忘れてしまった。たとえば、代入の同値概念は定義できるだろうか。


4. 論理式
　Resolution Refutaionでは、一般的な述語論理の論理式を積和標準形に直し、clauseと呼ばれるA∨B∨Cを{A, B, C}という集合で表すことにする。clauseの積はclauseの集合であわらすが、この集合というのはアルゴリズムとして重要ではない。

　clauseを集合で表すということは、要素が同じ場合、集合なので一つになる。つまり{A, A, B}というclauseはなく、自動的に{A,B}になる。

　Resolution Refutationの実装では、同一の場合は、片方が捨てられるが∃<A:B>=μ≠∅の場合は{Aμ}に置き換わるという規則Factroingだったような気がする。忘れた★

　


10. 矛盾
「矛盾が存在すると、すべての命題が証明できる」みたいな話を聞くが、それは正しいのか?

述語Pについて、+Pと-Pが証明されたとしてもそれから任意の述語Rについて、Rを証明することはできない。と考えるのが適切な気がする。

古典論理の推論体系では、任意の論理式Aについて、A⇒Aというシーケントを枝にもつ証明を考える。このときAとしてなんでもよいので、矛盾が存在するとAの証明ができてしまう。

しかし、矛盾の証明と無関係な論理式について矛盾が影響を及ぼすと勘がるのはおかしい。

・直観主義なのか
・古典論理の体系(NKとか)の作り方と目的が違うのか。

なにか、議論がずれているのかもしれない。

矛盾があればなんでも証明できるというのは、論理システム(NKとかLKとか)の体系での矛盾であり、たとえばA⇒Aというシーケントについて、Aに任意の論理式をとれるという条件とその形式における矛盾の話をしているのだという気がする。

一方で、+Pと-Pが証明できたとする場面では、Pのその解釈が問題にされている。



