
　● メインテーマは何か?!
　　・FOLでどう問題を表現するか。-- proverの作りと関連する多パラメータ問題。
　　・ある種の複雑な証明は必要ないのではないか。日常的な問題領域では。
　　・問題領域・・・
　　　　・証明器はどう使えるか。どのような応用が可能か。Kowalskiの本にあるような問題領域?
　　　　・機械/深層学習をセンサーと考え、センサーから述語命題を取り出してproverで推論するという仕組みを考えたい
　　　　　(述語命題とは、述語記号を含むが変数は含まない論理式(ground wff/ground clause))

　・rubbish
　　- 代入とunification
　　- rubbishのproverの仕組み。
　　　- Exprの定義
　　　- 性能
　　　- Literalは増えない。instanceになるのみ。
　　　　Lσ1とLσ2がunifiableでないことはある。

　・varsのDVC -- post rename
　　・性能問題の解決になっているかどうか

　・julia版
　　・Viewproverで、Canonicalを用いた時、varsのつけかえ操作　その意味は?
　　・keywordパラメタの実装 -- 日本語の単語の順序でliteralを書く試み

　・課題
　　・関数記号や述語記号が左端にない記法にするのはそんなにむずかしくないのに、なぜしないのか>自分

　・rubbish proverは、timeoutやliteal数clause数でlimitを指定して、無制限に処理が続かないようにしている。
　　無限に続くのはrepeatしているからであり、それはたぶん不要だから。
　　　同じことの繰り返しを除去したい = pcodeによりproofをcode化して繰り返しを発見する
　　　　繰り返しが必要な証明があったら、それらを排除してしまうのでまずいが、そこらへんはよしと考えている。
　　　　・対象としている問題領域は、そんな構造をしていないという気がするから。
　　　　　数学の組み合わせ的な問題なら必要かもしれない。
　　　　　複雑な順番の特定の性質を持つ証明が必要だとか・・
　　　　　そして、そういう複雑さは日常のLogicには必要ないと思うのだが・・・
　　　　　　また、世界をどう書くかにも依存するのかも。

　・証明空間を切り取っていく/縮退していくイメージ

　・clause setは何を定義し、どう関連づけているか?

　　clause  : literalを変数で繋いでいる。
　　literal : 述語記号による対応づけ。符号と位置による対応。
　　　　　　　　同じ述語記号で対応付け、符号で処理がかわる。
　　　　　　　　　- 異符号による対消滅
　　　　　　　　　- 同符号によるclauseレベルでの消滅。
　　　　　　　符号のむきはその場その場かも。
　　　　　　　・引数の順番による対応(varsのつけかえ)
　　　　　　　・変数による対応(unificationによる同一化/等号)
　　term    : literalと同じだが符号がないので、位置によってのみ対応付られる。。
　　　　　　　

　　変数対応: unificationによって決まる代入関係/同一性関係


　・∧_i∀x_i ∨_jL_j がclause setの論理式

　・factとはground unit clause。
　　・groundでないとfactでない。∀xP(x) は、すべてのxについて確認できないと真にならない。
　　　xのドメインが有限であったとして、それを∀xと書いてよいかどうか。
　　　レーヴェンハイム-スコーレムの定理によって有限でない解釈が存在しうるということが問題なのか?
　　　有限であるといあうことを表現しようとすると組み合わせを全部書かなくてはならなくなり、複雑になる。
　　　(無限とは、表現を簡素にするために、メタな領域に皺寄せをしているのかもしれない)

　・Horn clauseに関する分析が必要。プログラムに限定した制限であることは、ここでの目的にそわない。


　・MLなど外部から得られたfact(ground unit clause)は、変数を含まない。
　　それは、なんらかの手段によって真だと確認された事実の表現。

　・知識は、事実によらない記述であ。そこにfactが含まれていたら、それは普遍的な真実の表現ということになる。

　・今のテーマは、factのシーケンス(Φ)によって、知識がどう変わっていくか。
　　初期知識をΣとし、factのsequenceをf_1, f_2, ...であらわすと、
　　　Σ0=Σ, Σ_t+1 = Σt*f_t という知識のシーケンスについての分析になる。
　　　・20の扉は、Φの要素factが相互に絶対に矛盾しないという特徴をもつ。
　　　　このときΣ_t+1⊂Σ_t という特徴をもつ。
　　　　tが増えると、Σのclauseの数はへっていくし、clauseのliteral数も減っていく。(減るか同じ)
　　　　なので、Σで成り立つfact g　が得られる。
　　　・また、複数のシーケンス f^1_i、f^2_j, f^3_kがあったとき、それぞれのシーケンスでことなるΣ^pができるが
　　　　たとえば、観察するオブジェクトごにf^iが変わるとすると、Σ^pはお互いに独立で、共存できて、世界の独立な側面
　　　　に対する知識が作られることになる。
　　** 変数を含むfactは存在し得ないか
　　　 ・変数が出現するには、帰納的推論が必要ではないか?
　　　　　というか、対象を見ているだけでは変数はでないな・・・
　　　　　見えていない部分について仮定をおくことが帰納ということかな。
　　　　　その仮定のもっともらしさは、統計・確率論によるのか・・・


　　それとは別に、factが矛盾する場合も考えられる。
　　　・変化に具合によって観察されるfactが矛盾する場合があるだろう。
　　　　このとき、f_tと矛盾するΣ_t-1の部分をどう変化させていくか。そんなことができないのか?
　　　　などが気になる。
　　　<<調査中>



*** Σからでてくる個々のconjectureに注目するのではなく、全体としての変化が対象。
　　Σ全体のどのような性質が、特徴づけるのか?

　・ある証明pについて、pcode(p)は、pの有限特徴量となりうるのではないか。近似値ではあるけれど。
　　
　・知識の集合であるΣとfact fによるΣの変化
　　　Σ x f -> Σ'
　　20の扉的、無矛盾拡大の場合は、次のような操作が考えられる。
　　　C in Σについて
　　　　〜f in C なら、Cから〜fを除いた(resolution)clauseでCを置き換える。
　　　　f in Cなら、ΣからCを除く
　　　　それ以外のCはそのまま継続する。

  * x in Cとは、Cの中にxとunifiableなliteralがある場合
　* factはground unit clauseなので、

　*前提: fact fはCとresolutionしたとき1つのresolventしか生成しない。
　　　　L1vL2vβ = Cで、L1とL2が同じfactとresolvableとなるということは、L1とL2がお互いにinstanceになっている
　　　　が、factなので一意に決まる・・・ようなきがする


　・この観点から懐中電灯の問題を見直すとなにか得られるかも。
　　　懐中電灯の知識(仕様)にたいして、現場で調査した結果を順番に適用していくと、何が残るか・・・

****　知識の書き方

　　今日までに調べたのは
　　　+What(elef) <=> +BIG() and +LONGNOSE() and ...
　　　いろいろな前提がある。
　　　　1) 象というものは、象の性質の合計と同値である
　　　　2) 象以外の知識で、-LONGNOSE()はでてこないだろう。孤児リテラルだがfactがひっかかる。
　　　　　　これは、問を作る時の基準になりうる。(longnoseがelephantを同定してしまうということは
　　　　　　Whatで決め打ちした場合と得られる情報が同じであり、回答により得られる知識が少ない、
　　　　　　などという評価)
　　　　3) 

　　他の書き方
　　　+What(elef) <=> +Is(BIG) and +Is(LONGNOSE) and ...
　　　　* Isを導入すると、証明するとき+Pのoppoである-Pを探すのが大変だからIsを使わない書き方にしているが
　　　　confact.lispの方法は、opposを使わないので、ISでもよいはず。■ 確認 そのとおり
　　　　* Whatを使っているのは、問題の対象となるWhatとそれの性質(Is)と区別できるようにするため。

　　　+Is(elef) <=> +Is(BIG) and +Is(LONGNOSE) and ...
　　　　* だからWhatのかわりにIsでも問題ないはず　■ 確認　そのとおり
　　　　　
　　　+What(x, elef) <=> +BIG(x) and +LONGNOSE(x) and ...
　　　　* 変数を使わなかったのは、問題の対象が1しかないので、明記する必要がないと思ったから。
　　　　　

　　　概念の階層を書くことはどうか
　　　Animal(x) <= What(Elef) 
　　　Animal(x) <= What(Whale) 

　　　Is(Big) => What(Elef)
　　　Is(Big) => What(Whale)

　　　から

　　　Is(Big) => Animal(Elef)
　　　Is(Big) => Animal(Whale)

　　　-Is(Big)のとき、-Animal(Elef)+Is(Big) と-Animal(Whale)+Is(Big)が除去されるのは適切。

　　　What(mice) <= Is(small) and Is(longtail)
　　　が働くためには、

　　　　+Is(Big)　<=> -Is(small)

　　　が必要で、これは有限domain場合の公理。
　　　　-Is(Big)　v -Is(small)
　　　　+Is(Big)　v +Is(small)

　　　ここに+Is(Big)をfactとしてresolveすると
　　　　+Is(small)
　　　が得られ、-Is(Big) v -Is(small)は除去される。

　　　この新しい +Is(small)を使ってresolutionを行う必要があるかも。今のconfact.lispは不十分かな


　　　Σxf = Σ'

　　　Δ(Σxf) = Σ - Σ'

　　　と書くとすると、
　　　Δがφになるまで、繰り返すのか・・・普通のresoliutionだ。

What述語が質問/回答のInterface用の述語だと考えると


  +What(x) <=> +Is(x)
  +Is(Elef) <=> Is(Big) and Is(Longnose)
  +Is(Whale) <=> Is(Big) and Is(Water-life)

みたいにするのか?
この場合は、短期的に生成されたfactの再適用が必要になりそう。ということは、再適用ループは必須か・・・

どう書くかを制限するという方法もありそう。

　性質のnotは必要か? not Bigと Smallを関連づける必要があるか?
　質問するときの語彙は知識表現の中の述語であり、回答はそれに基づいてyes/noなので、性質述語間の関係は不要。

　いまは、そういう多段のfact適用は不要としよう。つまり
　Is(small)とIs(Big)の間に関係はないとする。

　*** 性質述語間の関係は記述しない。
　
20の扉的にはそれでよさそう。

******* eqvでよいか?または否定のfactについて。

  P(x) <=> Q(x) and R(x)
から
  (1) +P(x) -Q(x) -R(x)
  (2) -P(x) +Q(x)
  (3) -P(x) +R(x)

が発生し、factが+Q(a)のときは、(1)がresolveされ、(2)が除去される。
問+Q(a)? に対してNoの場合、-Q(a)がfactとなり、(1)が消えて(2)から-P(x)が残る。
このfactは否定だから、20の扉の答えではない。ということは、(2)(3)は不要なのか?
左向きのimplyは不要ということか?

否定形のfactは何か?

「象ではない」ということはfactかもしれないが、20の扉はpositiveなfactを求めているので
(2)(3)は不要になる。

問を作る時に、+What(象)を出すのは、効率が悪いから行われないが、必ずしも無効になっているわけではない。
そこで、この否定のfactを使うことで、+What(象)を問から外すことができる。
知識としては価値がある。

これを「裏狩り」となづけよう。

問を作るところまで考えないとその価値がわからない。

+Bigがfactになったとき、-What(ネズミ)は除去される。not -Big がfactだから。
ということだろう。

-What(ネズミ) +Is(Big)

ということだが、Is(Small)で知識が書かれていたら、こういうclauseはないので+Is(Big)にはひっかからない。

+What(ねずみ) <=> -Is(big) and -Is(bigteeth)

だとすると、-Is(Big)がfactになったとき、

+What(ネズミ) or +Is(big) or +Is(bigteeth)

が

+What(ネズミ) or +Is(bigteeth)

になる。

問は、知識をもとに作られるので、知識に書いてある述語記号が対応する知識と合致すればそれでよい。
smallとbigの関係は、いらない・・・あってもよいはず　→ □ そういう知識を書いてみる。

□ *******
・知識にfactを適用することで出現するfactの扱いをどうするか
  知識に
　　+Small <=> -Big
　と書いてあるとclauseは
　(1) +Small or +Big
  (2) -Small or -Big
となり、-Bigがfactだと (1)ら+Smallにおき変わって、これが知識の中のfactになる。
これはどうみても普遍的なfactではない。

　知識の中のfactとは何か?
  最初の知識であるΣとfact f が適用されたΣ_tは違うものなのだろう。 □ そうか? 
　または、知識の書き方の問題かも。 □ 例を書いてみる。

****
+/-両方のfactは、知識clauseでのそれぞれのリテラル使われ方によって、役に立ったりそうでなかったりする。
****


## その他の書き方　試み
　　　+What(x,elef) <=> +Is(x,BIG) and +Is(x,LONGNOSE) and ...
　　　+Is(x,elef) <=> +Is(x,BIG) and +Is(x,LONGNOSE) and ...

はどうか?

正解をどう書くかを考えると

　+What(elef, elef)というのはなにかおかしい。

* What述語は、なんのために必要だっか
　20の扉で、問題の回答となりうる対象をそれの性質と区別したかった。

*****
 +IsElef(x) <=> +IsBig(x) and +IsLongnose(x) 
 +IsRat(x) <=> -IsBig(x) and +IsLongtail(x)

という書き方はあるかもしれない。□ どうか?

*****

■ 調べること

　■　述語What()はなくてもよい。特に困らない。
　　　Whatでresolutionしないからかな。
  
　■　性質側の述語もIsであれhasであれなんでもいい。oppo関係が必要ないので対応関係もとくにない。
　　　知識にある述語しか書かないとすると、oppo関係は知識にでてくる場合のみ必要で
　　　それ以外の述語は関係しない。
　　　

