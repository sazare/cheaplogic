
　● メインテーマは何か?!
　　・FOLでどう問題を表現するか。-- proverの作りと関連する多パラメータ問題。
　　・ある種の複雑な証明は必要ないのではないか。日常的な問題領域では。
　　・問題領域・・・
　　　　・証明器はどう使えるか。どのような応用が可能か。Kowalskiの本にあるような問題領域?
　　　　・機械/深層学習をセンサーと考え、センサーから述語命題を取り出してproverで推論するという仕組みを考えたい
　　　　　(述語命題とは、述語記号を含むが変数は含まない論理式(ground wff/ground clause))

　・rubbish
　　- 代入とunification
　　- rubbishのproverの仕組み。
　　　- Exprの定義
　　　- 性能
　　　- Literalは増えない。instanceになるのみ。
　　　　Lσ1とLσ2がunifiableでないことはある。

　・varsのDVC -- post rename
　　・性能問題の解決になっているかどうか

　・julia版
　　・Viewproverで、Canonicalを用いた時、varsのつけかえ操作　その意味は?
　　・keywordパラメタの実装 -- 日本語の単語の順序でliteralを書く試み

　・課題
　　・関数記号や述語記号が左端にない記法にするのはそんなにむずかしくないのに、なぜしないのか>自分

　・rubbish proverは、timeoutやliteal数clause数でlimitを指定して、無制限に処理が続かないようにしている。
　　無限に続くのはrepeatしているからであり、それはたぶん不要だから。
　　　同じことの繰り返しを除去したい = pcodeによりproofをcode化して繰り返しを発見する
　　　　繰り返しが必要な証明があったら、それらを排除してしまうのでまずいが、そこらへんはよしと考えている。
　　　　・対象としている問題領域は、そんな構造をしていないという気がするから。
　　　　　数学の組み合わせ的な問題なら必要かもしれない。
　　　　　複雑な順番の特定の性質を持つ証明が必要だとか・・
　　　　　そして、そういう複雑さは日常のLogicには必要ないと思うのだが・・・
　　　　　　また、世界をどう書くかにも依存するのかも。

　・証明空間を切り取っていく/縮退していくイメージ

　・clause setは何を定義し、どう関連づけているか?

　　clause  : literalを変数で繋いでいる。
　　literal : 述語記号による対応づけ。符号と位置による対応。
　　　　　　　　同じ述語記号で対応付け、符号で処理がかわる。
　　　　　　　　　- 異符号による対消滅
　　　　　　　　　- 同符号によるclauseレベルでの消滅。
　　　　　　　符号のむきはその場その場かも。
　　　　　　　・引数の順番による対応(varsのつけかえ)
　　　　　　　・変数による対応(unificationによる同一化/等号)
　　term    : literalと同じだが符号がないので、位置によってのみ対応付られる。。
　　　　　　　

　　変数対応: unificationによって決まる代入関係/同一性関係


　・∧_i∀x_i ∨_jL_j がclause setの論理式

　・factとはground unit clause。
　　・groundでないとfactでない。∀xP(x) は、すべてのxについて確認できないと真にならない。
　　　xのドメインが有限であったとして、それを∀xと書いてよいかどうか。
　　　レーヴェンハイム-スコーレムの定理によって有限でない解釈が存在しうるということが問題なのか?
　　　有限であるといあうことを表現しようとすると組み合わせを全部書かなくてはならなくなり、複雑になる。
　　　(無限とは、表現を簡素にするために、メタな領域に皺寄せをしているのかもしれない)

　・Horn clauseに関する分析が必要。プログラムに限定した制限であることは、ここでの目的にそわないだろう。

　・MLなど外部から得られたfact(ground unit clause)は、変数を含まない。
　　それは、なんらかの手段によって真だと確認された事実の表現。

　・factシーケンスについては 20210502_factextens.txtに記載

