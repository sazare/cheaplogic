20200411 のこっていること


1. vars版とunif版
  vars版というのは、<e1:e2>のとき、e1とe2の変数をvarsとして持ち、
  代入はvars←exprs の形を前提として、表現はexprsのみにする。(cheaplogicの方法)
  
  このvarsを代入の中に残すとvs←esの形になりばらばらにすると
  [vi←ei]の形になる
 
 代入演算@と*の違いはこの二つの表現の違いと直接関係しないが
 @の場合はvs←esで表現するほうが見やすい。vsの順番が結果に関係ないということが表されているので。
 *の場合は[vi←ei]で表現する方が見やすい。順番に意味があることを表現そのもので表しているから。
 上にも書いたように、vs←esでも順番に意味があると考えれば、この違いは本質的ではない。
 

 処理の上では、どちらであれ、unifyのとき、該当する変数を探す処理と、対応するeを置き換える処理がある。
 *の場合は、全eiについて代入
 
 
 - 表現代入(e□σ)
  ・symbol(var)に対して、同じviをみつけ対応するeiをみつけて置き換える。
  ・どちらの表現の方が効率的か?
  　それぞれの表現をどう実装するかによる。
  　　[vi←ei]は、表現をそのまま実装するとproperty listのような順序を持つペアの集まりとなりそう。
  　　　pairlisを使うと、vs←esから[vi←ei]への変換はlisp関数でできる。
  　　vs←esは、vsを検索したあと、対応するeiをどう見つけるかのところに効率上の問題があり、
  　　hash-tableのような実装(メモリは余分に消費)になりそう。
  
  　　[vi←ei]と書きながらhash-tableの実装はありうるが、hash-tableでは順序を残せないので
  　　もしも順序に意味があるのなら[vi←ei]では対応できない。
  　　実際にunifyではdisagreeひとつずつをmguに蓄積していくので、代入代入で@にするか*にするかで
  　　結果が違いそう。しかし、disagreeの目的は異なるペアの発見だけなので、mguのことは気にしなくてもよいだろう。
  
 - 代入代入(σ1□σ2)
  ・vs←esの記法と[vi←ei]の記法を混在させることはしない
  ・@と*の違い
  　- @では、単に和をとっていくだけなので、同じ変数の有無のチェックだけが必要になる。
  　　vs←esのhash実装では、同じkeyがςにあるかだけのチェックであり、高速にできそう
  　　　変数の検索ではなくhash値の計算であることと例外の場合の計算量・・・
  　　[vi←ei]のlist実装では、ςを一通りなぞる必要がある(平均|ς|/2、最悪|ς|)
  
  　- *では、変数の有無のチェック+E(σ)に対するςの適用が必要になる。
  　　この適用が*なのか@なのかという点は、
  　　vs←esのhash実装では、
  　　[vi←ei]のlist場合、同じkeyの有無と、eiに対するςの適用が必要になる。
  　　　ei□ςは、どちらの演算になるか・・・
  　　　　
 代入代入はmguの集積で行う演算であり、こうしてためられたmguがresolventに対して適用されることも考えなくてはならない。
 　
 
 
2. seqでは
  a) resolutionでどう使われるか
 
 3. par版
 
 4. disagreeの高速化
  a) 前のdisagree pointの続きから探しに行く
  b) disagree point以降に前半で作ったmgu　σを適用しないといけない
  この2つのことができるか?
  
  b)は、disagreeで違うペアがでてきたときに適用して、そのペアについてdisagreeすれば十分
  　もともと同じなら、σをかけても同じだし
  　違う時は、両方にσをかけてdisagreeする。
  　最終的に同じになったexprは作る必要がないということ
 
  a)は、前のdisagreeの結果を覚えておく必要があるので、closuerで実現できると思うが
  　他の方法はどうか?
  
  