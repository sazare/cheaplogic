ちなみに load_viewprover.jlで動かすと、readcoreしたものは変数coreにはいる。
QEDは☕️でしめす。
バグは🕷でしめす。「ばぐ」
重要なことは🎂でしめす。「こう」
何かの影響を🕸でしめす。「す」


-- todo
 go to issue in github. ちょっと使いにくい offlineではわからなくなるのでここに戻す
20200913 itoのbaseとbase-noranは再定義を含むので、同じitoの中におきたくない。どうすればよいか
20200823 lid,clidはもともとの数字またはatomのままでいいような気がする。
20200823 resolve/renameでvarsとsigmaの対応を明確にする
20200823 resolve/lidの実装(litつき)
20200822 oppos(resolveの候補lids)をもとめる最短路
20200822 Lidの木、σの再生とそのコスト



--- log
20201004日
・ベンチマークのフレームワーク
・性能評価ツール
・

・package化の案
　1) symbol, expression
　2) substitution(A)
　3) unification(A)
　4) raw resolution
　5) resolution and proofs
　6) strategy
　　　strategyを構成するためのfunctions。
　　　特徴と処理

・utilityとして
　1) かけるか?? gensymの差異を回避できるか?


・ときたい問題
　- 製品の仕様と故障の現象から、故障の原因を導き出す?
　- まどマギの表面的な事象から、背景の世界を導き出す
　- DLによるFactsの収集と、あらかじめ作ったルールの集合から、今起きている問題を導く(??)
　- Factsからルールを導けるか(帰納)
　- 個々のルール(間違っているかも/有限のFactをまとめた)からの一般化
　- 時間によってかわるもの


・予想
　- わかり切った結論しかでない(演繹とはそういうものでは?)
　


20201003土
・すること
　- proof
　　cid -> parents, mgu
    mguはparentsから作れる場合もあれば作れない場合もある
　　ということはcidのpropertyにもつことになりそう
　　proof情報は独立。mixtureみたいな構成
　　ということでよいのでは
　　意図をどう書くか

　- cidにproof=(:reso mgu (plit1 plit2))を設定するようにした。entry-proof
    mgu=(vars sigma) このvarsは親のvarsのappend

　- resolventのvarsがちゃんと設定されていないかも
　　　わからなくなったのでひきつづき

　　　元(x y)
　　　mgu (y y)
　　　resolventのvarsは(y)
　　　mguは(x y)<-(y y)
　　　resolventのvars　は(y)になる。xは消えているので(shrinkvs)
　　　proofのmguには(x y)<-(y y)が必要みたいにみえる。
　　　というか(x)<-(y)は必須

　　　ということはproofにおけるmguは親の世界のmguであり、varsは作業中の
　　　(append (varsof lid1)(varsof lid2))みたいなものでないといけない

　　resolventのvarsはshrink
　　mguは親のvarsとmgu

 　　解決




　　　

　- strategy
　　once resolutionはproverとしてどういう能力があるのか

　- unificationの証明
　　test/instanceだけではいつまでもバグがのこるので、性質の証明でおわりにしたい
　

20200927日
・proofの続き
・(symbol-plist 'aaa) でも表示できる。symbolでなくatomでもよい

・proof情報をcid,lidに混在させるかどうか
　1) clause/resolventはproofと渾然一体なのだから混ぜて当然 => yes
　2) resolution とproofを分けて考えたほうがsimpleではないか => no
　　　proofはresolutionのメタな情報

・lidにplidを追加し、resolve-idでその値が正しく設定されていることを確認した
　　が、この設定が最善ではないような気がする
・消えたlidはmguでつながるので、proofというか*mgu*もほしいかも。
　mgu1 = <L1:L2>の関係。varsはvarsof(cidof(Li))できまる
  mgu1 = (vars . terms)
 どっちだ

  A案)
　mid = (:vars (x y) :subs ((f a) a))

  cidとmidはどう関係??

  B案)
  mid = (:cid cid :subs ((f a) a))

  
  ? mid -> L1 L2

　proofとの関係は?
　　
  step = cid, (lid1 lid2) 
  sig1 = <lid1:lid2>

  midがないと、再現できるかどうか
　midがあると Lid1, Lid2が不要か???


A案のmguはいるのかなあ。
midの値がtermのリストで、midのplistに(:cid cid)を持つ
すると、cid -> varsofで(vars .

20200926土
・今日はproofを考えよう
・sigmaはresolve-idの前半で得られている
・proofの構造は?
・案1)
  proof=step*
  step=parent*
  parent=lid, rule

  親clauseは(cidof lid)でわかる
  親が1つの場合(renameとかmerge)や2つの場合(resolve)も同じ型のstepが使える
　どうだろうか
・lid, cidの構造
　cid 
   :body->lid*
   :vars->atom*
   :step->(rule . lid*); rule=:reso/(lid1 lid2), :rename/(), :merge/(lid1 lid2)in same clause
   :name -> any
   :sigma -> :reso=><lid1:lid2>, :merge=<lid1:lid2>, :rename=>generated
     :renameのときは、sigmaの左がおやのvarsの一部で、右は新しい変数リスト

しかし、sigmaはproofの構成物ではないだろうか

  lid
   :cid -> cid
   :lit -> literal::S-exp
   :prev-> lid {input=>lid=nil,reso=>(lid1 lid2)
   : 

#で1以上の繰り返しを表すことにしよう。*は0回以上の繰り返し



20200923水
・cidの値にはbody、lidの値にはlitを設定した
・(cidof 'xxx)のように'が必要なのが気になったのでmacroでつけなくていいようにしてみたが
  意図はつけなくてはならないので、よくわからなくなってしまった。
　つけることにして、macroは使わないようにした。
・print-literalにlitが表示されていなかったので修正した。symbol版では表示されないのではないか

20200922火
・atom版をつくってみる(20200921atomid)
　局所的にながめながら修正すると何が正解かわからないのでだめ
  genで、(gensym ...)　のあたりを(intern (string (gensym ..))) みたいにした
・atomのvalueとpropertyは別になっているつまり
　(setf B '(:name 1 :body '((+ P x))))
　と
  (setf (get 'B :name) 1)
  (setf (get 'B :body) '((+ P x)))
　は違う。後者はBの値がなくてもよい。
　alistのように、valueからひいてくるのではないらしい。つまり
　(setf B '(:name 1 :body '(a)))
　とやって:nameの値を引くことができないような・・・
　さて、どうするか

・(make-clause)すると、cid, lidのpropertyにははいっていた。
  valueがないのでそこに生をいれておけばいいのかな・・・
・意図はエラーにならない。symbolのかわりにatomが使われているだけなので・・・
　タイプしたアトムが使えるので、こっちのほうが楽

・(symbol-plist 'cid)でproperty-listがとれる・・・もしかして何か間違っているということはないだろうか

・なさそう。print-cluaseとかdump-clausesとかも動くのでよいのではないか


・(inspect 'cid)が面白い。

　
・atom版をmasterにした。symbol版は20200921symidとした。


　
20200921月
・証明情報をどう持つか・・・resolve-idの外側で作るのかな
・cidの重複が何度もでているということは、resolve-idで作ったcidについて*maxcid*などがメンテナンスされていないらしい。
・internでatomのpropertyに設定するのができるかどうかすこし考え中
　それをしようとすると、baseあたりを全部書き換えたくなる
　つまりlidやcidをatomにするので・・・
・今は、cidやlidを容れておくatomを作っている。これはテストのためであり、実際に使う時はこのatomはいらない・・・のだろうか。
　そうとも思えないからつらい。



20200920日
・意図がとおっていないのは、resolve-idで作る形を変えたから。
　どうテストすればよいのかがはっきりしていない。
・いいのだが、resolve-idしてできたsigmaをどこに残すのかはっきりしていない
・resolve-idで、データを作って、最後にentry-clauseでまとめてidに登録している。
　このインターフェースがだめだというのもある
　意図を書くとき、idの中身を取り出して、S-expとして比較していて
　それを取り出す形が煩雑。
　特に、clause+sig(v.t)というのは意味がわからない。
　どうすればよいか??
・いまのところ、意図が成り立つように書いてみたが、直さないとならぬようだ。


20200919土
☑️srcをjuliaに、lispをjuliaのとなりに移動する
☑️aliasの修正
・動作確認　ito-rubbish-resoid.lispで同じエラーになったのでよし

・でもito-rubbish-resoid.lispで失敗する理由は?

🎂atom作れないと言っていたけど、internでatomにするか? そうすれば、同一性はたもてる


20200915火
・inputのとき番号が増えない
  make-clause->make-cidで*maxcid*を設定した
　入力nameが*maxcid*と同じときメッセージを出す・・・完璧にはほどとおい
・load-rubbish.lispにload-rubbish-resoid.lispがあってエラーになっていたのでコメントアウト
・resolve-idにもどって、整頓した。cid, lidがつくられてつながる
　lidにはRがはいり、cidには入らない。どうでもいいのでそのままにする。
　この部分はテスト作っていない

・できるかぎりテストドリブンでやっているが、うまくいかなくなることがある。
　複雑なものは難しいかな。
　todoがちゃんと書けるくらいに整理しないとだめか。

・演習問題程度なものは、繰り返しやるので、設計が明確になるが、初見の場合、それは実施できるものなのか
　とは思う。

20200913日
・resolve-id のresolventに複数literalがある場合の意図で、subsubpをしていたのはまちがいだった。
  substpが正しい。
・さらに、テストはlidのリストをlitのリストとして比較したかったが、lit*ofがなかった。
　cidに対するbodyofはあるが、生のliteralはなかったという話。
  baseにlit*ofを追加し、resolve-idのテストを修正した。
・lit*ofはテスト用の関数のような気もする。これを使ってprint-clauseを書き直す?
　と思ってprintをみたらlitsofを作っていた。
　やはりUI系の関数ということか。printからlitsofを消して、lit*ofにかえた。
・subsubpのbugfix
  めちゃくちゃだった
・resoidの意図にもどったが、resolventをつくるためのpropの設定ができていない

🎂issue itoに、baseとbase-noranを作ったが再定義のwarningがでて醜い。
　どう解決すればよいか。

・resolventのcidはまあRでいいか。
・*clist*, *llist*, *maxcid*の管理部分を作る
  どういうタイミングで増えるのか?
  new-cidは*maxcid*をふやしていく。inputのときがうまくいっていないような・・・

・あれ? load-rubbish.lispでエラー。ito-rubbish.lispはOK


20200912土
・atomの作り方/作れる
* (defvar vvv (intern "GOG"))
VVV
* (set vvv 123)
123
* vvv
GOG
たしか、今使っているパッケージにできるはず。

・resolventを作る方法を考える。いきさつの細かいことは忘れている。
new-resolvent(vars, sigma, ((Li . Liti),...))
　Liは親のLid, Litiはsigma適用後のLit
 1) make ncid(*maxcid*をもとにmax+1にするか・・・
　　そのためにはkqcioでinputのmake-clauseのときに*maxcid*をmaxにする。
 2) ncidのvars(nvars)を作る(vars, sigmaから?)
　　・ncid.vars = nvars
 3) nameは*maxcid*
    ・ncid.name = *maxcid*
　　resolventのnameは全部"R"でもよいような気がする
    親はlidのprevとproofのparentでわかるので数字である必要はない
    でもnameがみんなRというのはどんなものか・・・proofを別にもつからそう思うのか
　　全部Rということは、gensymが作るランダムな部分が区別要素になる・・・
　　もしも自前で区別要素(distinguish part)が作れたらrandomは不要か

 4) bodyを作る
　　4.1) LiからnLkを作る
　　4.2) nLk.cid = ncid
　　4.3) nLk.prev = Li
　　4.4) nLk.lit = Liti

となると
　cid => parents (:reso C1 C2)みたいになるのか
  (:rename C1)とか
  proof情報をcidにつけて大丈夫か


・rootofはCの次から.までをとってくる
　C12.xxxx => 12
　CR.yyyy => R
まあこれでもよいか

・resolve-idで最後にsubsubpしているが、literalのリストにたいするsubsubpにならない?****

　

20200907月
・lidからnewlidの場合

20200906日
・resolve-idの続き
・PvQと-PvRがQvRにならないところまで。Qになってしまうエラー
・resolvent のlitに代入したとき、新しいlidを作りたい
・そのときresolventのcidが必要
というあたりが未定

・string => atomはないんだよなあ
・jupyter common-lispをインストールしてみた
　ito-rubbish.lispうごく
  https://github.com/yitzchak/common-lisp-jupyter
　に書いてあるようにした。
  rosもいれていたが、rosでのインストールは失敗(ros install common-lisp-jupyterで名前がわからないと言われた)
  quick-lispいれていたので、quick-lispのupdateをした。
　sbclを起動し、(ql:add-to-init-file)はいらなかったかも。
　ql:update-dist "quicklisp")
　githubからrepositoryをcloneして、そこでやってみた。
　20190521以前のものと書いてあるやつ。
(ql:quickload :common-lisp-jupyter)
(cl-jupyter:install)
(quit)
して
jupyter console --kernel=common-lisp
これをするとterminal上で、jupyterのconsoleになってしまい、やめた。
^Dでないと終わらなかった。
jupyter 自体は
どこででも
jupyter notebook
でできるようだ
newにcommon lispがはいっている






20200905土
・cid, lidを数字にするのはやめて、もとにもどそう
・まず、文字列を内部形式に変換する。fileから読み込む(kqcio)の一部に含める
  まず、rubbish-kqcio.lispとito-rubbish-kqcio.lispを修正。readastring, readskqcを追加
・rubbish-base.lisp、setcid, setlidの意図
　base-noran.lispでやっていた OK
・resolve-idの意図をつくろう


20200830日
・DVCの効果をうまく評価できない。どうしたらいいか。
　分析必要


20200823日
・L100とL200のresolveをするとき
  <origin(L100):origin(L200)>が失敗するならresolveを試みる必要はない。
　<L100:origin(L200)>も失敗すれば<L100:L200>も失敗する。
  L200の祖先でL100とresolveに失敗するリテラルL120があるとすると
  <L100:L120>faile, <L200:L120>=σ1(L200はL120のインスタンス)
  <L100:L110>=σ2, <L200:L110>=σ3で<L110:L120>=σ4の特徴はなにか?

・lid,clidはもともとの数字またはatomのままでいいような気がする。
 　が、数字にするとsymbol-plistが使えないので、どうやってリンクをもたせるか悩ましい。
　 plistとしてもたせる?
   cidlist=(1 '(1 2 3) 2 '(4 5) ...)
   lidlist=(1 '(lit '(+ P x)...)
　　　だめだ。

  今のcid, lidでだめになりそうなところは、人間がlidやcidを指定するとき、文字列をmake-symbolしてもだめというところ。

  たとえば、lidを*lidlist*から探すときは、
(setf *slidlist* (map 'list #'string *lidlist*)) ;; stringify

(defun findid (id idlist sidlist) 
  (loop named findsid 
    for sid in sidlist as ssm in idlist do
     (when (equal id sid) (return-from findsid ssm))
  )
)

(findid "L1-1.418" lll *slidlist*) ;; (#:L1-1.418)

(eq (car lll) (findid "L1-1.418" lll *slidlist*)) ;; is T ok

でstringからsymbolに変換はできるが、ちょっとtime consumingすぎる。

1. 人間がlidやcidを直接指定する場合はどんなとき?
2. Web にしたとき、inputの文字列からcidやlidを作る必要がある。
3. 直接指定する場合、cidにname(番号)がついていたらそれでとってこれるだろう。
　lidはその(bodyof cid)のn番目を指定して取ることはできる。


*番号をidにする場合、連続性は仮定しない。
　だから、配列にいれるわけにいかない。

・cid,lidを数字にして、symbol-plistの構造でなく、number->alistにする実装を確認した。play-rubbish.lisp


・人間がlidやcidを直接指定する場合は、stringに変換してclistやllistから検索るのでよい。性能が必要ないから。
　ということで、lid, cidはsymbolのままで続けよう。
　自動の場合は問題ないような気がする。

・そこでopposの処理を作ってみる。これはresoの一段上の制御になる。rubbish-baseでいいのかな。

・Lid -> (sign . Psym) -- oppo --> (-sign . Psym) -> Lid*



20200822土
・oppoをもとめるため、-Pと+Pというシンボルを作り、その値またはplistとしてlidを持たせるというのはどうか
・symbol +P,-Pの値としてlidのリストを持つようなことを考えた
　make-symbolするたびに見た目はおなじだかeqで異なる判定されるシンボルができるらしい
　シンボルはどう作ってもuniqueだと思っていたのだが・・・ packageが違うのだろうか


・


20200817月
・input ⇒ literal pairのunify ⇒ ngは無視し、σのみをとってグラフ再構成
　⇒ σの合成についての新しい制御を導入すれば、Flowができそう。
　ポイントは、clauseの集合を代入の構築物にする点。
　そのアルゴリズムがもとのrefutationの集合と同等かどうか?

・プログラム合成には興味がないが、proofと代入(の構成物)の対応は興味深い。
・代入の構成物は、実行可能性に拘らなくてもいいのかも。
　(x,y)←(a,f(y))は、
　　(1) {if x=a then y←f(y)}
　か
　　(2) {(x,y)←(a,f(y))}
　というmguに対応するというような考え。


・<L1・σ1:L2・σ2>=σ3となるためには、<L1:L2>がunifiableでなくてはならないという話。
・proofに出現するすべてのliteral/ resolventのliteralはすべて入力リテラルに元があり
　それのインスタンスになっているという話。





20200816日
・input clauseの組み合わせで、mguを先に作ってしまうというのはあるのではないか。
　あとはmguの合成だけで処理する
　これは、命題論理のproverと一階述語のproverの中間になる
  mgu+remという混在はどう考えるのか

・cid,lidのplistによる連結は、時間によって変化する公理系を実装するのが難しいかも。
　公理系1つを1つのプロセスとし、プロセス間通信にする???

・今は設計の情報あつめになってきた。
　観点がかわりつつある。新しい視点


20200815土
・todoをissueにもっていった
・(resolve lid1 lid2)=>clause Aを作ってみる。cidでなくclauseかな

・graphをどうするか
　操作の流れ
　cid -|body|->lids-|select|->lid->(sign, psym)-|oppo|->lids
　という流れになる。oppoで(neg, psym)にする必要はなさそう

 a) (plist::(p lids)..., nlist::(p lids))...)
 b) ((p lids lids)(q lids lids)...)
a)は、全体をpogとnegに分けたもの
b)は、述語ごとにpogのlidsとnegのlidsをもたせたもの
oppoを考えると、b)が妥当


・今日作ったもの
  remof(lid) = bodyof(cidof(lid))からlidを除いたlids

  varsof(lid1) + varsof(lid2)であたらしいvarsを作るが、このとき
　unionではなくリストの並置。appendか。

・現状の問題点
  - lidにsubsubpしているのでlitはそのまま
  - 新しいlitにlidをつける必要あり
  - あとでcidをつけるとなるとcidのbodyは更新されていない
  - varsは必要なものだけにできるのか?

・グラフのapi
  - lid -> lsym -> oppo -> lids
  - goal -> lids

・sibling(lid1,lid2) == cidof(lid1)==cidof(lid2)





20200814金
・read-kqcではcidsしかでないが、lidsもほしい・・・

・(alllids cids) :cidsから含まれるすべてのlidを取り出す
・(lidsof cid ns): cidのbodyからns番目のlidを取り出す
・(choose ns os) ; general select ns th of os

・graph0を作ろうとするがどうするか
graph0 = (P (:+ (L10 L20) :- (L11)) Q (:+ () :- (L77)))
みたいなplistをかんがえるも、これは2次元のplistか・・・
plistはkeywordで検索するようなイメージの例ばかりで、keywordが自由なのはないのか?
plistはkeyword-valueと考えるのが正解な気がしてきた

idを管理するのには適さないのかも・・・いやまて・・・
(gensym)はなんのためにあるのだ・・・




graph0 = (P ((L10 L20) (L11)) Q (() (L77)))

でよいか





20200813木
・(read-kqc)を(print-cluases)で表示。(clausesof)でlistにする。
・varsが()だとNILになってしまう。printは()にしたほうがよいかも
・rubbish-printには
 - print-clauses
 - clausesof
 - dump-clauses

・シンボルわからん
　(readkqc )で読み込むとcidのリスとができるが、そのリストのcidを
取り出してsymbol-plistなどは動く。
　しかし、その名前をreplで入力すると、(symbol-plist)はnilになる。
　みためではないのか・・・

・idは数字にしようかな
・symbolでいいかな。idsのインデックスで指定すればいいんだし数字にしたらsymbol-plist
　みたいな操作ができない

・あと変数を作る必要があって、変数名+数字にするとsymbolになるから・・・そこはさけられなさそう。
　だとするとtpuのように決まった変数のリストを使ってrenameするか・・・



20200812水
printを作ろうかと思っていたがito-r*-base.lispがエラーになったのでそれを修正。
noranと同じなので不要な気がする。
gensymを使わなければよい


20200811火
・symbolに小文字が混じると||で囲まれることに気付いた。
・cid, lidはsymbolで動作した。base-noran
・kqcioで読み込んでbaseまでするようにした。itoはかけていない。

・cidもlidもただの数字でよいのではないか
　と思っていたが、itoが動いたのでそのまま。ううむ

・明日はprintを作るか・・・


20200810月山の日
・idとstringとatomの関係について調べる。
  atom -> stringは(string -)でも(symbol-name -)でもOK

・(symbol-plist -)がよさそう。symbolに対してplistのインターフェースを提供
　(symbol-value 'a)もあるが、結局p-listにしたいので、(symbol-plist)がよさそう

　ということは、atomを使う必要はないような・・・

・symbolは、REPLで入力するのがむずかしい。見えるままではだめなのか??
  #:C1. と :C1. は違う。。。


20200809日
・cid, lidを生成する関数に、デバッグ用に固定のidを生成するものを作ろう
　メタレベルで切り替えてコンパイルすればどちらかになるような方法がないか考えたけど
　よくわからないので、実装ファイルを二種類にして

  rubbish-base.lispからmake-cidとmake-lidをrubbish-gen-noran.lispにうつし
 itoの先頭ではnoranをloadして使うようにしよう。
　gensym版はそれ固有の意図を作る。

・rubbishをwasteにかえるのはどうだろか
　cheapwasteでもよいし
　wastelogicでもよい

・ずれていると思ったのは、ruleの部分
  stepid(sid)

  sid -|left|→lid
　　　-|right|→lid
　　　-|subs|→mid


　mid -|vars|→V*
　　  -|subs|→T*

  ρの場合はT*はN*でNは変数名

・symbol - atom - stringの変換方法忘れた
 symbol-name: symbol -> string
 make-symbol: string -> symbol
  symbolかstring -> atom


20200804火
手でやってみている。
mguとcidとlidの対応がずれているような


20200802日
🎂ID管理などを行う部分をbaseと呼ぶことにする。
rubbish binからbinも考えたが、binはバイナリなのでやめた。
julia版にあわせてcore・・・もともとcoreはいただけないと思っていたのでやめた。
pureだとresolutionの関数の意味に感じる

特別な意味を感じないbaseにしようと思う。basic・・・BASICはいやだ
rootはlinuxのrootだし

base

🎂 (isterm e)など書いてみたが、これ、使うかな。

使いそうなものを書いてみる


20200801土
水曜に作ったresolvとisolatevsは裸の機能の実装だったが、それに証明情報を対応させようと
すると難しい。

そこで、その前に証明機構などを作る。

機能仕様や実装について、何となぜをまとめておくことにした。
なぜそのような実装を選んだのか。何を作りたいのか、というようなこと。

cheaperlogicにlisp実装だけを移動したい。
リポジトリは作った。

そうなるとcheaplogicとcheaperlogicの両方にかかわるdocumentはどこに書けばよいか。
cheapthoughtにおくほうがよさそう・・・
まあ、交わることはないと思う。

gitの履歴がとぎれるので、やめた。
たぶん、cheaplogicをcloneして、いらないものを消したりdir構成を変えてから
別のrepogitryとして作るのか・・・
面倒になったのでやめた

履歴を残さないでいいのならできるが
prover話のつながりが切れるのもよくない・・・

20200729水
ツールはリポジトリlisptoolsに移動した
~/lib/mysbclは~/lib/lisptoolsに変更
そこはcloneした
.sbclrcのmylibの参照する*MYLIB*をこのパスに変更したので
ツールは(myload "ito.lisp")みたいになる

🎂ToDO20200729   unif, resoの'NOは:NOにする
した

(resolve)で、varsをきれいにするのがすこしわからなかった。これは(shrinkvs)
最終的にはこれで正しいはず。
<L1:L2>に出ていない変数も残る。

次はrenameで、関数名は(isolatevs)
これの意図は作っても動的に変数名が変わるからだめかな。

変数名を決めてからrenameする部分をわけてみた。
isolatevsではないな・・・ただのsubsubpか・・・

vs -> nvsにしたあとで意図は(subsubp nvs ncls vs)で元のclsに戻して比較してみた。

これで、次のレいやーで証明情報やidと実体の対応付がうまくいくかどうか
もう一度設計にもどって考えてみる。


20200726日
・全体デザインすこしずつ

・ proof stepについて検討
(v l1 l2 r1 r2) から
v.σ = v.<l1:l2>
v.r = v.(r1+r2)*σ
ρ=new(v)
 σ' = ρ.(v.σ@ρ)
 r' = ρ.(v.r*ρ)

** ρ.(v.A)は、ρ.Aを作る操作。変数リストのつけかえ

結果 (ρ σ' r')

step
 (v l1 l2 r1 r2) : l1 l2 ⇨ σ, v.(r1∪r2)*σ  => ρ(v.σ@ρ) ρ.(v.{(r1∪r2)*σ})@ρ

どう表現すべきか

 v1.c1 v2.c2 ; v = v1∪v2
 ----------- v.σ = v.<l1:l2>
 v.r         ; r = (c1-l1)∪(c2-l2)
 ----------- ρ = gen(v)
 ρ.{v.(r*ρ)} ; 右のρは定数とみなして代入し、左のρは変数としてバインディング

ここに表現されていないがc1,c2から最後のところまでの代入は
　ρ.{(v.σ)*ρ} 
になる。





20200725土
renameの部分を作り始めた

20200724金
1 resolveのパラメタに関数を渡すにしろ、defparameterで名前をつけるにせよ、funcallが必要なのだ・・・
　schemeならいらないのかな。

呼び出すところ全部にfuncallをいれるのはいやなので・・・

  (defparameter *funp* ...function to be called...)
これをresolveを呼び出す部分で定義して、resoでは

　(defun sfun (x y) (funcall *funp* x y))
みたいな関数sfunpをそれぞれ作っておくか・・・
resolではfunでなくsfunを使う
引数の数は固定なのでこれでつながる。

これが働くためには、substpとかsubstsとか別のモジュールにする必要がありそう。
それぞれが完結していないと
しかし、spは両方使うので、どうすべきか・・・
たぶん、unificaionspを使う人にとってのsubst, subsubなのでsubstpとsubsubpだけでよいのではないか。

この変更はreso layerのみ。


🕷 <(P x):(Q x)>がnilになる。NOになるべき
disagの定義で関数名が違うときNOにしていなかった。
何か他の不具合があったようだが、有効にしてなにも問題がなかったのでそれでOK





20200723木
1. make alias sbcl='sbcl ... --userinit ~init.lisp ...'
  init.lisp contains definition *MYSBCL* and myload

  *MYSBCL* has a path to my lisp utility file.
  myload load file from *MYSBCL*


2. refactor lisp files
🎂名前　rubbish prover
🎂ファイル構成
　subst, subsub(pnot, snot): 代入
  unification: snot, pnot, sp版
  resolve: S-expレベルのresolution(proofはまだない)
  essential: clause管理とresolveのつなぎ. COREはrubbish binと呼ぶ?
             proof管理
　rubbish provers: proverはいろいろありうるので、全体をrubbish proverと呼ぶとすると
　 simple-rubbish :単純なprover... control over resolvent num, proof steps
    p-f correspondence 
　 view-rubbish: Web GUI prover with human interraction

ファイル構成をかえた
今まで作ってきたlispコードはoldsに移動
rubbishコードのファイルは、〜rubbish-〜.lispとした


☕️TODO20200723   ito.lispを違う場所で使いたくなった。juliaのLOAD_PATHみたいなのがほしい

ito.lisp and ito-ito.lisp are soft link to ~/lib/mysbcl
とし
(myload "ito.lisp")
でロードするし。
(load "ito-ito.lisp")
で意図できる。でもオリジナルはcll





20200720月
#|...|# がコメントのように働く・・・でもS式にはならない
それでいいのか?
kqcはこれでコメント書くことにしよう。
特に修正なし


20200719日
🎂どういうデザインにしようか考え中
　julia版をみなおしているが、ややこしくてどうしたものか。
　viewproverは動いた。
  みためはともかく・・

　dataにある、ものをなんと呼ぶべきか
　juliaではcoreと呼んでいた。readcore()で読み込むと、coreになるからそれでいいのかな。

　coreは一般的すぎてどうかな。
　specみたいな用語があるとよい。

　coreは何か?

  .cnfはclause normal formかなにかそういう名前だったような
　　でもjuliaとlispでは違う形になっている

 factsでもないし
 descriptionでもないし

 lispの場合、evalすれば実行される。
 macroで定義するように書くか

　something writtenで、swではどうか。拡張子は.swf swiftとぶつかるのか
  swnかsowか
　ならば、something to want(stw), something to desire(std)
  something to wrettenでstwか

 sowはstatement of workだそうで、statementが使えるかも

 statement of worldとかstatement of desireとか。後者ならsodか

 quelque chose (qqc)にしておこうかな。長い語は出さない

https://franpon.com/study/1701101

 略語はqlcらしい。ということはklcでもいいのでは
 みんなすでに使われている
　kqcかな
https://www.filemagic.com/ja/list/k/page/7/
　によると、一般的でないファイルなので、これにきめよう kqc(quelque chose)

 kqcのreadkqc関数を作った。単に全体を1つのS式として読み込むだけ。
1行ずつにするとend-of-fileがわからない・・

 kqcio.lispでito-kqcio.lispも作成した

🎂 bterm/lispを別リポジトリにしたほうがよいかどうか・・・



20200718土
* refactoring
resolutionを作る準備として、play-disag.lispのファイル名れべるのリファクタリング
play-disag.lisp ⇨ unif-disag.lisp

* disagというキーワードを入れ続けることの違和感あり

* ito-reso-disag.lisp
 デザインをはじめよう

 1) julia版のcoreみたいにするか
 2) resolve : +L x -L -> mgu / exception 
  a) (resolve core 'C1 'L1.1 'C2 'L2.1 #'unifications #'substs) ;;; ???
  b) (resolve '(x) '(1 (1.1 + P x)) '() (2 (2.1 - P a)) 'L1.1 'L2.1 #'unifications #'substs)
  c) (resolve '(x) '((+ P x)) '() ((- P a)) #'unifications #'substs) ;; left most lit removed

 3) resolution C1 x C2 with l1,l2 -> R


 4) いったんnative formに変換してresolutionするという形?

  core -> native -> resolvent -> core(clause, proof)

  julia版のdvc_resolutionをみると、引数にとるのはlid1, lid2, coreのみで、
　そこからvars、cid->lidsと求めている
　まあ、必要最低限はそこかな。それにしてもjulia版のことはすっかり忘れている。
  coreについては気持ちはわかるが、どう使っていたのかがわからないというれべる。
　うまくいくのかどうか考えながら進むしかない。

  lid -> cid
  lid -> cid -> vars
  lid -> cid -> lids 

　これの利点は何か??

 julia版は、id -> nativeをDictでやっていたと思うがhashtableでよいか。

 (make-hash-table)
 (gethash key hash)
 (setf (gethash key hash) newvalue)
 (loop for k being the hash-keys in *hhh* using (hash-value v) do ...)
 (maphash #'fn hash)
 (hash-table-count hash)

 alistやplistを使うのは、メモリ最小条件だから、どっちかな・・

★ clauseあたりのliteral数が少ないならlistのほうがよい。
★ その境界はどのあたり???



* 全体
最近、何かファイルを作ると一連のファイルをあわせて作ることになる

xxxx.lispなら
ito-xxxx.lisp
load-xxxx.lisp
perf-xxxx.lisp

ファイルxxxx.lispから自動生成できないかな

0. generate-module
1. load 
 (load "xxxx.lisp")
xxx.lispがひとつとは限らないが、それは手でなおすのか?
どこまで生成するか

2. ito-xxxx.lisp
 xxxx.lispから関数名をひろってきて ito-ffffを定義する?

3. perf-xxxx.lispはどのitoを使うかわかるか?

*とりあえずファイルを作っておき、その中身は
(format t "~%yyyy-xxxx is not yet written~%")
としておくか・・・
ファイルを作る手間だけは除ける





20200712日
learn-lisp.lisp -- for-acrosssいうのがあったのですこし調べた

20200705日
TODO20200531a: defunをdefmethodに変えてgenericにすると性能落ちるだろうか
TODO20200704   genericを使いたいので学ぶ 使えなさそうなのでやめる

・簡単なmethod定義をしてみた
　classは使っていない

;;;* (defclass be ()
;;; (myname myvalue))
;;;#<STANDARD-CLASS COMMON-LISP-USER::BE>
;;;* (defparameter *name1* (make-instance 'be))
;;;*NAME1*
;;;* (setf (slot-value *name1* 'myname) 'Jiro)
;;;JIRO
;;;* (setf (slot-value *name1* 'myvalue) 123)
;;;123
;;;* *name1*
;;;#<BE {1002CD9A73}>
;;;* (slot-value *name1* 'myname)
;;;JIRO

exp*はどうするのかとか、

どう考えてもデータはS式のほうが簡単
method dispatchが高速になるかどうか・・・

とりあえずやめておこう


20200704土
今のunifyをgeneric functionを使ったらどうなるか。
性能を比較したい。

generic function/methodを使うためには、disaptchのためのパラメタのオブジェクトで
区別できなくてはならない。ExprもExprのリストもconsでは分岐できない・・・

故にdefclassでクラスを作る必要がある
(この段階でメモリを食い過ぎるような・・・)

区別したいもの
 - atom(constant と variable) -- symbolとは違うはず
   もしかしたらconstantはsymbolでvariableはatomかも
 - number
 - string

 - expression
 - expression list
 - sigma : set or list of primitive substitution(var term)

くらいだろうか

だんだんわからなくなってきたので、中断

* load-test.lispがload-ito.lispでなくてはならないことが判明
関連する場所を修正

* commonlispのブロックコメントはやはりないみたい
　何回も探して、毎回なかった。
　とりあえず、
　:'a,.s/^/;/



20200628日
性能測定関数をいろいろかえてみた
perf.lispに関数をまとめた。
perf-disag.lispでそれを使った

10000回実行の結果
** ITO-UNIFICATIONS of 10000 times**
Evaluation took:
  0.119 seconds of real time
  0.118683 seconds of total run time (0.116848 user, 0.001835 system)
  [ Run times consist of 0.010 seconds GC time, and 0.109 seconds non-GC time. ]
  100.00% CPU
  320,912,577 processor cycles
  52,494,336 bytes consed
  

** ITO-UNIFICATIONP of 10000 times**
Evaluation took:
  0.164 seconds of real time
  0.163658 seconds of total run time (0.162857 user, 0.000801 system)
  [ Run times consist of 0.002 seconds GC time, and 0.162 seconds non-GC time. ]
  100.00% CPU
  442,854,369 processor cycles
  92,962,816 bytes consed
  

** ITO-UNIFICATIONSP of 10000 times**
Evaluation took:
  0.167 seconds of real time
  0.164944 seconds of total run time (0.148711 user, 0.016233 system)
  [ Run times consist of 0.012 seconds GC time, and 0.153 seconds non-GC time. ]
  98.80% CPU
  450,921,876 processor cycles
  58,092,976 bytes consed
  
T
* 

non-GC timeを見ると、spもpもあまり違わない。pがすこし遅い
consの数は

s-p-sp順
          s        p      sp
total   0.119  0.164   0.165
non-GC  0.109  0.162   0.153
cycles   320M   442M    450M
cons    52.5Mb 93.0Mb  58.1Mb

こうしてみると、consの数はp>spだが、cycleはspのほうが多くなっている。
処理時間については、s>p>spだが、pとspの差はそれほどない。
GCの時間をみるとp,spよりもpのほうが少ないのは偶然か?

順番を変えてp,s,spの順で実行してみた
T
* 
(performance `ito-unificationp PN)
(performance `ito-unifications PN)
(performance `ito-unificationsp PN)
** ITO-UNIFICATIONP of 10000 times**
Evaluation took:
  0.172 seconds of real time
  0.170481 seconds of total run time (0.168257 user, 0.002224 system)
  [ Run times consist of 0.005 seconds GC time, and 0.166 seconds non-GC time. ]
  98.84% CPU
  463,369,783 processor cycles
  92,961,872 bytes consed
  
NIL
* 
** ITO-UNIFICATIONS of 10000 times**
Evaluation took:
  0.113 seconds of real time
  0.112033 seconds of total run time (0.111277 user, 0.000756 system)
  [ Run times consist of 0.003 seconds GC time, and 0.110 seconds non-GC time. ]
  99.12% CPU
  303,392,274 processor cycles
  52,461,568 bytes consed
  
NIL
* 

** ITO-UNIFICATIONSP of 10000 times**
Evaluation took:
  0.130 seconds of real time
  0.129126 seconds of total run time (0.128284 user, 0.000842 system)
  [ Run times consist of 0.003 seconds GC time, and 0.127 seconds non-GC time. ]
  99.23% CPU
  349,702,717 processor cycles
  58,063,936 bytes consed
  
NIL

p-s-sp順
          s        p      sp
total   0.112  0.170   0.129
non-GC  0.110  0.166   0.127
cycles   303M   463M    350M
cons    52.5Mb 93.0Mb  58.1Mb

s-p-sp順(再掲)
          s        p      sp
total   0.119  0.164   0.165
non-GC  0.109  0.162   0.153
cycles   320M   442M    450M
cons    52.5Mb 93.0Mb  58.1Mb

totalは関係ない処理も含んでいるので比較しても仕方ない
non-GCは、spがかなりずれている。
cyclesはなぜこんなに違うのだろうか。
ランダムな要素はないので、みんな同じにならないのはなぜか??
cyclesにはGCの処理も含まれるのか?

この結果からは、
処理時間については、pもspもsより時間がかかるのと
pとspの違いは逆転もするので、なんともいえない。

一方で
consは順序によらないので、処理の特徴をとらえていると思う。

consによると、sを1としてpとspは
        s     p    sp
cons比  1   1.8  1.11

となり、p-notのmguを作るにはspのほうが軽処理になっている。




20200627土
unificationの性能測定をしよう
unificationのp,s,ps

とくにpとsの比較が必要。

spは、pのあとにp2sをやっているので、性能がでないのは当然

代入の性能も調べるべきか? unificationの中で代入しているので、分けなくてもいいような気はする。
とはいえ、代入だけの性能も調べるべきか。

play-disag.lispがいままでの中で一番完全なので、これだけ調べればよいだろうか。
disag版とそうでないやつの比較も必要。
disag版は高速にするために作り直したのだから、高速になってないといけないので、その確認。
とはいえ、非disag版が不完全なunificationになっていたら、比較の意味がない・・・

方法
1. ito-unificaitonsとito-unification-pのテスト項目を同じにして(関数をパラメタにとるように
　すべきか?)
　それぞれのitoの実行時間を計測する。
　代入のpとsでデータ構造が違っていること。

結果
実行方法
(time (dotimes (i 100)(ito-unifications)))
(time (dotimes (i 100)(ito-unificationp)))
(time (dotimes (i 100)(ito-unificationsp)))

結果
ito: unifications is snot unify
......................
Evaluation took:
  0.002 seconds of real time
  0.002100 seconds of total run time (0.001871 user, 0.000229 system)
  100.00% CPU
  5,738,598 processor cycles
  524,288 bytes consed
  
  ito: unificationp is p-not unification
......................
Evaluation took:
  0.004 seconds of real time
  0.004096 seconds of total run time (0.003722 user, 0.000374 system)
  100.00% CPU
  11,057,668 processor cycles
  917,504 bytes consed
  
  ito: unificationsp after unifications, s2p makes p-not
......................
Evaluation took:
  0.003 seconds of real time
  0.003419 seconds of total run time (0.003020 user, 0.000399 system)
  100.00% CPU
  9,301,424 processor cycles
  589,824 bytes consed
  
評価
sよりpが2倍くらいconsしていて、処理時間も二倍に近い。
spはpを高速にするために作ったものであり、結果もそれに従っている。まとめると
s > sp > p
p-notのunifierを得るには、spがよさそう。

このテストデータには偏りがあるはずなので、結果は無条件には成り立たないかも。
想定に一致するので、信じてしまいそうになるが、別の偏りのあるデータだとどうか。
次のTODO
表現の種類による性能の違い
たとえば
・insideが発生してNOになる表現ばかりのばあい
・複雑だがunifiableの表現の最後でa!=bでNOニナルバアイ。
　　おそらく、失敗する例は性能よいのではないか。最後までやらないで終われるから。
・unifyする項目がいきつもどりつして成功する場合
  これがテストを作るのも大変・・・
・引数の順番を逆にしたとき性能がどうかわるか。
　順番に代入が作られていく場合と、代入が逆流していく場合。
　*disag-unificationで、別のunificationを呼び出す場合<x:y>だったのが、disag処理で
　途中までの代入の適用で、<x*s1:y*s1>=><e1:e2>となるケース。
　? unifyのパターンがそこで変わってしまい、性能に影響するか?

🎂 このケースは、disagだからおきる。
　<x:y>でも<x:e>でもdisag pairについて、他の部分で発生したσを適用してからこの
　pairの解決が必要になる。
  <x:y>で考えると、本来変数同士の比較なので、特別な必要がないはずなのだが
　unificの中で再びunifyしなくてはならないのが根元。

　ではこのパターンは、非disagでも性能が遅くなるのか?


  












20200620土
unificationpとunificationspのテストを追加し、動作確認した
unificationspは、unificationsを呼んでいるだけだが、NOがかえってくる場合いったん介入する必要があった。しくなかった

unificaionsは、makesubsubpなどの処理を見直した。makesubsubsの真似をしただけ。

意図はもっと複雑なものを考えるべきな気がする。
・(x:y)の両方に代入がかかって、(t1:t2)になってふたたびunifyするパターンが不十分ではないか

・さらに、t1,t2の中でふたたび同じ現象がおきル場合とか・・・



20200614土日
catch-throwの仕組みを勉強して、
unify?を呼び出すところをunification?にしてcatchとし
NOをreturnしていたところを(throw 'unification? 'NO)にした

20200607日

TODO20200606: vとeがftermになる部分のテストは未。テストは作った。
　これは一番単純な場合なので、複雑なテストも必要
 014 unifics v e with m again: Ito Failed at (ITO-ALL-DISAG ITO-UNIFICS)
   Expression: (UNIFICS '(X) 'X 'W '((X F Y) (W F A)))
    Intented ((X F Y) (W F A) (Y . A))
    Evaluated: ((X F Y) (W F A) ((F Y) F A))
原因
　内側でおきる<(f y):(f a)>に何もしていない
・実装の継続
これはトップレベルが変数で、それらに対する代入の後、unifiableな例
 014 unifics v e with m again: Ito Failed at (ITO-ALL-DISAG ITO-UNIFICS)
   Expression: (UNIFICS '(X) 'X 'W '((X F Y) (W F A)))
    Intented ((X F Y) (W F A) (Y . A))
    Evaluated: ((X F Y) (W F A) ((F Y) F A))
調査
　内側でおきる<(f y):(f a)>に何もしていないのか
　これは途中経過のテストのつもりだが、このような状態がおきることはあるのか。
　この状態になるはずのm=()の意図を作ってみた。
  unificsの016,017。途中でこのような状態にならない。

　この意図は問題をおこせない・・・

  これは最初どういうunificationから始まるのか
  unificsの020はNOが意図だが、この例になった。

  unificsとmakesubsubsにtraceをかけてみると、たしかに内側のdisagをしていない

  -- makesubsubsでunifysを実行したあとのトレーす

* (unifics '(x y z w) '(h x (f z) (g x) b z) '(h (f y) w (g w)  y a) ())
  0: (MAKESUBSUBS (X Y Z W) NIL X (F Y))
  0: MAKESUBSUBS returned ((X F Y))
  0: (MAKESUBSUBS (X Y Z W) ((X F Y)) W (F Z))
  0: MAKESUBSUBS returned ((X F Y) (W F Z))
  0: (MAKESUBSUBS (X Y Z W) ((X F Y) (W F Z)) (F Y) (F Z))
    1: (MAKESUBSUBS (X Y Z W) NIL Y Z)
    1: MAKESUBSUBS returned ((Y . Z))
  0: MAKESUBSUBS returned ((X F Z) (W F Z) (Y . Z))
  0: (MAKESUBSUBS (X Y Z W) ((X F Z) (W F Z) (Y . Z)) Z B)
  0: MAKESUBSUBS returned ((X F B) (W F B) (Y . B) (Z . B))
  0: (MAKESUBSUBS (X Y Z W) ((X F B) (W F B) (Y . B) (Z . B)) B A)
  0: MAKESUBSUBS returned ((X F A) (W F A) (Y . A) (Z . A) (B . A))


(B . A)て何か??

vsにBははいっていないから、定数同士でNOニナルノデハ??

(B.A)がでてくる理由
  makesubsubsの最初atom判定していたが、これだと定数でもいってしまう。
　はisvar判定に変える必要があった。
　そしてどちらも変数でない場合はNOにする。

　だんだん処理がふえる・・・いいのか

　unifysからきたとき014と015は発生しないのだろうか。

 014 unifics v e with m again: Ito Failed at (ITO-ALL-DISAG ITO-UNIFICS)
   Expression: (UNIFICS '(X Y) 'X 'W '((X F Y) (W F A)))
    Intented ((X F Y) (W F A) (Y . A))
    Evaluated: ((X F A) (W F A) (Y . A))

 015 unifics v e with m again: Ito Failed at (ITO-ALL-DISAG ITO-UNIFICS)
   Expression: (UNIFICS '(X Y W) 'X 'W '((X F Y) (W F A)))
    Intented ((X F Y) (W F A) (Y . A))
    Evaluated: ((X F A) (W F A) (Y . A))

となっているので、(Y.a)が(F y)にsubstされるということか。
それは意図が間違っている

　意図を修正してパス。

　処理量を考え直すべき

確認)
  unificsがNOヲカエシタトキドウナルノカ?

・019 unifics 追加
　意図の目的は、2 innerだったが、NOガトチュウデハッセイスル令になっていた

　問題ないみたい。



・内側の複雑な場合


20200606土曜
まず、前回残していた意図外れをあわせよう
1) insidepを作ること
2) v:eに対して<v*m:e*m>で再びdisagreeになる件の明確化

1)をまず実装する
・insidepのトップではx:xがNILになるのでinsidepとinsidep0をわける
・makesubsubsの中でvとeのinsidepをテストしたが
 020 unifys: Ito Failed at (ITO-ALL-DISAG ITO-UNIFYS)
   Expression: (UNIFYS '(X Y) '(F X X) '(F (G Y) Y))
    Intented NO
    Evaluated: ((X G Y) ((G Y) . Y))
　となる。
変数のXに(x. (g y))を代入して(g y)になっている。変数がわがf-termになったので
こうなっているらしい。

makesubsubsの中でもう一度vとeの向きを決めるのか?
だとするとここでdisagの再実行がおきるのか・・・

・vとeがftermになる部分のテストは未でその前まですみ


20200531日
- play-disag.lispの定義順序を整理する
  snotで作ってpnotには最後にs2pで変換する
　　これの計算量もみておきたい

- ito-disag.lispも合わせて変更する

- 足りないものは何か?
  - insideは未★
  - 深いところから上にもどつたとき -- 不十分
　- 複雑なunifの意図も作ってみたが、深いところから上にもどるようになっているのか??

- 不要なものを削除した

- unifyspとunifypの名前を交換した
　unifyspがunifysしてs2pでp-notにするのでunifysp
  unifypは、fnからp-notにしているはず　★要確認

s2p, p2sをunifyより前に移動

ito.lispで意図は違うけど、今はここまでにしている、みたいなのはいらないか
たとえば、intend-notequalで、バスしても実はこの意図は違うというようなの必要か

間違った結果にならないという意図はどうか?
intenでなく、exceptみたいなものかな
(except-notequal "2+1 は3以外になってはいけない" 13 (+ 2 1))
みたいなことが書けた方がよいのかも

意図は意図なのでintendか・・・



20200530土
disag版の作成中
🕷 unifypの結果のσで、左に定数がきたりする・・・
  makesubsubsで、d2が変数のときも、d1を左にしていた

🕷 unifysで、変数リストでなく出現順にσが作られていく
　これは🕷ではない。当然そうなる。

🕷 追加意図 
  017 unifyp: Ito Failed at (ITO-ALL-DISAG ITO-UNIFYP)
   Expression: (UNIFYP '(X Y Z) '(F Z (H Y) (H (H B)))
                       '(F A (H (G X)) (H (H X))))
    Intented (B (G B) A)
    Evaluated: (X (G X) A)
　・Xへの代入が後だからか、YへのXの代入とか無視していて正解なのか???
　　s2pの問題??
  ・unifysをしてs2pで正解になる。
　　unifypをそのように修正した
　　テストok







20191217火
1. Genieのaddはできてもusingでエラーになった
　updateしてbuildしたら動くようになった


20191214土
1. testunify.jlにUnification theoryの例を追加した
   testunify.jlは動いた
2. viewprover.jlで、Genieのupdateに失敗・・・ネットにつながっていないからかも。


20191109土
1. 実装でいくつかアイデアができて、ソースも整理したくなってきた。
　いろいろアイデアがでてきて考えきれないので、すこしコードにもどりたい。

　名前がいろいろ必要

 作りたいものは、たんなるproverではなく、いろいろしたい
　たとえば、cluaseを追加してaxiomが変化するときの状態をみるとか
 

20191026土
1. prover のlimitterとして成功した回数にしよう。
　resolution以外もあるので、どう数えるか・・・
  core.proofの要素数にしてみよう

20191022火
1. cirf001.cnfで、axiomsからmalの行をけしてみた
 [d].[-Dev(d,on,black,charged),+How(d,mal)]

goalをこうして
[d,w].[+Dev(d,on,black,w)]

wにはmalfunctionがこないので、異常の原因を探しにいくことができない。

2. malになったとして、原因をどう調べるのか問題
cirf003.cnf

 1) Cause(d,cau)を導入
 2) テストに失敗した場合+FailX(x)を追加する
 3) current fact -> Mal() -> dispatch test -> Cause with fail

という流れ

全体のprover flow
1) malfunctionかどうかの証明(cirf002b.cnf)
2) テスト対象の発見
3) テスト結果(Fail=Fact)の追加により、どこでエラーになっているかがわかる
これは、テスト対象を示していない。
4) 失敗したテストをFact Fail(x)にしているのは直感と反する。というか
　テストに成功したほうをFact Test(x)と書いてもうまくつながらなかった。
　なぜ??
5)成功したほうを-Fail()とかくと無視されてうれしいが、
　相手のいない述語のリテラルが消えないという理由だけで、
　-Fail()は書かなくても無視される。(ないから)
　明示的に書いているこのと意味は?
6) 証明を作るということと、できるかぎり多くの証明から情報を集めるというのは
　目的が違う。現象の解釈も違うのでは?

[] 手順
(1) 知りたいことをgoalにして書く
　・正常・異常という概念はメタな概念であり、書かなければわからない。
(2) Factは2種類
　1) 現状の装置の状態をしめすFact
　2) テストの結果であるFact
　まず、1)のFactを含む証明から、正常か異常かを判定
　異常の場合、テスト結果をFactとして追加して、それが原因かどうかを

　いやまて、テストがFailしている段階でもうそれが原因と考えられる・・・
　FailのFactはよくない。

　テストというものがFailしたらまずいというものなので、そうなってしまうのか・・・

　ちょっと考えていたことがずれていた。






　


3. いくつかの問題
1) cirf002d.cnfで、conjをC and Dにしてみたが、終わらなくなった
2) 




20191021月
回路は、QAの例になっている。
そこでは質問が必要になる。

1. cirf001.cnf
　何を質問すべきか?
　何を尋ねることができるか。

1.1
　まず、この装置が正常か異常かを問うてみよう。
　となると正常か異常かを表す述語が必要になる。それをHow(how)とする。
　Dev(d,sw,lamp)は装置の状態を示す。

　cirf001.cnfは、axiomsで、ground levelでgoodかmalかを書いている。

　正常・異常というのは、具体的な装置の構造の性質ではない。
　装置を観測するとは、装置の違いを示せる部分についての解釈が状態と呼ばれるもので、
　その状態を述語化したものが観測。

　と考えると・・・

　swとlampは装置の状態を示す2つの部分。
　swをonにしたらlampがwhiteになるとかいう因果関係はありそうだが
　ここではそれは考慮しない。状態にのみ着目する。

1.1.2 正常異常以外に問うことのできる状態は何があるだろうか。
1.1.3 もうすこしhop数を増やしてみたい。
1.1.4 たとえば、故障したとき、その原因をどう調べればよいか。

1.2 cirf002.cnfはバッテリーもふくめたもの
1.2.1 この例では、axiomに変数anyを含め、sw=offのときは、batteryがchargedでもemptyでも
　　　lamp=blackになることを書いた。それはうまく働いて[]がでている。


2. ちなみに、この場合、知識をclause集合K, 質問をQ、回答をAとすると、Aは

　　A = Kσ、A <= Qτ

　　になる。つまり、答えは質問のインスタンスになる。
　　もちろん、Kのどれかのインスタンスでもなくてはならない。

3. 状態を定義する。解釈を定義する。状態についての質問を作る。ということなのか?
3. 状態を定義する。解釈を定義する。状態についての質問を作る。ということなのか?
3. 状態を定義する。解釈を定義する。状態についての質問を作る。ということなのか?



20191019土
1. DVC proverが間違っていないような気がしてきたので、それを前提とすると
　どのようにproverを作らなくてはならないかを考え始めている。
  about_prover.txtで書き始め

2. 回路の例を考えていくと、どう書くかもはっきりしないが、その理由は
　何を書きたいかがはっきりしていないからと思えてきた。

　何を書いて、何がわかるのかを考えている。what_problem_to.txt書き始めた。


20191013 日
1. cire002.cnfで lamp=black, sw=off, bat=charged をやってみた。
　証明できているが、よくわからない。
  printproofs1()で証明の詳細、printmgu()で個別のproofのσをみられるようにした。

2.cire003.cnf
 1) Dとdはいらないので消した
 2) resolventの数も増えてきたのでprintmgusにしろprintproofsにしろみにくいから
　  printcontradictions()を作って[]の証明の深さ(depth)をprintするようにしてみたが
　　全部10になって、区別がつかない。

    printdepth(cid, core)はdepthを表示する。追加した。
    printの最後に[]の数を表示するようにした


20191012 土
1. 回路を全部書いてみた cire001.cnf
　部品とその状態をわけて書かなくてはならないのだが
　うまく書けていないと思う

2. 今の書き方だと、部品はその全状態に等しいと考えている。
部品完動と電流の流れの部分をこんなふうに書いている。

[a,B,b].[-WorkB(a,B,b),+Curr(a,charged,b)]
[a,B,b].[-WorkB(a,B,b),-Curr(a,empty,b)]
[a,B,b].[+WorkB(a,B,b),-Curr(a,B,b)]

そして電流の流れについてこんなふうに書いているから

[d,x,y,z].[-Curr(1,x,2),-Curr(2,y,3),-Curr(3,z,1),+Curr(d,x,y,z)]

混乱している。

部品とその状態をどう関連付けるか。

P(.., p, s, ...)

と書いてみたが、たとえば回路の部品の順番が固定されてしまう。
# I want to write as this, but no Curr but CurrX
#[d,p1,p2,p3,x,y,z].[-Curr(1,p1,x,2),-Curr(2,p2,y,3),-Curr(3,p3,z,1),+CurrD(d,x,y,z)]
[d,p1,p2,p3,x,y,z].[-CurrL(1,p1,x,2),-CurrS(2,p2,y,3),-CurrB(3,p3,z,1),+CurrD(d,light,y,z)]

たぶん、CurrXとCurrがunifyできなくてはならないのかも。単に述語記号からXを消すだけなら
[L].[-Curr(L,1,x,2)...]
とか書けばよいが、このLは定数になるので、
[d,x,y,z].[-Curr(1,L,x,2),-Curr(2,S,y,3),-Curr(3,B,z,1),+CurrD(d,L,light,y,z)]

かな

そうなるとWorkXも同じように描きたくなる。

そもそもneg側のx,y,zには何がはいるのだろうか。
そこは部品だから、pos側のy,zが状態なので型のミスマッチになる。

柔軟さと情報の完全性がうまく書けない。

部品と状態と型をわけるのか?

SW, sw, {on,off}
swはスイッチの名前
SWは部品の名前('スイッチ')

+Work(SW,sw) 
+Curr(p1,SW,sw,p2)

回路の点はp1,p2 定数
この文脈では定数でいいのか。

Curr自体はどこでも成り立つので変数を使う
Curr(x,P,y)
部品Pがxとyをつないでいて、電流が流れる。

直流の+と-はどうなるのか??

3. 再検討

部品の名前と、その状態を(D,d)とかければいいが、
今のProverでは書けないので、述語の引数として D,d,と書くことにする。

Work(p1,D,p2)
p1,p2は位置の定数でなく、変数であってほしい。
しかし、そこに電位差があり、電流が流れる状態でないとDがWorkかどうかわからない。
Dは特定の部品の名前であり、ここでは状態については述べない。
Dが動作しているかどうかの判定に、電流が流れるp1,p2が必要なのでp1,p2を含めている。


Curr(p1,D,d,p2)
Currは電流が流れることを言っているので、p1,p2は具体的な回路の位置を示す。
だから、定数で表されるだろう。
回路の点は、その回路における点なので定数になる。
Dは部品名でdは状態。
だとすると、Currは電流が流れることだけでなく、そのときの部品の状態も書いている。
分けよう。

たとえば、
[p1,p2,D].[-Work(p1,D,p2),+Curr(p1,p2)]
か。

これはp1とp2の間にDを置くとDが機能するならば、p1,p2の間に電流が流れている
ということ。

[L,S,B].[-Conn(p1,p2,L),-Conn(p2,p3,S),-Conn(p3,p1,B),
 +Curr(p1,p2),+Dev(L,white,S,on,B,b)]

は、p1とp2の間にLampがあって、p1とp2に電流が流れていれば
その装置の状態は、L=white, S=on, B=b になると言っている

Devは、装置全体としての状態の記述。
装置の名前Dがなくても大丈夫か??

回路の構造を
[L].[+WorkL(p1,L,p2)]
[B].[+WorkB(p2,B,p3)]
[S].[+WorkS(p3,S,p1)]

と書くとConnとの対応が必要になるが、それは必要か?

WorkXは位置は関係ない。
しかし、任意の位置について確認したわけではないFact。

これで書いてみた

cire001.cnf
goal: [].[-Dev(L,white,S,on,B,b)]

[]は3つできている。
詳しくみなくてはならない。


☆ 同じFactは繰り返し使われない

4. 同値をそのまま書くと、空代入のループができてしまう。
　そこの対処もいずれ必要かも。
　goalによって方向がはいるので、ループが回らなければいいのかも。
　あるいは、先日考えたように、空代入はスキップ可能と考えるとか。壁になるやも。
 

20191006 日
1. つづき
  proverがおかしいのかもしれない

2. もっと単純にした場合、sw=onでlampはつき、(cird001.cnf)
  sw=offで lamp=blackになった。(cird002.cnf)
　Workは部品ごとに違う名前にする
　変数にしていないものがあった。これはこれまでもよくあった。
  変数にしないからunfiyできない。

3. 待てないくらいに終わらないのは、🕷かもしれない。
  他にも、いろいろ不安。

4. +Dev(dev,d,lamp,l,sw,s,bat,b)のように書いたらどうだろうか。
　中身を全部書くのはおかしいけれど、


201910015 土
1. 回路cirb001 機能と構造をわけたものの見方について検討中
2. なぜか1回、resolutionに失敗してそこから先にすすまない。
　resolventがでないとてがかりがない

20190929日
1. view prover(vcirc004.cnf)では1つしか[]をみつけられないということに気づいた
　cnfでは、複数の可能性について書いているのに、1つしかみつけられない。

　ここは、cheaplogicdata/circ004.cnfで全部みつけるほうがよいような(状況によるか)
　気がするので、やってみた

2. DCについての期待(DC2,DC3,DC4,DC5)を書いた。
　　Factはgoalのみ
   *発見
　まず、DC2->DC3でemptyのパスだけのときは意図どおり、emptyをみつけた
　次に、DC4を追加すると、emptyとcutの両方がみつかる。
　DC5まで追加しても同じ。

　そこで、テスト結果として、connのFactを追加した。DC5でconn
　これをすると、[]{conn}が追加されただけだった。

　つまり、テスト結果として特別扱いされていない。

　テスト結果は、期待とは違う扱いがなされなくてはならないということか。

　たぶん、テスト結果のFactは生成される[]で必ず使われなくてはならないのではないか?

　だとすると、Goalと同じ類のclauseということになる。

　つまり、Goalは1つではなく、Goal setとして与えられ、Goal setのclauseは
　proofにすべて含まれなくてはならない。
　というような仕組みが必要ではないか。

　もうすこし、実例を手で計算してみよう。

　ExpectとFactの違いはここではないだろうか・・・


3. canoを使うよりKeywordのほうが、見やすいような気がしてきた。


20190928土
1. やることを整理
   参照:todo20190928.txt

2. 回路を見直したら、記述のレベルがあって、レベルからレベル
　　への遷移がおきるような仕組みがよさそう circ004.cnfで試し書き
   未完

3. stepでevalのときどの述語でevalしたのかわかるとよい。

4. evaluateの中でisProc()でないときなぜかgroundかどうか判定していたが
　groundであるだけでliteralを消してはいけないだろう。
　その部分のコードをコメントアウトした。
  viewreso.jlの94-97
　何か問題がおきるだろうか?
　あとproofの関連性がわからなくったような・・・

5 .load_cheaplogic.jlの順番が間違っていた
   primitive.jlとcommon.jlが逆


20190921土
1. 制御をもっとクリアにできないか。
   20190906にもやろうとしたが、できている気がしない。　


20190908日
1. ソースを読み直していると、lsymof()のような関数はprimitives.jlに
　あればよいと思うが、なんとかreso.jlに定義されていたりする。
　違う概念に同じ名前がついていたり・・・refactoringをした。
　lsymが、literal symbolという意味とlogical symbol(in parser.jl)
という意味で使われていた。
　それで整理した。

  test_*.jlは一通り確認した。


20190907土
1. argsof()を追加
　Exprでリテラルとtermを表現しているために、この二種類を区別できない。
　しいていえば+/-の有無が違うが、それをみてliteralかf-termかを判定するような
　ことは書きたくない。不要な計算がはいるから。
  tag をつければよいけれど、それはそれで単純でなくなる。

2.　単純というのが、何についての単純なのかははっきりさせなくてはならない。
　それが違うと話がかみあわなくなる。

3. dvc_reso.jlとkp_reso.jlに同じ関数が定義されていた。
　この二つが同時に動くことはなく、kp_reso.jlは、もう使うことなどない
だろうと思ってきたが、いちおう整理することにした。
　View proverでQAシステムを作るとき、kpがあるとよいような気もする。
　でも、機能的にはdvcと変わらないので、何かしたいという気にはなれない。


20190906金
1. vlogic.jlのソースを見直した
どうもgoalproverの処理が混線していると感じる。

2. half 🕷 goresolve()でくるはずのないところでceaseview()を呼んでいるような気がする。
きたらわかるように@warnをいれておく

3. 🎂 goal::list(lid) の各lidについて
 - oppositがあるかどうか
 - canoがあるか
 - Procかどうか

を判定したい

3.1. その前に、Exprに関するprimitiveを作った。
　signof(::Expr)とかlsymof(::Expr)みたいなもの。
  e.args[1]とか書きたくない。
　ひとそろい作ろうか・・・

3.2 Exprは、LiteralだったりAtomだったりtermのリストだったりする
clause2of()::CForm2
CForm2=(cid, vars, body)のbodyはExprのArray

literalof()::LForm2
 LForm2=(lid, body)
 bodyはExprのArray


20190901日
新しいcirc004.cnfを試してみた。内容はabout_circuit.txt

正常な場合、cw=on & lamp=lightのときはすぐに[]になるので
異常ではないことがわかる。

sw=on, lamp=blackだと質問してくる
pow=charged, wire=discで[]になる


🕷 printmgu(:R1, core, true)で
julia> printmgu(:R5,core,false)

R1:<L3:L3>=x/black;y/on;ERROR: BoundsError: attempt to access 4-element Array{Symbol,1} at index [5]
Stacktrace:
 [1] getindex at ./array.jl:728 [inlined]
 [2] printmgu0(::Array{Symbol,1}, ::Array{Symbol,1}, ::Bool) at /Users/shin/Projects/github/cheaplogic/Prover/coreprint.jl:214
 [3] printmgu(::Symbol, ::CORE, ::Bool) at /Users/shin/Projects/github/cheaplogic/Prover/coreprint.jl:232
 [4] printmgu(::Symbol, ::CORE, ::Bool) at /Users/shin/Projects/github/cheaplogic/Prover/coreprint.jl:225 (repeats 4 times)
 [5] top-level scope at REPL[35]:1

になる。
debuggerでみると
printmgu0の中で

1] sigma: Symbol[:black, :on, :z_C1, :w_C1]
3] ovars: Symbol[:x_C1, :y_C1, :z_C1, :w_C1, :x_C1, :y_C1, :z_C1, :w_C1]

長さが違うので、overrunしている。

単にくっつけたな。

printmgu()でprintmgu0()を呼ぶときこの変数リストをovarsof()で作っているが
leftとrightのovarsをくっつけているのが敗因。
step.ruleが:evalと:viewのときはleftだけにする
解決



昨日考えたことをまとめた。
about_circuit.txt

cnfの中身をgoalを除いてdescriptionと呼ぼうかと思う。
前はaxiomsと呼んでいたような事柄。

descriptionのclauseはいまのところ次の3つに分かれる。
もっとあるかもしれない。

1. Fact

2. Premise

3. Unconfermed


20190831土
今日は成果なし

eval-view-reso(EVR)の制御を明確にしようと考えた。
まず、viewといっているものは全部、いわゆるDialogで、画面にメッセージを出して
すぐに帰ってくるものだけ。

だから、そのループが単独の関数としてかければよい。

1つのtargetでWebループをまわしたとして、Webのデータの制御とEVRのループの
間で同期をとる必要があるように思える。

たとえばwebの最初のtargetまで制御がいくと、そこでWebはrequestがくるのを
待ち続ける。
そこで表示すべきhtmlをEVRで作ると、それが表示されるような制御になると考えている。

結局、webの制御と平行した動作を書くことになる。
Genieのappの仕組みが使えないかみてみたが、途中でgiveup。

きれいな表現がないものか。

きれいな表現にするということは、そのしたのレイヤーに複雑なことをまかせる
ということになるが、そこはそこできれいになっていないといけない。

今日は何も進展がない(12:30)


20190825日
昨日のつづき

R2でcan't progressになる
1. can't progressの理由は??
  glidのopponentがないため。
　templateができていない。

  goreadcore()でalltemplateof()をしていなかったためにlevel0ができていなかった。

　修正した。templateはできたが、can't progressはかわらず。なぜか?

  KCは+も-もあるので問題ないと思うがどうしてか
  ↓が先か

2. R2の変数にblackとonが代入されていない。R1にはあるので、resolventの作り方がおかしい
　きのうはできていたような気もする。昨日の修正の影響か??
  L2_R1をresolveすると、blackとonが消える。

  addnewclauseのσに値を設定してみているが、間違っているかも。
　一度、全体を見直す。

  -VSW(on)というのができているが、これはgroundなので消せばいいようなきがする。
　つまり、cannoでgroundだったら消して良い。
  これはviewの前にやりたいので、evalの中でよい。

　条件の時、literalを消して新しいgoalを作りたいのでevalでやるとめんどう。
  似たような処理はviewでやっているから、viewでやりたい。

　choosecanoidでは、isCano()判定しているのでisgroundをみればいいような気も
　するが、それでidを残していっても消すときがいつかくる。

  VSW()とVLAMP()はいらないけど、どういうふうにはずすか?

  とりあえず-VSW()と-VLAMP()をはずしたが同じ。

　もしかして-ではなく+限定か?

　たぶん単純な間違いのような気がしてきた。cnfの間違いの可能性もある。

  [+DC(),-KC()]にしてみたが同じ。

R2:[z_C7R2,w_C7R2]. L6_R2.-(KC(black, off, z_C7R2, w_C7R2))
ができていて
C3:[]. L7.+(KC(black, off, charged, conn))
があるのに
ceaseview()にくるのはなぜか??

R2ができたあと、なぜかそのままceaseview()にながれている

goresolve()でresolvelid()のあとgidがかえってきたら
contraかceaseのどちらかになってしまうが、
resolutionが成功すればgidがかえってくるのでこの制御は
おかしい

 resolventができたときの処理が抜けていた。

 作ったら通った。

3. [x,y,z,w].[+DC(x,y,z,w),-VPOW(z),-VWIRE(w),-KC(x,y,z,w)]
のように書くと、POWとWIREのVIEWが両方聞かれる。
たしかにそうかもしれないが、POW(emtpy)ならそれでlamp(black)ではある・・・
原因をすべて確認するというやりかただと言えば、論理的でよい。

同様に、sw=on & lamp=lightでも聞いてくる。

ここらへんはcnfの書き方の問題なので、プログラムは一旦完成とする。


20190824土
1. 回路問題のcnfを書いてみている(docs/about_circuit.txt)
 はっきりと書き方がわからない
　resoでresolventの変数がひとつもなくなっている。
  ?) R1からR2にいくとき別の変数が同じになっているような
  vdata/vcirc003.cnv
proof
R1:<L3:L3>=[black,on,z_C1,w_C1] by view
R2:<L2_R1:L4>=[z_C6,w_C6,black,on,z_C6,w_C6] by reso

julia> varsof(:R1,core)
2-element Array{Symbol,1}:
 :z_C1R1
 :w_C1R1

julia> lvarsof(:L4,core)
4-element Array{Symbol,1}:
 :x_C6
 :y_C6
 :z_C6
 :w_C6

julia> stringclause(:R1,core)
"R1:[z_C1R1,w_C1R1].[L2_R1:-(DC(black,on,z_C1R1,w_C1R1))]"
と
julia> stringclause(:C6,core)
"C6:[x_C6,y_C6,z_C6,w_C6].[L4:+(DC(x_C6,y_C6,z_C6,w_C6)),L5:-(VSW(y_C6)),L6:-(VPOW(z_C6)),L7:-(VWIRE(w_C6)),L8:-(KC(x_C6,y_C6,z_C6,w_C6))]"

から

julia> stringclause(:R2,core)
"R2:[].[L5_R2:-(VSW(y_C6)),L6_R2:-(VPOW(z_C6)),L7_R2:-(VWIRE(w_C6)),L8_R2:-(KC(x_C6,y_C6,z_C6,w_C6))]"

R2のvarsが[]なのはなぜか?

[ Info: (:addnewclause, Symbol[:z_C1R1, :w_C1R1, :x_C6, :y_C6, :z_C6, :w_C6], :R1, Any[:L5, :L6, :L7, :L8], Any[])

🎂 fitting_varsでresolutionの結果の変数がひたすら減っていくだけだ。
   変数名のつけかえのあとにfittingをしているのだろうか??

☕️ addstepのrenameσは右と左のσの[-,-]でなくてはならないのに、view proverのreso ではaddstepでそうしていなかった。







20190819月
1. 問題をどう書くか、どう問えるかを考える
  1) 簡単な電気回路(スイッチ、電源、ランプ)を考えて、
     スイッチを入れてもランプがつかない理由を答える。
　　　data/circ001.cnf
　2) どう書くか。関係に着目してFactを書く。
　3) Queryは-P,+Qではなく-P,-Qのパターン(2つのclauseに分かれると、関連がわからなくなる)
  4) 断線の可能性も考慮した版: data/circ002.cnf
  5) Queryの書き方をもうすこし考えるべき


20190818日
1. test_*.jlを確認する
 1) 🕷 test_kplogic.jl でCOREの再定義がおきた。
　　　　COREの定義にいろいろ追加していたからだろう。
    ☕️ kpcore.jlのCOREの定義が古いようだったので、コメントアウトしてみた
       でtest_kplogicは正常にとおった

 2) test_naivelogic.jlは
        kpcore.jlの意味は忘れたが、なぜこのような定義が必要なのか?

###
(vars, t1, t2, σ) = (Any[], :(P()), :(Q()), Any[])
(vars, t1, t2, σ) = (Symbol[:x], :(()), :(()), Symbol[:x])
naiveunify: Error During Test at /Users/shin/Projects/github/cheaplogic/Prover/test_naiveunify.jl:28
  Test threw exception
  Expression: unify([:x], $(Expr(:quote, :(()))), $(Expr(:quote, :(())))) == [:x]
  BoundsError: attempt to access 0-element Array{Any,1} at index [1]
  Stacktrace:
   [1] getindex at ./array.jl:729 [inlined]
   [2] unify1(::Array{Symbol,1}, ::Expr, ::Expr, ::Array{Symbol,1}) at /Users/shin/Projects/github/cheaplogic/Prover/naiveunify.jl:47
   [3] unify(::Array{Symbol,1}, ::Expr, ::Expr) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:302
   [4] top-level scope at /Users/shin/Projects/github/cheaplogic/Prover/test_naiveunify.jl:28
   [5] top-level scope at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083
   [6] top-level scope at /Users/shin/Projects/github/cheaplogic/Prover/test_naiveunify.jl:26
###

   ☕️ unify1(v,t1,t2,σ)の冒頭でt1==t2のとき↑σとした。unify()から呼ぶときはt1==t2のときunify1にこないのだが
　　　ほかのパスがあるらしい
🎂 printcore()よりもprint(stringcore(core))のほうが、cidの順番がみやすい。
   print(stringclause(core))もよいがCanoがみえない。

2. C24 in vev002.cnf, で、ループにおちいっていた。
   C24のリテラルはCanoがなく、resolveだが、opposがない。 
   resolvelid()でnothingをかえすようにしていたが、呼び出し側でloopするviewをつくっていた。
　 failview()をだすようにして解決

　 ただし、failview()の定義をみると、:Failのときに出すviewらしい。
　 can't progressなので同じものを使ったがだめかも
   
3.🕷 C21 in vev002.cnfでViewの値を2つ指定しても、resolventにリテラルが残っている
　そこでconfirmするとき消えるらしい

  - isground(glit)をしていたが、このglitはσoをかけていなかったので変数があり、消されなくなる。
　　factifyはσgをもってきていて、σoでなくσgをかけてground化し、解決
    ☕️動作確認(V[8,6]でR1から-P4()が消えることを確認)

  - V[7,6]とすると-Q(6)ができる。resoで相手をさがすとまず+Q(5)がみつかるがこれではFailになり
　　そこであきらめてしまうのでFail can't progressになる。

　　failになったら他の選択肢をさがすべき。opposがあるかぎり頑張る

    resolvelid()の中のopposのloopで、unify()からICMPがかえってきたらcontinueをするようにした。

    ☕️ 動作確認(V[8,6]で-Q4(6)で[]になることを確認)



4. メモ
　↑X を書いてみたかった

  macro ↑(v)
   return :(return $v)
  end

　としたら

  function a(x)
    if x == 3; @↑8 end
    @↑ 19
  end
  として
  julia> a(3)
  8
  julia> a(23)
  19

とは書けた。





　  
20190817土
1. maxでなく、そのリテラルの前のwhendoit+1にしてみた
今の例では,partialもabortもうごく

結局、サイクリックにまわすことになる

同じwhendoitの中から、ランダムに選ぶようにしても、根拠がないので
今のままにするしかないか・・・

2. よくみると、V40_R1[8,y]にすると、L41_R11[y,z]になってしまう

355  σo = getσo(varc, varg, pm)
357  σo = apply(varc, σo, gvar)
のところでgvarがclauseのvarsになっていて、長さがvarcと違う。
varcはcano(unitclause)のvarsなのでliteralの変数の数だが
gvarはちがう

たぶんgatmの引数部分だけをもってくるべき

357  σo = apply(varc, σo, gatm.args[2:end])
とした。

3.Viewで入力すると、そのインスタンスが一回残っていて、confirmさせられる。
　これでいいのか 🎂

4. 今はViewでCanoリテラルをすべて消去したあとResoに進む
   少なくとも1つViewを解決したらResoに進めばよいような気もするが
　順番はいるのはよくないような気がする
　今のままがよいか



20190816金
1. viewでabortやpartialのとき、次は別のリテラルを選ぶようにしたい
2. しかし、他に選択肢がないときはよい
3. goalの各リテラルについてtouch valueをつける。
　　基本は0。partialやabortやFailしたときはgoalのそのliteralのtouch valueを増やす。
　　0でないものだけ管理すればよい。Dictで。
　　次に対象とするliteralを選ぶとき、touch valueの一番小さいものから選ぶ。

4. まず現状を調べる
 1) V+Rがないので、C21で作る
 2) まちがえて-P4,-R4と-R4(5),-R4(6)とやったが[]になった
    CanoのP4について -P4()と+P4()-R4()という定義にしたためで、-R4にいっていなかった。
　　-R4()と相手のいない場合の例を作った
🕷 3) V[6,-] => viewlogic.jl:324でException varc,σo,varg = [W,Z],[8,Z],[y]
    [W,Z]なのに[y]が1つしかないから。
 4) V[-,5] => これもループ。V[5,5]で[]。
 5) V[-,9] => これもループ。V[5,9]と入力するとcan't progress.
 6) abortするとずっと同じリテラルでループする

5. choosecanoid()を修正した
global DIL = Dict()
global maxdil = 0
を追加した。
関数を追加した
doitlater(glid) glidのカウントを設定する
doitlater(glid, wdi) glidのカウントをwdi+1にする。
どちらもmaxdilを最大値にする

whendoit(gid) gidのカウントを参照する

abortのときは、glidのカウントをupする。
partialのときは、glidとridから新しいglidをもとめ、前のglidのカウント+1にする

choosecanoid()では、lidsをsortするときby=whendoitを指定する。


6. chooseresolveid()を修正する



8. stringclause()でRがCの中にまじっていた。ltid()をRとCを区別するように修正した


20190812月
週末は、小説の整理をしていた。

🎂証明の進展ではなく、proving attemptsについて変化を調べなくてはならない。

証明とmguは対応するけれども、<L:R>がfailしたという情報は、proving attemptsが進んだ
ということを意味するのであり、存在しないmguを見ているだけではわからない。

input literalsのすべての組み合わせ以外に証明で使われるpairはない
(axiomsが変化しない場合)
だから、Lpairsを列挙すると、証明の全体像がみえるはず。
命題とそれに制約をつけた述語。

proving attempts=Lpairsの並びあるいはLpairsの木がprovingの進展状況を示している。


🎂 NTPのワードベクトルのように、input literalでベクトルを作ってうれしいことがないか??
どのようなベクトルを作れば良いか
literalには変数を含むものがあるが、
何で区別するのか

述語記号
リテラル記号
input リテラル

たとえばclauseが似ているということを定義できるか?

literalは述語記号と符号が一致していれば似ているのか

全input literalのベクトルというのが素朴な考えとしてありそう。

変数はどうするか?

cheaplogicの最初の頃に作ったproverもどきは似ているかも







20190809金
viewでかえりのとき、isgroundでなけれぱliteralを消さないようにした。
1. 一部の値を入れてgoalは変化した。🎂
2. 次も同じリテラルのviewになり、🕷
3. 値の決まっていないところはcano変数がでていた。🕷
4. そのcanoViewの値のはいっていなかったところに55を代入したら
2019-08-09 19:24:59:ERROR:Main: ICMP(:Y, 55, :unify0sn)
　となった。変数リストがうまくいっていない。
 vargは[]。
5. view後の新goal(R1のL50のvarsが[]になっている

[ Info: noabort
┌ Info: after_apply
└   (catm2, varc, catm, σo) = (:(P(22, Y)), Any[:X, :Y], :(P(X, Y)), Any[22, :Y])
┌ Info: after_unify
└   (σg, varg, gatm, catm2) = (Any[22, :Y], Symbol[:x_C3, :y_C3], :(P(x_C3, y_C3)), :(P(22, Y)))
[ Info: (:factify_clause, :L50, Any[22, :Y])

applyはいいみたいだが、Yをy_C3に変える代入がない
🎂σgをつくる前にσoにvarc.<catm:gatm>をかけておく

うまくいった





* 直接いけるか? 
 http://localhost:8000/go?op=readcore&corepath=vdata%2Fvev002.cnf
 いけるみたい。

20190730火
vlogicのソースの整理ができた

アルゴリズムの見直しが必要


20190803土
1. viewの制御を見直した。
1.1. viewでliteralを消していいのはViewのもどりがgroundになっているとき
1.2. giveup条件がいくつかある。そこでもgroundが条件になる
1.3. viewで入力しつくしたあとにresoをするようにしたい
1.3.1 ∵ resoでバックトラックが発生したときviewにまで戻れない
1.3.2 バックトラックなのか、総当たりなのかはまだ未定

2. isground()を作成した。with tests

3. viewlogic.jlとviewreso.jlにコメント追加。特に関数のコメント
重要な修正はまだ。

4. stringcore()でclauseの表示順を数字にあわせた。つまり
  今はC12のあとにC2がくるのをC2のあとにC12がくるようにした。
　桁数の少ないものを前にした


20190721日
1. 見てみるとおかしな点はすぐにわかった。修正する(20分)
2. vev002.cnfで確認する

🎂 ViewでだめなときにValidでうまくいったときContradictionはおかしいので
　　UIとしては「証明不可能」とか「証明済」といったメッセージがよいはず。
　　そうなるとHorn clause的な表現がよいことになる。まあそうか。

🕷 vev002/C12 x=8,y=1
[ Info: postview
[ Info: postview
[ Info: postview
2019-07-21 09:19:40:ERROR:Main: type Char has no field lcmap
2019-07-21 09:19:40:ERROR:Main: /go?op=postview&X=8&Y=1&how=confirm 500

2019-07-21 09:19:40:CRITICAL:Main: type Char has no field lcmap
getproperty(::Any, ::Symbol) at ./sysimg.jl:18
cidof(::Nothing, ::Char) at /Users/shin/Projects/github/cheaplogic/Prover/newcore.jl:227
lvarsof(::Nothing, ::Char) at /Users/shin/Projects/github/cheaplogic/Prover/newcore.jl:205
postview(::Dict{Symbol,Any}) at /Users/shin/Projects/github/cheaplogic/Prover/vlogic/viewlogic.jl:322
(::getfield(Main, Symbol("##79#80")))() at /Users/shin/Projects/github/cheaplogic/Prover/vlogic/viewlogic.jl:78

☕️ resolvelid()の中でcatchしていたunifyのfail
　　だがresolvelid()はgidとcoreを返すもので、failからfailview()::htmlが
　　かえってきてもタイプミスマッチになっていた。
    resolvelid()を読んでいる側でcatchするようにした。

🕷 C18のビューがおかしい。

GLID: L31_R1のビューで
{X=x_C14, Y=y_C14}
になり、値を入れてconfirmすると

2019-07-21 10:08:45:ERROR:Main: ICMP(:x_C14, 8, :unify0sn)
2019-07-21 10:08:45:ERROR:Main: /go?op=postview&X=8&Y=2&how=confirm 500

2019-07-21 10:08:45:CRITICAL:Main: ICMP(:x_C14, 8, :unify0sn)
unify0(::Array{Symbol,1}, ::Symbol, ::Int64) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:34
unify0(::Array{Symbol,1}, ::Expr, ::Expr) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:67
unify1(::Array{Symbol,1}, ::Expr, ::Expr, ::Array{Symbol,1}) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:215
unify(::Array{Symbol,1}, ::Expr, ::Expr) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:302

🎂 x_C14とかが変数になっていないのではないか






20190720土
1. addnewclauseなどの関数をみなおす
2. addstepを各ruleについて作る(引数違うからできるのでは)
3. 夜中にaddnewclause, addstepで全部書き換えたが、ちゃんと動かない
　細部は明日にする


20190714日
1. 処理を見直す
2. 不要なコードをコメントアウト
🕷 昨日の修正でViewのabortすると、次に他の処理に移らない。
   あるliteralのViewでabortしたら、次はviewでもresoでも別のliteralにしてほしい
　 おなじliteralのresoに進む道もあるかも　要考
🕷 項目に値を入れずにconfirmした場合どうなるべきか
　　1) 今は、その値は無視してliteralが消える。それでいいような気もするが
　　2) 値がないのに消えていいのか?
　　　　- 人間がその値を指定しなかったのは、いずれ決まると考えているからか
　　　　- かといって、その項目を理由にview literalを消さないと、すでに入力した
　　　　　値が無駄になる。その場合は、literalを消さずに残すということになると
　　　　　abortと同じ問題がある
🕷 askUのあとのpostview->factify_clause()の中でevaluate_literals()を繰り返して
　　いるがこれのproofを作っていない
🎂 factify_clause()の367行以降はどこかでもやっていた
　addnewclause()かな
🕸 


20190713土

1. about_viewprover.txt <- howto_viewlogic.txt
  viewproverの概要説明とvev002.cnfのclauseの概要

2. viewで失敗して次のviewにいくかresolveに進むかするような制御を考えようとしたが
　自分の意図が不明確だった
  ViewはFactを作るわけではないので、askU()をすると必ずliteralが消えてしまう。
　C10でP-viewにx,y=10,100などといれると、結果goalはvalidになる。

  ということはViewで中断した場合、literalを消す操作自体をやめなくてはならない。

  askU()が作るhtml(in goalprover():viewlogic.jl)で cancelをしたとき
  たどりつくtargetで、goalprover()のchoosecanoid()を再度実行して
　次のcanoidをみつけられるとよい。
　choosecanoid()をclosureにするか、どこまで確認したかのindexを持つか。
　indexは、resolveに進んだときはresetする。

　ややこしすぎ
　たんにおわればよい

  askUで次のtargetはpostviewになっているが、そこでcancelしたときの
　処理をすればい。

　cancelは、今は入力をなしにすることになっている。
　abortみたいなのが必要かも。
🎂🎂🎂 inputタグのtypeにabortはないか? value??

　makeView2()にabortボタンを追加した。

<input type=\"submit\" name=\"how\" value=\"confirm\"></br>
<input type=\"submit\" name=\"how\" value=\"abort\"></br>

 name属性は、サーバにname=>valueを送信する。

 postview(pm)で、このpm[:how] == "abort"のとき
　goalを変更せずに次のステップに進むようにした。
 htmlは前のをコピーしただけ。

🕷 C12でViewをabortしたら同じ画面にもどった。
　resolveにすすむ予定。
　全体制御を誤解しているかも
🕷 入力に空があったらabortとみなすようにする



  


*** Genieがabandanされた場合にどうするか。
 a) Genieのrepositoryをとっておく
 b) route("/go") とGenie.AppServer.startup()だけ作り直す。
    他のhttpサーバを使って、作れるか???
 c) Genieのかわりのものを作る(bは一部だけ)


20190707日
🎂@showを@infoに変更
🎂ValidのときExceptionににならないようにした
　Validの扱いはこれでいいのだろうか???
🎂-P(x,y)->View->+S(x,y) -> ge(x,y) で[]が出るようなgoalを追加したが
proofはそうなっていないようだ

C15:[].[L28:+(S2(1,2))]
C16:[x_C16,y_C16].[L29:-(P2(x_C16,y_C16))]
C17:[x_C17,y_C17].[L15:+(P2(x_C17,y_C17)),L16:-(S2(x_C17,y_C17))]
C18:[x_C18,y_C18].[L40:+(S2(x_C18,y_C18)),L41:-(ge(x_C18,y_C18))]

P2のcanoを作った

このとき
P2Viewでx,y=1,2の場合はC15で[]
x,y=100,20のときはC17で[-S2(100,20)]になり
C18で[-ge(100,20)]となり
evaluateしてfalseなのでリテラルが消えて[]になる

resolventはできるが、proofができないのはViewだからだろうか。


20190706土
しばらく進展がなかった。resolutionをどうするかでなやんでいたので。

🎂evaluate, view, resolveの処理はいちおう作った。
まったく賢くない。

🎂制御の変更
　1. evaluateは、評価できるものすべてを一気に評価していたが
　　それをするとproofが作れなくなるので、1つevaluateで消すたびに
　　proofを追加するようにした。
　　毎回結果をuserに見せるような制御にした
　2. resolveは、1ステップだけ先に進めるようにした。

  (evaluate^*+view+resolve)^* という感じ。

　revolveの相手はoppositof()で求めるので、ループにはいってしまう
　可能性もあると思う。

　理論的には重要だが、応用の対象をGUIによる質疑応答にしているので、
　実際に、どれくらい複雑なclause集合を使うのだろうかと思う。

　3. Viewでliteralを消す時、proofを作るためにはFact clauseを作った
　ほうがよいような気がする。はっきりしない。
　

🎂P(x,3)からViewのYに3がはいるようになっていた。
　



20190630日
昨日のつづき。

|gvars|=4で|cvars|=2 の差かな

たしかにそうだ。
varg.remにσoをかけようとするとvargとvarcの長さが違うのでこうなる。

lvarの長さを持つσoをclauseのvarsのサイズに拡張しなくてはならない。

σoはbindingまで含めると varc.(varc←σo)

varcとσoの順番とlengthは同じ。(by cnf def)

1. varc.σoをvarg.σgに変換する手順

varcとvargは長さは違うかもしれない。
一致しているものは

gatmのargsをとってくると、|varc| = |gatm.args|
∵ canoはそのように定義するから。

まず順番をそろえる。
(下のclitはcatm, glitはgatmでもよい)

clit2 = varc.(clit*σo)
σg = varg.<glit:clit2>

bindingを示すと

σg = varg.(varg←σg)


ここでnew goalの形はこうなる

vars.rems

このことから

varg ∈ vars なのでvars.σsは

σs=varg.(vars*σg)

と計算できる。
これは、vargの範囲では
varg.σs = vars.σs
それ以外の範囲では等価代入
ε=vars.σs
という意味での拡張になる。


さて、
glitのbindingは varg.glit
goalのgindingは vars.goal

であり

σg = varg.varg*σo

となる。

ここで、varg in vars なので

σs=varg.(vars*σg)

newgoal = vars.(rem*σs)

である☕️

C12は進んだが、reso作っていないようなので、[]まではいかない
C2で例外・・・addstep()でglid0[1]はevalを除いたあとが[]のときindex Exceptionになる。
親のgidl[1]をparentにした

C1から確認
C1 Valid OK
C2 Contradiction OK
C3 View入力でなんでも[] OK
C4 2つのViewでなんでも[] OK
C5 View先、残りevalで[] OK
C6 evalで残り1Viewで[] OK
C7 Viewは後出し。ViewPでx>=yなら[] OK
C7 ViewPでx<yなら[]ができない => validview OK ... 入力が代入されていない
   clauseがcoreに登録されていない
C8 ViewPは先出し。ViewPで>=yなら[] OK
C8 ViewPでx<yなら[]ができない => validview OK... 入力が代入されていない
C9 ViewP{x,y}とViewR{z,w}があり、x>yなら[]、OK
   そうでないならValid... OK 入力が代入されていない
C10  {x>=y}、ViewP{x,y}, ViewR{z,w}, S(y,w) 
　　　y = 1, w= 2, x >=1 なら[] NG Sのresoができず途中
     それ以外はValid ... OK

C12 {x>=w}、ViewP{x,y}, ViewR{z,w}, S2(1,2) 
　　a x>=2, y=1, w=2 なら [] NG Sのresolutionできず。Viewとevaluate部分はOK
    b それ以外はValie(かな) OK 

ここまででいったんcommit

goresolve()追加
うごかない
 


20190629土
・xxxview()でstringclauseを表示するようにした
・/startのところでglobal変数を初期化するようにした。
　続けていると値がおかしくなっていたので(gidが残っているために
　stepを続けているとみなしている)

・lidの表示で、literalも表示しよう
・xxxview()で/startに戻るようにしよう

fixing
・R1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))] cant progress more
ということはProcリテラルは、viewやresoにかからない(resoはまだない)のと
evaluateで変数が残っているから実行できないのでこうなる。

?変数は置き換わらないのか

C7:[x_C7,y_C7].[L15:-(ge(2,1)),L16:-(ge(x_C7,y_C7)),L17:-(ge(5,2)),L18:-(P(x_C7,y_C7))]
なので、まずPのViewがでなくてはならない。
なぜでないのか。
evalauteだけで終わっているらしい。


logをみると

stringcore(core) = "CORE: vdata/vev002.cnf\nCLAUSES\nC2:[x_C2,y_C2].[L4:-(ge(12,5)),L5:-(ge(114,55)),L6:-(ge(115,9))]\nC10:[].[L10:+(S(1,2))]\nR1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))]\nC8:[x_C8,y_C8,z_C8,w_C8].[L1:-(ge(x_C8,y_C8)),L2:-(P(x_C8,y_C8)),L3:-(R(z_C8,w_C8))]\nC1:[x_C1,y_C1].[L7:-(ge(2,5)),L8:-(ge(4,55)),L9:-(ge(5,9))]\nC4:[x_C4,y_C4,z_C4,w_C4].[L20:-(P(x_C4,y_C4)),L21:-(R(z_C4,w_C4))]\nC5:[x_C5,y_C5].[L26:-(P(x_C5,y_C5)),L27:-(ge(2,1)),L28:-(ge(4,2)),L29:-(ge(5,2))]\nC9:[x_C9,y_C9,z_C9,w_C9].[L22:-(ge(x_C9,y_C9)),L23:-(P(x_C9,y_C9)),L24:-(R(z_C9,w_C9)),L25:-(S(y_C9,w_C9))]\nC6:[x_C6,y_C6].[L11:-(ge(2,1)),L12:-(ge(4,2)),L13:-(ge(5,2)),L14:-(P(x_C6,y_C6))]\nC7:[x_C7,y_C7].[L15:-(ge(2,1)),L16:-(ge(x_C7,y_C7)),L17:-(ge(5,2)),L18:-(P(x_C7,y_C7))]\nC3:[x_C3,y_C3].[L19:-(P(x_C3,y_C3))]\n\nPSYM: [P,R,S,ge]\nCANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))\n"
:goalprover1 = :goalprover1
gid = :R1
glids = Any[:L16_R1]
nlids = Expr[:(-(ge(x_C7R1, y_C7R1)))]
:askU = :askU
chooselid = chooselid
gid = :R1
lids = Any[:L16_R1]
lid = :L16_R1
:nocano = :nocano
v = Inf
ix = 1

なので
R1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))]

★canoのL18:-(P(x_C7,y_C7))が無視されている。

C8は、Viewliteralを先頭に持ってきたが
R1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))] cant progress more
となり

stringcore(core) = "CORE: vdata/vev002.cnf\nCLAUSES\nC2:[x_C2,y_C2].[L1:-(ge(12,5)),L2:-(ge(114,55)),L3:-(ge(115,9))]\nC10:[x_C10,y_C10,z_C10,w_C10].[L4:-(ge(x_C10,y_C10)),L5:-(P(x_C10,y_C10)),L6:-(R(z_C10,w_C10)),L7:-(S(y_C10,w_C10))]\nR1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))]\nC8:[x_C8,y_C8].[L8:-(P(x_C8,y_C8)),L9:-(ge(2,1)),L10:-(ge(x_C8,y_C8)),L11:-(ge(5,2))]\nC1:[x_C1,y_C1].[L12:-(ge(2,5)),L13:-(ge(4,55)),L14:-(ge(5,9))]\nC11:[].[L15:+(S(1,2))]\nC4:[x_C4,y_C4,z_C4,w_C4].[L16:-(P(x_C4,y_C4)),L17:-(R(z_C4,w_C4))]\nC5:[x_C5,y_C5].[L18:-(P(x_C5,y_C5)),L19:-(ge(2,1)),L20:-(ge(4,2)),L21:-(ge(5,2))]\nC9:[x_C9,y_C9,z_C9,w_C9].[L22:-(ge(x_C9,y_C9)),L23:-(P(x_C9,y_C9)),L24:-(R(z_C9,w_C9))]\nC6:[x_C6,y_C6].[L25:-(ge(2,1)),L26:-(ge(4,2)),L27:-(ge(5,2)),L28:-(P(x_C6,y_C6))]\nC7:[x_C7,y_C7].[L29:-(ge(2,1)),L30:-(ge(x_C7,y_C7)),L31:-(ge(5,2)),L32:-(P(x_C7,y_C7))]\nC3:[x_C3,y_C3].[L33:-(P(x_C3,y_C3))]\n\nPSYM: [P,R,S,ge]\nCANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))\n"
:goalprover1 = :goalprover1
gid = :R1
glids = Any[:L10_R1]
nlids = Expr[:(-(ge(x_C8R1, y_C8R1)))]
:askU = :askU
chooselid = chooselid
gid = :R1
lids = Any[:L10_R1]
lid = :L10_R1
:nocano = :nocano
v = Inf
ix = 1

であり
R1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))]
だからView リテラルが無視されている

★★★ evaluateのあとでgoalを作るときに、Procリテラル以外のものを残すのを
忘れているらしい

evaluateの中でisProcでない場合のelseが抜けていた。
修正したらViewがでるようになった

今度は、
1. R1にはview リテラルのみになった
R1:[x_C8R1,y_C8R1]. L8_R1.-(P(x_C8R1, y_C8R1))

evaluate => R1のとき、今度はevaluateですべて消された
elseのときrgidsにgidをついかするように修正

すると

PSYM: [P,R,S,S2,ge]
CANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))
GOAL
 R2:[x_C8R1R2,y_C8R1R2].[L10_R2:-(ge(x_C8R1R2,y_C8R1R2))]

X,Yへの代入がremにapplyされていない
σoのあつかいがおかしい


viewのσoがもどってきたとき、goalのremの変数名を新しいgidでrenameしているので
canoのX,Yへの代入はヒットしないのだが、
そこはvarsをこのremのvarsにすれば解決するはずでは??

factify_clauseの冒頭で
glid = :L8_R1
σo = Any[:x_C8R1, :y_C8R1]
glit = :(-(P(x_C8R1, y_C8R1)))

σoは入力値の代入だから[5,3]みたいになるはずではないか
R1のvarsもほしい

★ σoを作るときの変数をcanovarsof()にしたら、[]までいったC8,C7

そのあと、変数の数が違うためかExceptionが発生するようになった

そこで今日は力尽きた



20190628金
最初、何度やってもすぐにKeyerror(:R1)で終わった
裏で別のload_viewprover.jlを実行していた。

C7,C8で-ge(-,-)が消えなかった
どうも先にaskUで消えたリテラルのσが残りのgoalにapplyされていないようにみえる

20190623日
load_viewprover.jl 
 - vlogic
  - viewlogic.jl -- html view を作る部分
  - viewreso.jl  -- resolution の部分。logicと分けるのは難しいのか
  - vhtmls.jl    -- html生成関数
  - factify.jl   -- postviewでviewで消したclauseを作り登録する

手順
 include("load_viewprover.jl")

 一方

 vdata/vev002.cnf
 gid = C1 -> eval and => Valid
 gid = C2 -> eval and == Contradiction
 gid = C3 -> 1 Views and => Contradiction <= now here

 after View, Exception occured...

 gid = C4 -> 2 Views and => []
 gid = C5 -> View + exec => []
 gid = C6 -> exec + View => []
 gid = C7 -> exec + View with var => []

global gidやcoreに設定していなかった

それを直したらC4までうまくいった
C5はviewがでてほしいのに、何もしなくても[]になった

julia 再起動してやってみるも同じ
PのViewがなぜかできている

C6も同じ

C7 は空白画面になってしまった


20190616日
*** viewlogic uses a Web Page for a tool for getting FACT, 
I assume the inputs from an human is a fact.
Of cource, human may mistake. The reasonable treatment the input
should be cross check it with Base(Axioms).

*** The problem for an huge number of fact is not cleared.

viewlogic.jlはvlogic.jlをコピーしたが、まだ作っていないので動かない。

vlogic.jlが動く

・Viewの初期値がはいっていない。(defaultvalue? value?)
  修正した
　isvar@goal でないとき初期値にする

・viewreso.jlとvhtmls.jlを思に修正
  viewを作るために、goalからCanoを抜き出して、invarの数(canoにて)が一番少ないものを
　viewのliteralとする。
・ただし、invarの数が0のものがあったら、即決でそれをViewにする。

・askyouを作ろうとしているところ
　ここでhtml作成関数を呼ぶことはできるが、表示はviewlogic.jlからなので
　本当は、そこからaskyouを呼ぶようにする必要がある。ううむ



20190615土
viewreso.jlがsyntaxこわれていたので整理

vlogic0.jlとvhtmls.jl はGenieで targetを/go一個にし
targetの区別をopで行うようにした

実質的には前のvlogic.jlと同じような気もするが、
分岐を1つのrouteで表現できるのでましか。

vlogic.jlはvhtmls.jlと整合しなくなったので、動かない

globalを使っている箇所をsessionID+sessionDataで表現すれば
複数のcnfも扱える


証明の分岐の解決ができていない。




20190614金
・isCano(x,core)を作るためcanoのlsymのリストを作っておくことにした
　これはcoreにいれよう(なくてもなんとかなりそうだけど)

・isProc(x,core)は、procがevalされているので
　isa(lsym, Function)で判定する。このlsymはSymbolではなく関数名で
　あり、未定義の名前だと例外が発生するのでtry-catchで補足する

これらの関数をviewreso.jlに追加し、testviewreso.jlを作った
load_viewprover.jlを作成した。

・vlogic/vlogic.jlはviewとlogicが混じっているので分離したい
とりあえず、geneを使わないバージョンを作ってそれに

genieを組み合わせたい。
 ファイルの再構成
 vlogic.jl => vlogic0.jl (記念にのこす)
 viewlogic.jl を新しいvlogic.jl相当にしたので、vlogic.jl == vlogic0.jlになった


20190609日
・factify_clause()の関数名を昨日かえてしまったのだけれど
  genieで動かすvloigc.jlで呼んでいたのでもどした。
  viewreso.jlにこの関数だけはいっていたので、factify.jlという名前で
　追加し、動くことを確認した。

・Viewで入力した値は、fact literalを作っておくとproofに残るという点が
　メリット



20190608土
みなおし

関数名をrefute_goal()とし、glidでなくgoal全体を対象として[]を目指す関数と
とらえた。

3つのステップ
1. remove_false() or revmove_by_evaluation() or compIt()
 juliaの式としてevaluateし符号も含めてfalseならそのliteral=式を消す。
 trueならclause全体がtrueとなるので、refutation全体が無効になる。
　これを:FAILという名前の例外を飛ばしてよいのか???
 自然な前提として、このようなliteralはground literalである。
 groundかどうかをチェックしてからevalするかどうか。同じようことを二度する
　ことになるので、ground checkは不要。


  1) 実行可能なliteralは定義のある述語のliteralなので、CORE.procにある関数は
　　残りの述語として数えなくていい。その変数はresolutionがだめでも
　　askyouで必ず消せるから。消せなかったらrefute失敗

    残りのliteralがすべてproc述語で、groundなものが残っていれば
　　refute失敗。(か、その条件を満たす変数を不定の解として) と考えられる。

　　proc literalはoppositeにあっても、分岐条件なのでresolutionする必要がない。
　　それは+P(x)と-P(x)のモデルが共有されないということ。つまり同じxが両方の
　　clauseで存在できないので、resolutionする意味がない。

　　resolutionするときliteralを消せるのは、共通のxのモデルがあるから。
　　分岐では、それらのliteralには
　　　1) 共通のモデルがない
　　という条件を前提としていて、executableというのはまさにそういういみ。
　　現実世界で、p(x)かつ!p(x)がないのだから、resolutionには意味がないということ。

　　resolutionでは形式的にでもそのようなxがあるとして、矛盾すると言っている。
　　しかしそのようなxが存在できないのなら、p(x)と!p(x)で分けてrefuteすればよい。
　　・・・というようなことか。よくわからない。

2. remove_with_base() or remove_by_resolution() or inferIt()
 これは、goalのliteralをcoreのbaseで消す。
　グラフでは、goalのpsymのopponentにぶら下がるノードがあれば実行できる。

 いくつか問題
 1) ぶらさがるノードの中で1つだけが適用可能なら、安心してresolutionしてみればよいが
　そうでない場合もありうる
 2) resolutionでglitを消すと、goalのliteralが増える場合もある。
 
 3) 複数のnodeがあると、それぞれについて新しいgoalがありうる。
　・あるgoalのrefuteに失敗した場合、バックトラックして別のgoalを試す(Depth first)か
　・ひととおりの新goalを作っておいて、順番にトライしていくか(breadth first)

　・複数のgoalがあったとき、refuteできそうなgoalを優先して行う。という方法もあるかも。
  　そのとき、「refuteできそうな」の評価方法は?

  ・(literalが増えたとき、)ground literalでevaluateできるものがあれば、減らせる。
　・グラフにoppositeがないliteralがあればaskyouで値を求める。
　・

 4) どのliteralから消していくか


 5) 消す方法は、viewにすべきかresolutionにすべきか
    判断基準はoppositeのリテラルの状態とclauseの状態が材料になりそう。
    一番簡単な場合
　　　oppositがground unit clauseでunifiable
　　　oppositがunit clauseでunifiable

　　そういうものが複数あったらどうなるか。
　　　a) groundの場合、unifiableなら同一のliteralということなので
　　　　そのliteralはviewにしても意味がない(つまりconfirmしか得られない)
　　　　だから、そのliteralについてはresolutionしか必要ない。

　　　b) 変数があるときは、標準形の変数が減るようなlitralがあったら
　　　　resolutionは有望かもしれない。
　　　　resolventができたときのlitral数は少ないにこしたことはないが
　　　　evalで消えるものなら数えなくていい。


　評価基準案
  ・案1) 式に含まれる変数の数をみて、0に近いものはgroundに近いとする。
　・案2) Canonicalを情報1とし、ground clauseはすべて0とするのもある。
    これを<:>で評価できるか??
    空代入φは<P^c:P^c>=<P_g:P_g>=φ
　　P_gはgroundliteralであり、同じliteralの場合
　　ground literalは異なるものがいろいろあり、
    <P_{g_1}:P_{g_1}>は常にφであり(これはなんでもこう)
    <P_{g_1}:P_{g_2}>は失敗する。
    canonをP^cと書くとすると、<P^c:P^c> = φであり、

　　何かリテラルPが与えられたとき、

　　<P^c:P> = φは必ず存在する。

　 このφの形によって、[]に近いかどうかを判定できないか??


3. remove_with_askyou()
 これは、goalのliteralをcoreでは消せないとき、Viewでexternalに問い合わせる。
 externalが人間の場合のこと(AIプログラムが世界に対する判断をこのような形
で受け取ることが一つのテーマだが、それは難しいのでこの方法で試している)

 グラフでは、goalのpsymのopponentにぶら下がるノードがあれば実行できる。
 opponentにぶら下がるノードがあっても実行して悪いわけではないとも思う。
★　たとえば、resolutionで進展しないときに、人間に問い合わせるとか

 この考え方はよいのだがコードについて。
 literalからPageのhtmlを作り、そのurlをBrowserで開いて
人間が入力し、confirmすると別のurlでその値を受け取る。

htmlを作るところと、値を受け取るところは、同じ計算環境(session)
だが、計算のブロックとしては別になってしまう。

このような位相のπ/2のずれのようなことをわかりやすい形で記述できないか。
htmlの前と後で分けた時、一連の処理なのにもかかわらず計算が
分割されてしまう。

schemeかlispで何かフレームワークがあったような気がする。
具体的には知らないので、すこし考えてみよう。

★そのほかの問題
 1) resolutionとaskyouの順番
   removebyevaluation()はgroundに対してしか行われないので、この2つとは独立
　 resolutionとaskyouの場合、どちらも変数をinstance化していく。

   resolutionでいくつかの変数に定数が入った後にaskyouをすると、
　わかっている項目に初期値が入るようなことに対応して、おもしろい

　しかし、人間に聞いてわかることであれば、askyouで変数の値を決めて
　おけば無駄にresolutionしなくてもよい。つまり、resolutionを効率よく適用
　できたり、resolutionを回避できたりする。

　





20190606木
applytemp()の末尾
map(rid->lidsof(rid, core),rids)
の部分は正しいのか?
ridのlidsof()をとるのはいいが、グラフのPにぶらさがっているliteral
すべてにこれをしてどういう意味が??

viewreso.jlに追加
evalation(glid, core) を作ってみたが、この関数は何をすべきか。
glidがevalしてfalseになったとき、goalからglidを消したい。
その点はできていない。

go_resolution()は、graphでglidの相手がいたら、resolutionで
消去する。



20190605水
・unify(vars, array, array)を追加した。testも
・testnewcoreが昨日の分未修正だったので修正した

20190604火
・COREにcanonicalを追加
・printcore()の修正など

20190602日
・goalの引数に定数があるときの処理を考えた。
標準リテラルが必要になり、ややこしくなる。

今のままで、GUIダケでなんとかならないか考えたが、やはり無理そう。

・goalが[]になったとき、confirmすると/startlogicに戻るようにした。
　readcoreをしたとき、フラグをもう一度trueにする修正必要


20190601土
今週は、vlogic.jlとviewreso.jlをnavinavi/genieで作っていた。

coreやclausesをhtmlで表示するためにcorestring.jlを作ったのは今週ではなかっただろうか。

いちおう動くようになったので、vlogicをcheaplogicにコピーした。

動かしかた
@Prover
$ julia
> include("load_vlogic.jl")
vdata/vl002.cnf だと、2回glitを使えば[]になる

TODO:
1) goal literalの消去の方法は3つある
　(1) baseとのresolution
  (2) executeしてfalseになるとき消去
  (3) Viewで消滅させる
　* 消していく順番を決定する方法

1) もとのliteralの引数が定数の場合、その定数がviewに反映されない。
2) cancelまたは ViewのFactが -Pであるような場合
3) lvarsofがvarsofと同じになっている。
　 変数をliteralにあわせるには、標準literalが必要


20190512日
{GoalKeeper- Genie- SQLite}
ここ数日、webのViewとproverをつなぐ仕組みを考えていた。
clauseの集合Baseと、アプリの目的を示すclause Goal(B+G)を与えて
Viewで何かを決定すると、対応するFactが作られて
それをつかってF+B+GでGoalを変化させていくというイメージ。

外部でFactを作るという考えを試すのによいのではないか?

考えたこと
0. B+Gで、どの述語にViewを対応させるかは、あらかじめ定義しておく必要がある。
　　動的にPageを作るというのであれば、ここは自由だが・・(*ここ不十分)

1. Goalに対してBaseを適用して、Goalのリテラルが、Viewを持つものになるまで
　 変形していく。

2. すべてがViewを持つ=Factになりうる必要はないように思うが(*ここ不十分)
　 複数のLiteral in GoalがFactableになるまで変形すると、(*ここ不十分)
   FactableでないLiteralをのぞいて、
   Goalに対してPageの集合が対応し、Web画面が起動する。

*Factableは造語
 (factorialと似ているので、似た言葉がすでにあるのかもしれない
  ちょっと調べたがfactableは辞書にはなかった)

3 Factはground unit clauseかどうか
  -ViewでEntry Sheetみたいなものを考える。
　 そのとき、入力の必要のない項目は、変数のままにしておけばいいはずなので
　 GroundでないFact clauseがあってもいいのではないか。
　 Partial Fact。
　 Unit ClauseはPartial Factということか。

4. Factable LiteralとViewの対応はvarsになる。
　 FL と Vの間は、標準Literalを介してデータが相互に渡る。
   標準Literalは、引数がすべて異なる変数のリテラル。
　 Factable と標準をunifyすると、そのσはViewに表示すべき項目の値になる。
　 Pageはvarsを持つので、そのσをPageに適用すると、計算できる。

　 Pageで入力がconfirmされたときは、Pageのもつvarsに対する代入σも決まるので
　 pageのvarsは標準literalのvarsと同じであり
　 そのσをFactable≈標準に適用すれば、Viewから得たFactリテラルが作れる。

課題
・中間resolvent
  BにはFactableでないリテラルがあると思う。

  Viewから見ると、Logicに関連しており、画面遷移の論理ではあるが
　見た目とは関係ないもの。

・Viewの出現タイミング(Tabか遷移か)
  Goalの変換で、どこまでproofを進めればよいか?

  1) Goalに1つでもFactableがでてくるまで進めて、Factableに対応するViewを
　　 UIで示す。
     1Pageが遷移していくものになり、画面遷移をLogicで書きたくなるかもしれない。
     それは望まない。証明の都合で、画面遷移が変わるとか・・・

  2) GoalがすべてFactableになるまで証明を進めて、Goal単位でPageに変換する。
　　　並列でPageがでるので、Tab切り替えのようなものになるのではないか。

  3) Factの変換とViewの遷移のタイミング・・・

　4) Pageのある変数が別のPageの変数として使われているかもしれない。
　　そのとき、varsに対するσとして適用と反映をpageごとに行えば
　　同期がとれる。
　　この同期のとりかたは、Factとの同期と一致しているはず。

　5) Goalが複数のclauseになるとき
　　1 clause goalに対して、複数のclauseが適用でき、その結果
　  goalが複数になることはありうる。

　　Viewから見ると、tabで別れたPageが複数でてくる。
　　利用者はそれらのPageのどれか一つを入力しきればいい・・・

　6)条件のある場合、異なるPageになるはず。だがリテラルと条件の対応はわからない。

　7)





・executable literal に相当するのが factable.

・


▪️ Juliaで実装するとき、WebアプリのフレームワークとしてGenieというのがあって
Railsみたいにつかえる。WebからJuliaの関数を呼び出せるのはよい。
ということでGenieを調べている。

GenieでSQLiteを使っていたので、SQLiteをインストールした。
HPからとってきたファイルはsqlite3とsqldiff, analyzerのみ。
これですべてらしい・・・Liteだ。

DBは動くようなので、さらに、 Genieで, DB関連のものらしい
SearchLiteというモジュールを使っていたので
] add https://github.com/essenciary/SearchLight.jl
したが、途中でエラーになり中断。
LibPQで失敗しているらしい。

DBはなくてもよいし、 面倒なのでやめ。

きちんとドキュメントを読んでいないからかも。

▪️ Genieは Rendrerが使えれば十分だと思う。

View-Logicのお試し版はGoalkeeperという名前にした。
Goalを[]にする目的でrefuteしていくので。

### GoalKeeperについて

方法
まずは、単純な画面から作っていく。
20190504
Factを動的に追加してくシステムを作ろうかと思う。reactlogicと呼ぶことにする。

1 simpleproverを参考に考えてみたが、factを追加すると、cdb, ldb, templateを
updateする必要があり、 記号もふえるかもしれない。
evalonの処理は気にしなくてもいいような気がする。

2 factを追加する処理、updateと、factが追加されたら、goal x new Axiomsで
  証明を進める処理の2つが必要で、reactlogic.jlに枠だけ作っている。
  進められるところまで証明をすすめて、goal2ができる。
  それが[]なら、終わり。

　1ステップでなく、進められるところまで進めるのは、1つのgoalから
　共通の子供になる複数のresolventがでてくるのをとめるため。

　[g1,g2,g3] x {a1,a2,a3}で
　g1, a1 => 0
  g2, a2 => 0
　だったら、1ステップだと[g2,g3]と[g1,g3]ができてしまい、[g3]ができないとなると
　今できるはずの[g3]が次以降のステップにでてこなくてはならないことになり、ややこしい。

  そこで、[g2,g3]と[g1,g3]は途中ででるけれど、最終的なresolventとしては[g3]のみとする。
　これで問題になりそうなのは、新しいfactが前ステップにでてきたresolventを置き換えるような場合。
　上の例で考えると、次のステップでa4が加えられて、g2, a4 => 0となるとき
　もはやg2はないので、このa4は[]生成に関与しない。

　動的に変更されるaxiomという枠組みの中で、これは避けられない。

3. 現実的には、小さいaxiomsであれば、毎回、全axiomsから[]を導出するのでもよいかもしれない。

  ただし、途中のgoalを調べることで、まだ未解決の条件が何かを知りうるので、



20190503
 play.jlにあったreadstring()が未定義だったので、read(file, String)に変更した。
 1step proverを作ろうかと思ったかが、dostep1goalsがplay.jlで使われていて
 それの使い方を調べていた。
 テンプレートを一回適用する関数らしいので、だいたい目的にあっている。

 commitしようとしたら、未commitのdocsがたくさんあった。

---
実世界での操作から述語を生成(GUIとか機械学習による)し
それに基づいて証明を進めるという考え方の検討

runkb.jl, kb00[0-3].cnf
途中の状況があまり鮮明に描けないが、kb003.cnfで、作られたresolventを確認すると
必要なものはとれている。
原理が単純なのでよいと思う。

1. イベントからclauseが生成され
2. そのclauseを使って、goalから新しいresolventを作る
3. それが[]なら、完了

という仕組みはできるはず。

イベントの部分はreplを使えばよいだろう





20190424
1. in cheaplogic, unify0snとunify0nsでisvarの判定する引数が逆だった
naiveとcheapが同じ結果になる

20190421
1. check TPU of Chang&Lee
   the definition of substitution is different.
2. investigating ml007, what is different naive and cheap.
   naiveでは9個の[]ができるのに、cheaplogicでは1つもできない
   R10まではcheaplogicでもつくれているが、その先がないin cheaplogic.

20190420
Problem: How about the original algorithm?
Do for it.
1) preparation: reso.jl to reso.jl, unify.jl and others
2) test it
3) make naiveunify.jl for the original algorithm
4) test it

1. First, I think test_unify.jl is enough for naiveunify.jl
   But, some functions as fp_unify() should not need in naive,
   I made test_naiveunify.jl. 
   If I want to compare two unify(), I need common tests.
 


20190413
I clearfed the concepts about substitution-apply-unify.

1. Substitution(Σ) can have {x<-f(x)}
   Σ=VxT

2. apply(α) replaces a var with the corresponding term simulteniously.
   Because it, the substituion can be express unambiguously as 
    (v1,v2,v3) <- (t1,2,t3) without {}

   α: T x Σ → T
   α: Σ x Σ → Σ 

3. <x:f(x)> fails. It is caused by inside check.
   This doesn't except x<-f(x) from substitution.

   <> : T x T → Σ

I thought yesterday, this is not correctly implemented now.
But today reso.jl should be correct. 
I clearfy some tests around this.


