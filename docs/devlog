ちなみに load_viewprover.jlで動かすと、readcoreしたものは変数coreにはいる。
QEDは☕️でしめす。
バグは🕷でしめす。「ばぐ」
重要なことは🎂でしめす。「こう」
何かの影響を🕸でしめす。「す」

2020/12/20 自分の開発スタイルは、未来の自分が、なにかやりたいことがあるとき、その修正箇所が
　すぐにわかるようなコードにすること。だと思う。
　grepくらいしかツールはないのだけれど、(Smalltalkならbrowserの多彩な機能が使える・・・)
　それで修正箇所がすぐにわかるように作っておくこと。
　それは、自分がだんだん馬鹿になっていくこととは独立な話。

　これを「愚者の方法」と呼ぼう。


-- todo
 go to issue in github. ちょっと使いにくい offlineではわからなくなるのでここに戻す

2021/03/09 asdf定義のdepends-onを明確にするため依存関係を明確にしファイル構成を見直す。
2021/03/07 play-prover*.lispでloadしていたのをみんなこれに変更する・・・
2021/03/07 asdfの仕様を確認すること。(asdf:require-system :rubbish)で警告がでる件

2021/02/20 重複したresolutionが行えないような仕組みがほしい。準備完了(pcodeを使う。addnwepcode, checkpc, make-pcpool)
2021/01/31 play-prover-gtrailの中で (when nids (push nid nids))は必要なのか? nidsはreturnしていないので

2021/01/03 load-rubbishして続行する方法を考える : save, loadは作ったが続きができるような修正は未
2021/01/03 system化(asdlある) by Recipes
2020/11/29 package化する
2021/01/03 exp(f,n)(x)でloopを消せないか?

20200823 resolve/renameでvarsとsigmaの対応を明確にする
20200823 resolve/lidの実装(litつき)
20200822 Lidの木、lidだけだとσを再生したいことはないか。そのコストは?

--- 以下済
2021/03/06 済 2021/01/31 goallistは*goallist* にしたほうがよいのでは? 3/6 goallistは一時的な存在で、*goallist*をupdateているので、大丈夫だろう
2021/02/14 済 ソートにした。(pinfof cid)は未ソートで(pcode cid)はsort and uniq化。関数名がよくないかも
20201025 済 clause/literalがinputかどうかを区別したい。*illist* とか *iclist*とかか *input-clause*に溜めた。
2021/01/30 澄 0213 validは仕様とFactのずれを示しているので、懐中電灯の故障箇所をみつけているのではないか
2021/02/04 済make-clauseで番号のないclauseに番号をつけるようにしたい
2021/02/06 済input clauseを知りたい。
2021/02/04 済 pcodeを各要素でソートする。pinfofも同様か。spinfofをみよ
1
2020/11/29 済 環境のsave/restoreはどうやればできるかを考える
2020/11/22 済 print-proof, print-proof0で、litてなくlsymを表示したい。パラメタで指定?
　　　　　　varsを表示しないようにしたら、全体がみとおせるので、この問題の意図がよくわからなくなった。済にする
20201024 済 readkqcで、全体が1つのlistでないと例外になる。エラーでとらえたい
　　　　　S-expのある限り読み込みconsするようにする
20200822 済oppos(resolveの候補lids)をもとめる最短路
　　　　　Lsymのpropに持たせるようにした
20200913 済)itoのbaseとbase-noranは再定義を含むので、同じitoの中におきたくない。どうすればよいか
　　　　　今はnoranだけで動いているはずなので、関係なくなった
20200823 済)lid,clidはもともとの数字またはatomのままでいいような気がする。
　　　　　lidの値としてrawを持っているので、よくない。


--- log
2021/03/14日
・play-prover-gt000.lispなどをみると、すべての[]を探している。
　goalのコントロールでは1つだけ[]をもとめるわけではない。

・ML-LOシステムの可能性調査
　- 動的にFactが追加されたときの動作確認
　- ML-LOでの新たな課題

　これらは別ファイルにまとめた。
  docs/20210314-about-MLLO.txt


・asdfとpackageの関係を調べるため
　quicklispとcavemanを~/Project/githubの下にcloneした
　沼である。

　どうもasdf.lispはたくさん定義されている。何か目的に応じて書き換えるらしい。
　quicklispとcavemanで書き方が違う。
　まず、defpackageで:useしているのが:cl-user(caveman)か:common-lisp(quick)か　
    これはcommonlispの関数については同じことになりそう。
　　common-lispは更新不可能。cl-userは変更可という違いがあることは知っている




2021/03/13土
・packageとsystemの実験はcheaplogic.pkgに残して、元の作業にもどる。
　- ~/quicktime/quicktime/asdf.lispをみてみたら、packageを使っていた。これは参考になるかも

・ML002のようなものを考えるとき、+PP(p, a) でaがPPである確率をpと書くとすると
・+PP(0.4,a) => +PP(0.6, a) => +PP(0.8, a)
　と変化したとき、これらのfactは蓄積されてはまずいので、置き換わらなくてはならない。
　矛盾していなくても置き換わる。
・置き換わるときの前提として、+PP(p, a)は1つしか存在してはならないという前提がある。
　つまりaについて+PPは1つのfactしか許さない。
　これは、PPがuniqueなaについての性質であるという性質。
・+R(p, a, b)というような「関係」の場合、(a,b)というペアについてuniqueな性質というものがあるか。
・uniqueというのは、(a,b)について1つしか関係がないという意味でなく、(a,b)のRという関係は1種類しかないということ。

・あれ? これは以前さがしていたclosureではないか
* (defparameter xx (let ((x 0)) #'(lambda ()(list x (incf x)))))
XX
* (funcall xx)
(0 1)
* (funcall xx)
(1 2)
* (funcall xx)
(2 3)




2021/03/11木
やすみ
・learninglispでpackageとsystemを組み合わせてみた。
　各ファイルの先頭にin-packageをいれておけばよさそう
　rubbish-pkgにcloneを作りためす
　ito.lispはどうしたものか

・cheaplogicをcheaplogic.pkgにコピーして、in-packageの追加と
　asdに(:file "rubbish-package")を追加

  common-lisp-userで実行すると
  (rubbish::readekqc "kqc/lover/love001.kqc")
　は*maxcid*がないといって終わる。
(RUBBISH::ADD-CID READEFILE)
   source: (MAX *MAXCID* N)

　rubbish::*maxcid*は存在し、base.lispの中の
(defun add-cid (n)
;   (cond ((< n *maxcid*) (format t "name double ~a~%" n)))
   (setf *maxcid* (max *maxcid* n))
)
の部分。
　defvarで定義していたのでdefparameterにかえてみたが同じ

・(in-package :rubbish)でなら動く。

・これは、defparameterに修正する前のがのこっているのかも・・・
  (asdf::load-system :gtrailp)をしたときコンパイルが走っていないから

  touch gtrailp.asd してみたらコンパイルはしつたが、同じ。

・readekqcはみつかっていて、rubbish::*maxcid*がみつかっていない。
・(setf *maxcid* 0) みたいなのがわるいのかと思い、setqにしてみたが同じ。

・それぞれのfileに(in-package :rubbish)がないと、シンボルはcommon-lisp-userに
　作られる。
　だから、fileごとに(in-package :rubbish)を書くのが正解だろう。

・ito.lispはどうか?
　package itoをつくればよいが、今やるとito使っているところ全部修正か・・・
  全体は(in-package :rubbish)にして、itoマクロはito::intend...にする。

めんどうなのでやめよう。
ということは・・・

・package & asdf版はcheaplogic.pkgにある。
　ただしito.lispは/Users/shin/lib/lisptoolsの非package版が最善
　githubのito.lispはpackage化しているが、使うにはさらなる修正が必要。
　rubbishとitoの混在になる。(:use :rubbish :ito)とすればよいのかも。

・cheaplogicはrubbish.asdのみ使用。
　パッケージは使わない。rubbish-package.lispは仮。非パッケージ版のitoは使える。

・in-packageのときかrubbishの定義かで、(:use :cl :ito)とすればよいかも
  rubbish以外でitoを使うときどうするか考えると、in-packaeでuseを使うとかけるとよいのかも。



2021/03/09火
・packageしてみる
  rubbish-package.lisp
(defpackage :rubbish
  (:intern :common-lisp)
  (:use :common-lisp)
  (:export 
    :readekqc
    :prover-gtrail 
    :play-prover-gtrail
    :*max-clauses*
    :*max-trials*
    :*max-steps*
    :*timeout-sec*
    :lscova
    :print-proof0
    :dump-clause
    :dump-clausex
    )
 )


として

* (load "rubbish-package.lisp")
* (in-package :rubbish)
* (require :rubbish)
* (readekqc "kqc/lover/love001.kqc")
* (prover-gtrail '(c1))
* (lscova)
* *package*
#<PACKAGE "RUBBISH">
* (package-name (symbol-package 'car))
"COMMON-LISP"
* (package-name (symbol-package 'unification))
"RUBBISH"

となって、うまくできているらしい。
*** 3時間後、別の場所で確認したらreadekqcが見つからないエラー。
　そうなるのかなという気もするが、
　やはりpackageはよくわからない。


? 各rubbish*.lispの中にin-packageを書く必要があるのか?
  load-rubbish.lispの先頭に
    (load "rubbish-package.lisp")
  を追加し
  rubbish*.lispの先頭に
　  (in-package :rubbish)
　を追加。
　でできるという気はするが、そんなに細かく書く必要があるのか??

・exportが全体で1つということは、各ファイルの修正をするとrubbish-package.lispも
　修正しないといけいなということか・・・
　
・どうするのが、修正作業、使用方法、最小になるのか。

・asdlの定義で、依存関係を書ける(makefile相当ということみたい)
　書くとすると、ファイル構成のリファクタリングも必要そう・・・
　とくにproof関係の関数がちらばっている。
　subsubあたりからunificaiton/resolutionまでは確定だけど、systemで認識する
　依存関係が妥当になるためには、ファイル構成がcoherentでないと・・・
・今quicklispのディレクトリにln -sしているが、このsystem定義はquicklispでインストール
　したわけではないので、場所が違う。どこにおくべきか
* 数時間したら、(readekqc ...)で未定義エラーになった。
　(require :rubbish)のとき:rubbishのpackageが違っているということかも


・githubのcommonlispのrepositryをいろいろブラウズしてみよう。

[asdf]
・1つのrepositoryでasdfファイルはいくつもある。
　テスト用とかなんとか用とか。

・packageの定義がファイル名でわかるようになっていないので
　探すのはややたいへん。

[package]
package名とsystem名が同じ:rubbishだからうまくいかないのではないかと思い
systemを:gtrailとしgtrail.asdを作ってみた。

(load "rubbish-package.lisp")
(in-package :rubbish)
(require :gtrail)
としても

* (rubbish:readekqc "kqc/lover/love001.kqc")

debugger invoked on a UNDEFINED-FUNCTION in thread
#<THREAD "main thread" RUNNING {10004F84C3}>:
  The function RUBBISH:READEKQC is undefined.

rubbish:がなくても同じ。
defpackage で、export の関数名や変数名を:つけずにおいても同じ。

export "readekqc" にしてみたら
* (readekqc "kqc/lover/love001.kqc")
; in: READEKQC "kqc/lover/love001.kqc"
;     (RUBBISH::READEKQC "kqc/lover/love001.kqc")
; 
; caught STYLE-WARNING:
;   undefined function: RUBBISH::READEKQC
; 
; compilation unit finished
;   Undefined function:
;     READEKQC
;   caught 1 STYLE-WARNING condition

なぜか:が1つふえてrubbish::reqdekqcになっている。

・パッケージはさっぱりわからない

まず、パッケージ名は::でつける。
rubbish::*clist*

package内で定義するときはrequireではだめみたいで
(load "load-rubbish.lisp")
なら定義される。

rubbishの外側で(rubbish::readekqc ...)としてもだめなのは
中で参照している*clist*が

* (load "rubbish-package.lisp")
T
* (in-package :rubbish)
#<PACKAGE "RUBBISH">
* (load "load-rubbish.lisp")
* (prover-gtrail '(c1))
* (lscova)

は動く
(in-package :cl)
(rubbish::readekqc ...)
がだめ

* (rubbish::readekqc "kqc/lover/love001.kqc")
kqc reading: kqc/lover/love001.kqc
.
debugger invoked on a TYPE-ERROR in thread
#<THREAD "main thread" RUNNING {10004F84C3}>:
  The value
    READEFILE
  is not of type
    REAL
これはrecursiveにreadefileをevalしている箇所かもしれない。

関数は動いているので定義はされている。
全部rubbishパッケージの中なら動くのに・・・
evalか・・・
そのために(eval rubbish::readekqc ...)と書くのはどうだろうか。


★ packageとsystemを組み合わせるとどうなるのかよくわかっていない。
load-rubbish.lispにもどるか・・・

今のところsystemにするメリットがあんまりない。
packageにすると、面倒なことになる。

ううむ


2021/03/07日
・systemを作ってみた。
  次の手順でloadし実行できるのを確認した。

(load "rubbish.asd")
(asdf:require-system :rubbish)
;or (asdf:load-system :rubbish)
(readekqc "kqc/lover/love001.kqc")
(prover-gtrail '(c1))

Recipesをみていると本当はloadが必要なさそう。
たぶんASDF:*CENTRAL-REGISTRY*からとってくるらしいのだが
;(push #P"/Users/shin/Projects/github/cheaplogic/lisp/rubbish/" ASDF:*CENTRAL-REGISTRY*)
してもとってきてくれない。

悪あがきで、(load "rubbish.asdl")をいれてみたら動いた。

RecipesではLibraryの章に書かれているので、adslを使って
外部に提供するときの手段だと思われるので、その場合はquicklispを使ってinstallして
ASDF:*CENTRAL-REGISTRY*からとってくるという話になるような気はする。

Recipesだと、何もしなくてもadslをカレントディレトクリからloadしてくれるようなかんじ。
拡張子がadslでなく asdだった。そうするとエラーになるのでだめ。
拡張子をasdlにしてみたが、これははずしているのかもしれない。

★ warning
* (asdf:require-system :rubbish)
WARNING:
   DEPRECATED-FUNCTION-STYLE-WARNING: Using deprecated function ASDF/OPERATE:REQUIRE-SYSTEM -- please update your code to use a newer API.
The docstring for this function says:
Ensure the specified SYSTEM is loaded, passing the KEYS to OPERATE, but do not update the
system or its dependencies if it has already been loaded.

なんのことであろうか。さらに、でたりでなかったり・・・

ちなみに
* (asdf:load-system :rubbish)
T

★asdfの仕様の確認が必要
これだろうか。ASDF3だそうだ。2019年。
https://common-lisp.net/project/asdf/
日本語の記事もASDF3なのでよいかも。
https://privet-kitty.github.io/misc/asdf-ja.html

これに従って
(require "asdf")
をいれたが同じ。たぶんasdfはsbcl起動するとインストールされている。

面倒なのでこうする
--- ここから
(load "rubbish.asdl")
(asdf:load-system :rubbish)
--- ここまででload
-- 以下実行
(readekqc "kqc/lover/love001.kqc")
(prover-gtrail '(c1))

ちなみに
* (asdf:asdf-version)
"3.3.1"

ドキュメントは
https://common-lisp.net/project/asdf/asdf.pdf

結局こうする。
1. ASDF:*CENTRAL-REGISTRY*をみて、探しにいくパスを確かめる
2. cd ~/quicklisp/quicklisp
3. ln -s rubbish.asdのフルパス .
を一度やっておくと

sbclで
5. * (asdf:require-system :rubbish)
6. * (readekqc "kqc/lover/love001.kqc")
7. * (prover-gtrail '(c1))


これで(load "rubbish.asd")は不要になる

さらに
(require :rubbish)
で十分

・play-prover*.lispでloadしていたのをみんなこれに変更する・・・










2021/03/06土
・cheaplogicのwikiに今後どうしていきたいかのページを追加した。
　意外とやりたいことがなくならない・・・
・rubbishの機能がふえて、手でテストみたいなことをしていてもきりがないので、自動化したい。
　以前、atomとplistをテストする関数は作ったので、それを元に書いていくのがよいのだけど、忘れている。
・licence.txtでMIT ライセンスにした。
・put (make-lsymlist *llist*) into (readkqc ...) and (readekqc ...)
  これで、手でやるときの手順がこうなる
* (load "load-rubbish.lisp")
* (readekqc "...")
* (prover-grail '(c1))


2021/03/01月
・*lsymlist*からもlidを削除することをした

2021/02/28日
・パイプでやりとりは、mkfifoでfifoを作っておいて、これに対してopen/input/outputをすればよいだろう
　一方向であることと、テキスト(s式)であることを考えると、そんなにややこしくないはず。

・課題1) S式単位でreadできるかどうか
    (readefile file)ではファイルを全部readしてからclauseに変換している。
　　これではだめなので、作り直す必要がある。

　　確認方法)
     1)  (send file S-exp) in process A というので送って
　　 2) process Bで、
        with-open-fileかwith-open-streamでやる


・センサー(ML/DL)から命題が公理システムに追加される話
・複数の公理システムの間で、定理や公理を受け渡しする話
・そうなると、それぞれの公理システムにおいて、何が真なのかあいまいになる。
　・新しい命題がそれまでのclausesと矛盾したらどうするか
　　・新しい命題のほうが真だと判断できるなら、それと矛盾する部分を削除してよいはず
　　・新しい命題が真であると判断できない状況とは?
　・命題に、それの真らしさをつけくわえることを考える。この値を仮に真度とよぶ。
　　・各センサーは、その感度や経歴によって、ハードウェアとしての真度が割り当てられるとする。
　　・センサーから作られる命題の真度はセンサーの真度と同じとする。
　　・最初から公理システムに含まれる
　　　・公理システムに含まれる命題の真度は1.0。その公理システムが信じている事実。
　　　・ルールの真度は?
　　　　・論理的に真な論理式は1.0だろう・・
　　　　・最初に与えられるaxiomsは1.0にするしかない。(ほんとか?)
　　　　・知識を表す論理式は?
　　　　　・これは、対象とするモデルに依存するかも。
　　　　　　たとえば、無限ドメインを前提として論理式は、有限ドメインでは正しくないかもしれない。
　　　　　　　センサーの対象とする世界が無限に近いとしても、無限ではない。
　　　　　　　ということで、世界に関するメタ情報によって、決まってくる。
　　　　　　　この世界に関するメタ情報はセンサー側で評価することにすればよいのではないか。
　　　　　　　なぜなら、センサーと公理システムを分離できるから。
　　　　　　　　この理由は、妙だけれど・・・解釈がシンプルになるという理由でアーキテクチャを決めていく
　　　　　　　　これは、解釈はシンプルになるほうがよいという前提があるからかな。



・無限ドメインでは真で、有限では偽になるとすると、その境界は何か?


・コマンド実行し標準出力に出す
　(uiop:run-program "ls" :output *STANDARD-OUTPUT*)
　(uiop:run-program "ls" :output :string)
など
　実行結果を文字列にする
  (uiop:run-program "git status" :output :string)
　カスケードも使える
  (defparameter rubbishes (uiop:run-program "ls *lisp|grep '^rubbish'" :output :string))



2021/02/27土
・そのためにはパイプが使えるとよさそう。でも1:1だとパイプが増える・・・
・recipieの22章 World outside
　20章はhtmlで、21章がimage

　パイぷは、パッケージがあるらしい。
　recipeに書いてあるのはできず。
  コマンド実行だけならrun-programとかがある
　/tmp/a2bとかファイルわたしにするのはできそう。

2021/02/23火曜
・MLとLOとの組み合わせを考えたとき、
  A_tに、+P(i,a)だったものが、A_{t+1}に-P(i,a)と観測されたとき
  A_t + {-P(i,a)} からは矛盾が生まれる。
　その矛盾の範囲を消すなどの操作がしたい。
　という点で、refutationは使えるのではないか。

　1) refutation subsetを発見できるか? (A_tのどの部分が新しい-P(i,a)と矛盾しているのかを知りたい)
　2) +P(i,a)と+P(i,b)は矛盾するのか? (状態aが状態bに変化したという解釈では矛盾してほしい)
　3) A,α⇨□のとき、A⇨α⇨□みたいに書きたい。αは矢印の上に書きたい。textでは無理か・・・



・iMovieで操作の動画を編集できる。
　音声は、iTuneがどうのこうの書いてあるので、どうすればよいか・・・
　macbookのマイク? usbでつないでもいいけど。録音・・・
  ノイズが入らないように録音する方法は?

　iMovieでバラバラにするのはできた。くっつけるのもできそう・・・

　一部分を作ってみよう。
　load, eval, 結果の参照　のループ
  1. kqcの内容を示す。意味の説明。 　
  2. play-prover-gt-*.lisp(どれか)の内容 　
  3. loadして実行
　4. (print-proof0)
　5. いくつかのclauseの中身。(dump-clause), (print-clauses)

・こういう実験をやりやすくするため
　play-prover-gtailをふたつにわけて、start-prover-gtrailを作った。
　これまでのはそのまま動く。

・こういう実験をするためには、既存のcidを消す処理が欲しい。
 cidを消すとは
　1) (bodyof cid)のlidの消去
　　1.1) lidの消去とは
　　　　　1.1.1) symbol-plistの全消去 (remove-plist-of-atom lid)
　　　　　1.1.2) lidのbindingの消去 (makunbound lid)
　2) cidのplistの全消去 (remove-plist-of-atom cid)
  3) cidのbindingの消去 (makunbound cid)

  (remove-cid cid)を定義
  *clist*からも消しておかなくては・・・

・kqc file から読み込むという操作と、proverの対象にする操作を分けたほうが
　使いやすいかも。

　だけど、propertyを使うからそれがやりにくい。
★
　やるとしたら、save/loadみたいにpropertyから消したり登録したりすればよい。
　readekqcをするとpropertyも設定してしまうのが問題で
　文字列として残しておけばよさそう。
　

　


　


2021/02/21日
・昨日もcommit-aでエラー。pushでエラーとなった。
　確かに、昨日はgit commit -aの途中で作業を終わっていたらしい。ps
　pushでエラーが、二度続けておきている。
　pullしてmergeしてpush・・で、cloneしてみて実行はできる。なんだかおかしい。
・¬PをQと名付けたら、<P:Q>はできるのか? とふと思った。
　¬P ≡ Q をaxiomに追加すると
1　+P+Q
2  -Q-P
　が追加される。
　3+P+Rと4-P+Sがあった場合、resolutionで
　-P+S => +Q+Sとなり
　<-Q-P:+Q+S> => -P+S
　ができるが、<+P:+Q>がおきるわけではない。

・この同値の形があると、証明ステップ <1:2>が+Q-Qや+P-Pを生み出して証明ステップが終わらなくなる。
　これはpcodeで回避できる。
　pcode内のlidの順番の問題は、たぶん問題ではないような気がする。
・Qitaをみていたら、sbclで^bなどを効かせる方法がわかった
　　$ rlwrap sbcl
     https://qiita.com/ytaki0801/items/b082a92fb3b6861b0b2d

・これまでのsbcl関係のノウハウをまとめてはてなにあっぷした



2021/02/20土
・merge/merge001.kqcは、pcodeをみると組み合わせが全部おこなわれていることがわかる。
  play-prover-gt-mer001.lisp
  - goallistが空になって終了。
　- pcodeではmergeの組み合わせが全部実施されているように思える
　- ただし、pcodeでは、L4-1とL4-2が誰と消えたのかがわからない(組み合わせの情報をすてている)のでC13,14は同じにみえる。
    どちらの組み合わせも、この場合は同じなので(L4-1とL4-2は同じ形をしたliteral)このpcodeは同じでよい。
　　情報が違って、pcodeが同じになる例は作れそうな気がする。★
  ★print-proof0をみていて、lidだけでなくolidが見えるのもよいと思えてきた。
   
・prvoerのsummaryにあるtrial数にmergeがはいっていないような気がする。
　 mergeはtrialかな? resolventができたときにしかしないから、今のままでよいか・・

・readkqcした中に、kqc ファイル名をいれたい。
  (readkqc..)と(readekqc..)をするとファイル名を*kqcfile*に接定する。した。

　
2021/02/15月
・resolve-id の実行前にpcodeをチェックする方法

既存のpcodeを登録する
1. (setq pp (make-pcpool *clist*)) -- *clist*から作成
1.1.  addnewpcode is called in make-pcpool -- 1つ追加する方法
  used as  (setq pool (addnewpcode cid pool))

2. 2つのlidに対して、pcodeの既存チェック
　checkpc2 llid x rlid x pp -> T/F 
  * (checkpc2 'l5-1 'l4-1 pp2)
   ("(L4-2 L4-1 L1-1)" "(L4-2 L4-1 L3-1 L1-1)")
  * (make-spcode 'l7-1 'l3-1)
   "(L4-2 L4-1 L3-1 L1-1)"

3. cidの場合。checkpc:cid x pp -> T/F
  * (checkpc 'c10 pp2)
   ("(L4-2 L4-1 L3-1 L1-1)")

* なぜかcommitしてpushしたらほかでupdateされてて違うソースになっていたエラーが・・・


2021/02/14日
・rubbish-prover.lispのpcode関係のリファクタリング
・(pcode cid), (pinfof cid)
・(pcodeoflp lid1 lid2)が(make-pcode...)と同じだったので前者を削除
・(make-pinfo lid1 lid2)を追加。
・(make-pcode lid1 lid2), (make-pinfo lid1 lid2)は、resolve-idをする前にpcodeを確認できるので
　既存のpcodeと同じものがあれば、ここではじける。という気持ち。
・pcodeはsorted & uniqed, pinfoはsortもuniquもしていないもの、という役割分担。
・play-prover-gt7loop.lispで確認。C12と(L9-1, L3-1)を使用。

・なぜspcodeのようにstring versionを作っているかというと、既存かどうかのチェックに
　string=を使うほうが高速だろうと思うから。
　あるいはsymbolにしたほうがよいかも。

　あれ? :abcはsymbolでなくkeywordというのか? (type-of xxx)によるとそうなる。



2021/02/13土
・play-prover-gt-kosho009.lisp play-prover-gt-kosho009x.lispに変名しのこした。
・あらたなるkosho009は
  unit clauseを作るためfactのnegative(1,2)をgoalとする。BATは除く
　　SW(on) and Lamp(dark)
　　というfactから、理由であるBATが求められればいいかなと思ったので。

  rulesは、and記述の否定にする。
　
　すると、olphanとしてBATのリテラルがとりだせるが、これはだめだ
・問題の記述フレームワークがはたらいていないのは、問題設定がはずれているからだろう

・nconjにfactsのneg、factsにはここのパーツの状態、ruleはimply形式で書いたものがkosho010.lisp
--- switch010.kqc
;; FACTS
(1 () (+ SW on))
(2 () (+ LMP dark))
(3 () (+ BAT empty))

;; RULES imply-statements
(4 () (- SW on)(- BAT enough)(+ LMP light))
(5 () (- SW off) (+ LMP dark))
(6 () (- BAT empty) (+ LMP dark))

;; NCONJ
(7 () (- SW on) (- LMP dark) (- BAT empty))

;; prover parameter ?
; goal 7

--- end switch010.kqc
1,2,3のfactsと7のnconjは否定しただけなので、必ず[]が生じることは明らかだが
それとは別に何か[]がでないかどうか・・・


　2つの[](c14,c15)はでたがよくにている。pcodeをみると

* (pcode 'c14)
(L7-3 L7-2 L7-1 L3-1 L2-1 L1-1)
* (pcode 'c15)
(L7-3 L7-2 L7-1 L6-2 L6-1 L3-1 L1-1)

c14はfactとそのnegとの対消滅なので情報はない。

c15とc14の違いは、L2-1とC6であり、
(2 () (+ LMP dark))
(6 () (- BAT empty) (+ LMP dark))

バッテリーが空という記述に迫っている。

証明をみると
* (print-proof0 'c15)
C15: RESOLVENT = []
C15 [] RESOLUTION : <L13-1:L3-1>
  L13-1 ().(- BAT EMPTY)  in
  C13: RESOLVENT NIL [((- BAT EMPTY))]
  C13 (L13-1) RESOLUTION : <L10-1:L3-1>
    L10-1 ().(- BAT EMPTY)  in
    C10: RESOLVENT NIL [((- BAT EMPTY) (- BAT EMPTY))]
    C10 (L10-1 L10-2) RESOLUTION : <L8-1:L6-2>
      L8-1 ().(- LMP DARK)  in
      C8: RESOLVENT NIL [((- LMP DARK) (- BAT EMPTY))]
      C8 (L8-1 L8-2) RESOLUTION : <L7-1:L1-1>
        L7-1 ().(- SW ON) input
        C7: 7 NIL [((- SW ON) (- LMP DARK) (- BAT EMPTY))]
        L1-1 ().(+ SW ON) input
        C1: 1 NIL [((+ SW ON))]
      L6-2 ().(+ LMP DARK)  in
      C6: 6 NIL [((- BAT EMPTY) (+ LMP DARK))]
    L3-1 ().(+ BAT EMPTY)  in
    C3: 3 NIL [((+ BAT EMPTY))]
  L3-1 ().(+ BAT EMPTY)  in
  C3: 3 NIL [((+ BAT EMPTY))]
NIL

C6のルールとFacts(c3, c1)からc10になって、のこったBAT(empty)が
c3で2度消去され[]になっている。
C4とC5がはいっていないから、C6のルールが適用されたのはわかる。

factsとnconjで両側から証明にしている感じ。
つまり、factsとnconjは対消滅する(c14)が、それとは違う[] C15とC14の
証明の違いをみると、goalxfactsにどのようにruleが介入したのかがわかり
このfacts=nconjが、どういう理由(rule)で起きているのかがわかる。

なんだこれは??

★0の証明と何か起きている証明との差から、「何か」をみつけるということか。
★そのときpcodeは手かがりになる。

★ 以上をまとめた。20210213_about_flashlight.txt

・他にproverを使って何ができるかを考えよう


・pcodeにinput 以外のlidがでていないか?

・pcode/pinfofができていない。ccodeの仕様はなにか??
  (pcode cid)は、cidのproofに現れるpairのliteralのollidの集合。
　ではinput clauseの場合は何になるか?
   ()でよい。

　修正した。
　・pcodeは次のlidから構成されるリスと
    - resolutionの場合、pairの各lidのolidをpcodeにする。全照明木
    - reduceの場合、tlidのolidをpcodeに追加。その親のclauseのcidのpcodeに追加

   (pinfof cid)は未ソートでpcodeはsort and uniq化。関数名がよくないかも
 
2021/02/12金
・play-prover-gt-kosho009.lispで, C7は[]なのにcontradictionはnilになっている。
  ではなくて[]にはなっていない。+LITと-LITがあるのでsyntaxでの
  validかな。

2021/02/11木
・何を書いておくか考える
・rubbishについては、ソースのファイル構成みなおしたい

2021/02/07日
・LlidとRlidの候補が既存のpinfに含まれるかどうかを判定するというのは、結構な処理になる
　既存のresolventのすべてのpinfoについて含まれるかどうかを判定するとなると・・・
  たとえば、*clist*のすべての要素についてpinfoを計算してlistにしておいて、
　あたらしい候補pair=(ll,rl)がそれに含まれるかどうかの判定。
　基本的に、llとrlの両方がclistのどれかのpinfoにはいっていたらskip。

・cidは途中が抜けていても大丈夫なのか? (1,2,3,8,9,10みたいな場合)
　大丈夫だった
・kqcにnameのないS-clauseがあったとき、自動で番号をふると、タイミングで空いている範囲の
　番号になったり、ならなかったり・・・
　番号を自動でふるようにした。(new-cid)なので*maxcid*をインクリメントする。
　この場合のnameはcidそのものにした。

・input clauseを判定したい場合どうするか。
　nameが:resolventか:reducedのときはinputでないと考えるか
* *input-clauses*にinputclauseのcidのみpushnew. in (readkqc)
  make-clauseが呼んでいるsetcidで設定するとresolventも追加されてしまうので
　setcidを呼ぶ直前でpushnweした。

・expf in essential.lisp... try and fail

2021/02/06土
・仕様と故障の話、こじつけみたいな気もするが
・GoallistをObservationにするのはありかも。
・kosho005, kosho006といろいろ書いてみたが、何が正解かよくわからない。
　goalにobservationをいれるとき、そっちを全部否定するほうが正しいような気もしてきた。
　ならば、observationは本体にいれて、nconjは何か別のことを書くべきかも。では、何を?
・litealにS-expをもてるか。たとえば、(cons x y)みたいなの
  証明情報をリテラルに持つことができないかなと思った。
　L1-1(+ P a ()):L2-1(- P x ()) => resolventのどこかに (cons L1-1 L2-1)を持たせる。
　　　課題1) resolventでlidを参照できるか?
　　　課題2) 消えるリテラルに持たせてもしかたないのでclause/resolventに持たせたいが
　　　　　　　それは残されたliteralの引数になるのかな。
　　　ヒント　ccodeみたいに入力cidを追跡するだけならできそう。resolventのcidは参照できないにしても。
・saveするときkqcファイル名をもたせたい
・pcodeをソートする
　pairのリストを全部展開し、文字列としてソートした。
  複数回同じolidが使われていたら、1回だけにした。
　本来はpairを単位とすべきだが、反復は同じとみなしたいのでこのようにした。

　未 reduceの枝はまだみていない

 spcodeをこの方式に変更し、gt6loopのresolventで目視確認して、よさそうだった。
 pcodeはS-式版。spcodeはそれをstringに変換したもの。

★★★★ 次のルールで制御できるか?
 resolventのpcodeが既存なら、新規に作成しない。
 次のpairの候補が、もしresolutionすると既存のproofに含まれてしまう場合はresolutionのtryもしない。
条件 候補のllid, rlidが両方ともにどこかのresolventのpcodeに含まれる。

未実装 
****1

2021/02/04木
・kqcで番号をつけなければ自動で番号をふると思っていたがそうなっていなかった
　make-clauseで番号のないclauseに番号をつけるようにしたい
  cidは{6,1,2,3}の組み合わせになっていて、
  pcodeをみると、3つのcontraは同じpcodeになっている。
・pcodeはちゃんと各要素でソートしないと違ってしまう

2021/02/03水
・play-prover-gt-kosho00[123].lisp は、kosho/switch00[123].kqcを実行する
　1は、蛍光灯のスイッチとランプの関係だけを書いた。
　　矛盾がひとつもでなかったので、これはFactが仕様からはずれた故障を示していると考えられなくもない
　2は、故障状態も含めて書いた。つまり、電池のうむ。スイッチをいれて電池が空ならランプは付かないとかいた。
　　これもまた矛盾がでない。nconjの書き方がまずいのかもしれない。+/-の組み合わせができていない。
　3は、onとoff、darkとbright、emptyとenoughをnotであらわすようにしてみた。
　　resolventに同じものがでてきているらしい。[]はでてこない。
　　これは、無駄なresolventが生まれそうな気もするが、第一に電池のunitがないのでは[]にたどりつけまい。
　　しかし、電池の何を書くというのか。電池は空のこともあれば空でないこともある。それは公理にはならない。


2021/01/31日
・validについて考えている
　なにかFactとそれ以外のように、真であることの確実さが外から指定された世界なのかも。
　何を確実な真であると考えるのか

・(1) L1 v L2 v αで、mergeしてσ12=<L1:L2>から(2)L1σ12 v ασ12を作ってしまうと
　でてこない証明があるような気がする。
　∃σ1 = <L1:L1'>とσ2 = <L2:L2'>として、¬<L1σ1:L2σ2>としたとき
　{L1',L2',(1)}からασ1σ2はでてくるが、
　それは(2)のインスタンスではない。

・goallistは*goallist*化でよいのでは?
・input clausesのreduceをprover-gtrailに移動
・proverのstatisticsで#validが0になっているのはおかしい。prover-gtrail
  summaryはただしそう。gathercontraが仕分けできていない。isvalidの問題か
  ★prover-gtの中で、gathercontraが返すvalidの数を数えてるが、
  goallistにはvalidは登録されていないので、これからvalidの数はわからない。

　summaryの前で、*clist*に対してgathercontraを実行するように変更した。

・play-prover-gtrailの中で
  (when nids (push nid nids))
　は必要なのか? nidsはreturnしていないので

・merge001.kqcで、goalを1にしたときはproof 1個はいいが、goalを5にしたときできる
  play-prover-gt-mer001.lisp
  goalsを1,5としたとき、c11がc1を使った[]
　c12,c13,c14,c15は5の子供[]
   (a,a), (a,b), (b,b), (b,a)の組み合わせを全部やっているので、
　　すべてのproofをみつけているらしい。

・play-prover-gt.lisp run all prover-gt-*.lisp for simple test for no aborts.
  
・clear-atoms関係の関数群は未整理。優先度低いだろう。

・clear-all-atomsを作った。
　atomのbindingを消すのは makunbound

 ・playしてclear-allしてもう一度playすると、inputclauseのcidはよいが
　resolventのcidが大きい値からはじまる。
  *maxcid*を0にセットした。

  -これでplayを2つにわけて、同じkqcに対してgoalを変えて実行できるようになる。
　　あと一歩

・この修正が正しいのかどうか・・・
  1) パラメタが増えると、clear-all-atomsも修正が必要
　　　まとめて初期化する関数を作ればよいのか?


2021/01/30土
・print-proof0をみなおした。おかしいのは(terpri t)で改行が出力されていないようだ。
　(terpri t)を(format t "~%")に変更たら思った通りに表示された。
　terpriについて勘違いしているらしい
　Tでなく*standard-output*にするべきだった

・kqcを作る
 1) sem002.kqcは、sem001.kqcを述語1種類にしたもので、
　　正しく[]とvalidがでている。
　　書き方として、factに+R(1,1)などと書いているが、
    proofとしては+R(1,1)は矛盾してvalidになる。
　　Factと呼ぶのもおかしいのかも。
　　kqcでは矛盾となり、FactではないということをValidとして表現しているのかも。

　　つまり、MLで観察した+P(1,1)は、KQCの体系上は正しくないので「矛盾」になる。
★★　　これを使って「懐中電灯」の「故障」がわかるかもしれない。

 2) sem003.kqc は実行可能なリテラルだけで書いたもの
　　正しく判別している。実行可能なリテラルだけのncも書いて良い。

・今のplay-prover-gt-*.lispは無駄が大きい。どうしたものか。
   kqcのloadまでは同じなので1つにしたい。
　 (play-prover-gtrail1)でgoalを指定し、kqcファイルの読み込みまでしているからだめなのだ。

　 読み込みとproverの実行を分離する。

　　本来それはprover-gtrailなのだが、inputのreduceをする部分がplay-prover-gtrailにはいっていて
　　分けられなくなっている。

　　だから、prover-gtrailにreduceの部分を移動する。そうすると、goallistをいろいろ変えて
    proverが実行できる。

　　そのためにはすでに実行したprover-gtrailの痕跡を消せないといけない。
　　消すというよりsave/loadがよく、ファイルへの退避でなくlistへの退避ができるようにしたい。

　　(gather-allinf)でlist化できる。
    (deploy-atoms)でもどせる。


・save/loadをlist化できるようにする。
・clear-atomを作らないといけないかな

・これの優先順位は低い。なくても実験できるから・・・





2021/01/27水
・validの扱いを変えた。property :VALID=Tにした。
　setcidでnameは:reduceにし、isvalidはそれをみるようにした。
・不要な関数はコメントにした
　print-proof, fullproof
  ccode, pcodeは動いていないまま

・だいぶファイル構成が雑になってきた。整理が必要。
  dump-clause系はprintにまとまっているが
　print-*系はprintとproofに分散している
  print-proof0はproofにのみあるが、print-literal0, print-clause0はproofにあるのに
  print-literal, print-clauseはprint

  baseに
  setlid, setcidはcid, lidの構造としてのpropを設定する
　validは別関数にしている。

　いろいろあるので、おちついたらするか・・・

・

2021/01/26火
・sem001で3つともvalidというのがおかしい。
  valid clauseの定義がおかしかった。
　proof の pairのところが reduceならflids, validならtlidsになる。
　その区別ができていなかった。
　nameをvalidにするのには意味があった。
 　と考えて、そのように修正した。

2021/01/25月
・listcontraからvalidをけし、listvalidをつくる
　あるいはcontraとvalidのlistを返すようにする
・print-proof0のインデントの微調整した
　改行が余分にはいるような気がする。

2021/01/24日
・ml1002の確認と、他のmlをみてみる。julia班との比較。をする
・print-proof0を少し修正。みためだけ。
・fullproofはresolutionしかでないし、print-proofは面倒みない。
・(listcontra)作成。これによる手順
　(prover実行)
  (listcontra) 矛盾のcidがわかる
　(print-proof0 cid) 証明を見る
・inのうしろにclauseが表示されないのはなぜ?
・print-proof0が思ったように表示できない。
　literal表示したあとclauseがでないとか・・・

・juliaのML cnfをみていると、
・semantx reduce のテストようkqc　seman/sem001.kqc作成
　　3つのcontraができていて、1つはvalidなのにcontraだということになっている。
　　どうするかな


2021/01/23土
・print-proof*で、インデントつけたほうがよいかも。
　indentをincrementしてその数だけ左側に空白いれるのでよいか?
・今日はindentで終わりそう。
・print-proof も修正した。fullproofは修正不要。
　↑は1literalの後それのcidのproofを表示するときindentがなくなる・・・?
・fullproofはresolutionしかでない
・pinfofについては、どうなるべきか考えないといけない。

2021/01/22金
・julia版のml002.cnfをkqcに書き換えてみる。
・play-prover-gt-ml002.lispを作成
・[]がでるのは確認。C24が1[]
・情報の流れは未確認11:w


2021/01/22木
・proofをclassで作った場合、シリアライズをどうするか問題になりそう。
　そこで考えた方法。
　まず、proofはmacroのformにして計算しない形で保存する。たとえば
　　`(make-proof ,cid ,vars ,sigma ,left ,right)

　saveやloadするときは、そのままS式として出力する。

　printするときはevalして、proof objectにしてから処理する。
　これが有効なのは、proof objectにする処理がprintのときしかないから。
　proofを作るときはか過去の証明をみてなんとかしないと考えているから。
　どうかな?



2021/01/119火
・reduceでflidsが削除されていなかったのでfixした

2021/01/18月
・lidのつけかえはできた。make-lids-from-lidsというものを作ったが大丈夫か?
・他の部分への影響がわからないので、proverで確認したい。
・oppoがない場合でもreduce-by-semantixはありうる。???
・play-prover-gt-presem.lisp　は、preseman.kqcを読み込む。
　parameterを変えるとすこしできるので制御はよいみたい。
  validのresolventも*clist*にはいっているのはOK

X presem.lispで、C7,C8でflidsが消えていない。なぜ??? 


2021/01/17日
・まず、proof関係のprintなどが動かなくなることは覚悟して、修正していくか。

・P(x)P(y)α⇨P(x)α{y←x}というルールは、全情報を取り出すという観点からは不要ではないか。
　このルールを適用しないとできない証明はあるが、その証明の代替があるのではないか。

・テスト用のkqcを作成。inputとresolutionの2パターン。inputのほうは、[]にならないので
　読み込み完了後の結果を確認するためのもの(
  data/seman/{pre-reduce.kqc test-recude.kqc}
* pre-reduce.kqcで、falseを消したときは新しいcidを作る。そのときlidはrenameが必要★これ未
  validについては、cidを作っているが、bodyやproofのlidは親のまま。
　　それでいいはず。つまり、validのときはlidはそのように扱う・・・例外になるのか・・・
    (make-lids cid (bodyof res))でbodyのrenameできる・・・
    ただしpropertyは正しく設定されるだろうか?

2021/01/16土
・ブレストしてみる
・itoにmultiple-equalを追加。multiple-value-listが使えることがわかった
・apply-semantx-id (prover-gtrail.lisp)でコンパイルエラー多数。
　コメント担っていたapply-semantxでエラーがでていたような気がする。
　とりあえずito-rubbish-gtrail.lispでエラーなし
　itoを書くとき、予想値をformで書いてはいけない。macroでevalしていないので・・
　そもそも、予想値は直値で書くべき? 相対的な正しさでよければformでもよい。
　ちょっとなやましい。ito-multiple-equal-relativeみたいな関数があってもよいのか?


2021/01/12火
・apply-semantx(semantx.lisp)とapply-semantx-id(gtrail.lisp)が同じインターフェース
　gtrail.lispではpeval-idを使っているが、まとめてsenamtx.lispにまかせたほうがよさそ1う
・itoにito-multiple-equalを追加したが、どこで修正したのかわからなくなった。
　
2021/01/10日
・apply-semantxは作った。まだpropertyは未。proofも未。
  peval-idは作ったが、e=(peval e)をするためにはmapした後の形が欲しいので、peval-idは使わない。
　あるいは、mapした後のeで比較するか。

2021/01/09土
・pevalによってliteralを消したりclauseをvalidと判定するのはapply-semantixと呼ぼう

2021/01/08金
・<(+ P (+ x 2) x):(- P (+ 3 1) 2)>はpevalでunifyしない。
　<(+ P 4 2):(- P (+ x 2) x)> はできそうだが、しない。
  <4:(+ 2 2)>がunifiableであるかどうかは考えない。
  (+ = 2 2)というliteralのみ計算する。
・<4:(+ 2 2)>がunifiableというのはあるかも。


2021/01/06水
・github pageを作ってみた
  docs/index.md

2021/01/04月
・resetを考える

2021/01/03日
・save&loadの検討(aboutsaveload.txt)
・pevalルールの検討(aboutpeval.txt)
・propertyなどのclear関数
  toolsに、propertyとbindingを設定およびremoveする関数が定義されていた。
　これは別のファイルに分けよう。toolsはrubbishのito用関数だから
  makunboundはcommonlispの関数
・load-rubbish.lispに(load "rubbish-prover-gtrail.load")を追加した
・play-prover*をしたあとで
　 (save-rubbish "mine.save")でセーブし
　 (load-rubbish "mine.save")でロードする。
　今はatom系だけ
・loadして続きを実行するのに必要なのは?
  *goallist*と*num-of-trials*
  *goallist*はなかったので追加し、goallistを設定した。ということは、*goallist*だけでいいかも。
・save,loadで他の変数と同じ処理にするため、*rubbish-state*に上記2つの変数をいれて、
　gather-atomsの引数のリストにこれを追加した。

・peval step 考え中。 

2021/01/02土
・pevalを(ignore-errors)でなく(handler-case)で書き直した。
　Recipesのignore-errorsの節の冒頭に書いてあったコードがまさにこれ用だと気づいた
・save-load
・peval-id をresolve-idの後に行うようにする。
　ただし、peval-idはoptionにする
・resolventのopposを登録するようにしたらどうなるか
・同的にfactがふえていく場合
　1. clauseの追加≈Literalの追加≈述語記号の追加
　　　どこまでやるか?
　2. 変数が無限要素のドメイン上を走るとすると、もはや証明手続きでは証明できまい
　　　メタな仕組みが保証(近似)する枠組みになる
　3. ルールとして与えた命題が変数を含むと、その変数にすべての項を代入した式が正しいかどうかという問題になる。
　　　だから、Factに対し変数を含むルールが正しいかどうかを証明することはできない。
　　　外側から、与えられれば証明する責任がなくなる
　　　その場合の証明の意味はなにか? 関係のない命題も生み出される
  4. -P(x,y)+P(d(x),f(x,y))を+P(x, F(x))で代用される仕組み。
     +P(x,F(x))はgivenでよい。
　　　これはdomainと関数の結びつける



2020/12/31木
・julia版のcnfにはなにがあるか
　- 回路の故障箇所をみつける circ*.cnf
　- MLはdeep learningとの連携について調べようとして、結局、確率引数とって何をしているかを判定する。
　- to?.cnfは、factに対してruleを予想しても一般的なルールとして証明はできないという例。
　　たとえば、全順序の公理は有限のfactからは証明できない。
　- あと、pevalを使う例が多いので、今はむり。たとえば、確率を含む述語とか。
・pevalできた(Recipes 参考)
  - 値がNILになる式だと、evalされない・・・
    値がnilのときは、:nilを返して、エラーのnilと区別するようにした。
  - peval は引数が '(+ 1 ww) みたいなの。mperalは引数にしきそのものを書ける(mpearl (+ 1 www)) のように
　　proverの中ではpevalを使うだろう。名前の付け方は迷う。
・print-proofで見ると、renameの痕跡も残っている。新しいルールを追加しなくてもよいような・
・pevalでliteralを消したら、新しいcidができて、ruleは:pevalで、親は1つのclauseで、
　消えるのはpairではない。evalした値を残すか? (- = 2 (+ 1 1))は消えるリテラル。
　- (+ = 2 (+ 1 1))はclauseが消える。+TはTなので。・・・。つまりgoalからこのclauseを消す。
　- (- = 2 (+ 1 4))はclauseが消える。-FはTなので。
　- (- = 2 (+ 1 1))はliteralが消える。-TはFなので。
　- (+ = 2 (+ 1 3))はliteralが消える。+FはFなので。

　ルール:pevalでは、literalが消えるとき、proofにそれは残るが、
　validになってgoalが取り除かれるときは、proofに残らない。

・itoの全ito実行のコメントは大文字にするようにした

2020/12/30水
・statisticsとして情報をあつめる。
  contraの数
　proof stepの最大値
　input clause 数
  rsolvent数
  input literal数
　literal数
　input literalに対するインスタンスliteralの数
　　同じolidを持つlidの数

★ 同じ環境で複数のkqcを処理できないのが面倒くさいな
　property listを使っているからしかたがないが、それを変更するにはどうするか

　property listのかわりになるものを導入する。hash

・mgaia.kqcをmagia.cnfから作った。
　あんまり意味はない。RDBと同じようなもの。
　ruleは使われていない。
  print-proofすると、最終的な結果は見えるので情報獲得の処理はなくてもよかった。
　1stepの証明が2つとれただけ。
  もうすこし複雑な証明にしたい。

2020/12/29火
・これまでのplay-proverのパターンで1つ関数化する。(play-prover-gtrail names kqcfile)
・play-prover*lispをこの関数を呼ぶように変更
・gt5,6,7を追加 
   5     : 2clauses goal
   6loop : -P+P パターン 無限に証明が生成されるが[]は0個。inputが3の場合。
   7loop : fact introで[]が無限にできてout。必要なものが見つかっているのか? inputが3の場合。
   8loop : input もxにした場合。[]は1つだけ。つまり1(0 1)だけ。

何をみれば、求めるものがみつかるのだろうか。
7loopでは
*  (loop for x in *clist* unless (bodyof x) collect x)
(C26 C24 C22 C20 C18 C16 C14 C12 C10 C8 C6)
* (pinfof 'c6)
((L1-1 L3-1))
* (pinfof 'c8) 
((L4-2 L3-1) (L1-1 L4-1))
* (pinfof 'c10)
((L4-2 L3-1) (L4-2 L4-1) (L1-1 L4-1))
* (pinfof 'c12)
((L4-2 L3-1) (L4-2 L4-1) (L4-2 L4-1) (L1-1 L4-1))
であり、c12はc10と同じだから、ここでsatulatedという感じ。

・正常時にsummaryを出力するようにした。quit時にでないのはどうするか。

・kqcを読み込んで指定されたgoalのrefutation。
　goalの指定はCnでなくname n それ自体にしたい。n -> Cnを作る関数はあったかな。

・proverの最後にsummaryを出力するようにしたが、limit超えの場合だせていない。
  contradictionsは*clist*から作れる
  trailsとproofはまだ作っていないが、globalに計算できるようにしたい。

2020/12/28月
・gt0で実行できたのでcommitした
・logをとると、proof見るよりもわかりやすい
・2stepの例 gt1.kqcも動いた。こちらはxでリテラル間のmguの交換ができている
・3stepsの例 gt2.kqc。[]は思ったようにでた。mguの伝播まではわからない。
・だめなはずの例 vv gt3vv.kqc。[]はできているようだ。順番をかえるとinputでできてしまうのかも
・resolve-idがうまくいっているかの確認用に、mguが複雑に発生する例 gt4.kqc
  gt4で1[]がでるようにしたが、簡単すぎる例ではないか。

・logだけではmguの伝播がよくわからない。print-proofでmguもみなくてはならない。
　そこは何か手段がありそう。

・logprintのprintに違和感があったのでlogshowに変更した

・終了時のgoallistをみたい。 みれるようにした
・prover.lispでpinfofをpindofにタイポしていたので修正した
・prover-gt001.lispで前に作ったprov001.kqcのgoal trail proofできた
・000, 002も動いた。
・prov003.kqcはcontradictionの数が10以上あったので、*max-contradictions* = 20で終了した
  これは000,002を実行した後に動かしたからだった。[]が累積していたので10をこえていた。
　正しい結果かどうかは検討が必要。
  複数リテラる1goalの例。
・prov004.kqcも[]がでた。正しい結果かどうかは検討が必要。
  複数リテラる1goalの例。

・provvv02c.kqcは[]が1つできた。
・provvv01c.kqcは[]が1つできた。

前に作ったkqcの意味を確認する必要がある。

・pevalの実行中errorを扱う方法はRecipesで判明した
・itoを見直すと定数aに対して実行する意味がない。itoみなおし
　errorは補足できるがundefinedがつかまらないらしい。signalではだめ・・・

・print-proof0がちゃんと木で表示していないので、よくわからない。
　kqcの補足を見れば確認できるかもしれない。02aと02cがあるが、どっちか?

・clsueof がcidからraw だったり、関数名の付け方に難あり

・FactはRDBのテーブルみたいなもの。
・SQLはそこからデータを取り出す式になっているが、それはgoalを書くようなものか。
　SQLエンジンが、結果を得るのに推論をしているのか、単なる計算をしているのかは知らない。
  SQL文が、ルールを手続き的に書いているのではないかという気はする。
　joinは2つのclauseが、unifyした結果、異なる変数に同じ値を代入することにより消えたり残ったりする
　ことを書いている場合のかなと思う。


2020/12/27日
・pevalをつくりかけているが、commonlispのconditionを使ってエラーをキャッちする
　方法がまだわかっていない。
・手間取りそうなので、先にprover-gtを作ろうと思う
・(make-lsymlist)をリファクタリング。1つのlidについて処理する(pushlsym)を追加した。
　これでresolventのlid-lsymの登録はできる。listは*lsymlist*
・とはいえ、まず初めに、これを使わずinput literalだけでやってみる。
　(rubbish-prover-gtrail.lisp)が関数で使い方は
　(play-prover-gt0.lisp)のとおり
　1step証明だけのprov0.kqcでgoal=(c1)にして3つの証明を求められた

* (load "play-prover-gt0.lisp")
* (run)
* (pinfof 'c17)
((L1-1 L3-1))
* (print-proof 'c17)

 C17 [] RESOLUTION (X.432) <- (B) : <L1-1:L3-1> 
L1-1 (X.432).(- P X.432)  input C1 (L1-1)
L3-1 ().(+ P B)  in  input C3 (L3-1)

mguもみつかっている。X<-B


2020/12/20日
・lsymにはolidしかはいっていない。resolventも追加する必要がある。
・たとえば、lidのpsymとrawliteralのpsymはどちらもpsymofで参照したいか。
　今は、psymoflidとpsymofみたいになっている。
　ということは、resolutionの相手は全部input clauseということになり、VVができない。
  では、resolventのlidもlsymに追加すべきか。
　その場合の問題点
　　- 世界にひとつしかaxiom setはないと考えている。(そもそもvalueに設定しているとはそういうこと)
　　- それはつまり、factによって変化するaxiom setの扱いをどうするか
　　　・ひとつは、factと矛盾するclauseをopposから削除する方法。lsymのlidsから消す。それは可能か?
　　　　あるclauseは、そしてそのbodyのlidはどういう条件で消しうるのか。
　　　・または、opposの情報をそれぞれの可能世界で分けるという方法
　　　　今のようにlsymのvalueにlidのリストを持たせるのでなく、可能世界ごとに対応リストを管理する。
　　　　可能世界はどのように定義できるか
・pevalを実装しよう。他のと独立な機能である。そのためにはcommonlisp の condition systemの
　理解が必要な気がする


★termに型を持っていないからこうなる。atomとs式で切り分けられるなら、generic でできるか? 

2020/12/19土
・しばらくproverのソースを見ていなかったら、opposとlsym関係の処理のつながりが
　わからなくなっている。
　同じlsymのlidはlsymのvalueではなかったか
　opposをとるのはできている
　lidのlsymの先頭がなぜかNILニナッテイル???
　(make-lsymlist)でlsymにそのlidがはいる。

・resolventは追加されるのか?
  olidにその子のlidをもたせるのはいかがなものか


2020/12/17木
検討事項
  ・lidのリストかcidか
　・pevalにはどういうlidをつけるか。消えるからいらないか。
　　ruleは:pevalでいいが、新しいcidをつけるか。その場合、lidの増加あり


2020/12/13日
・(make-pcode l1 l2)を作成。これはresolutionをする前にpcodeを調べて、そのresolutionが
　必要かどうかを確かめるためのもの。

・goal-trail班のproverを作り始める

2020/12/12土
・rubbish-log.lispを作成。timeはessential.lisp。
　(resolve-id)でfunificationの結果をlogにとるように修正した。
  それらしいものはでるようになった。
　いまはlogをとらないというオプションがない。
　logをとらないとき、その処理にかかる時間が無視できるようになるとうれしい。
・log関係の関数を作った
　(logon)(logoff)(logstate)
  (clearlog) (printlog)

2020/12/11金
・やること
　1) unificationをtraceしてみる。
　2) logとして(時刻 LLid RLid mgu|FAIL)のlistにする。carのほうが新しい。
　3) unificationするとこのlogを吐くようにする
　4) 制御せずにresolventをつくつていく。goal方式。
　5) limitは、
　　- []の数
　　- proofのstep数
　　- proofの段数
　　- clauseの数=resolventの数
　　- unificationの数(failも含む)

・proofの書き方案
い)
  P -PP -P
  1  23  4

1:2/3:4
1:2/3:2/3:2/3:4

3:2が反復

みたいな書き方をしてはどうか。
n:mはリテラルペアでresolution stepを表す。
/は横線のかわり

ろ) 関節ルーブのある例
 P -PQ -QR -RP -P
 1  23  45  67  8

1:2/3:4/5:6/7:8
1:2/3:4/5:6/7:2/3:4/5:6/7:2/3:4/5:6/7:8

3:4/5:6/7:2/が反復


は) 分岐
 P -PQ -QR -RP -QS  -S R -P
 1  23  45  67  89  1011 12

1:2/3:4/5:6/7:12
1:2/3:4/5:6/7:2/3:4/5:6/7:12
こうとも書ける 1:2/3:4/5:6/7:2/3:-Q

1:2/3:8/9:10/11:6/7:12
1:2/3:8/9:10/11:6/7:2/3:-Q


★★ ★★ ★★ ★★ パターンにすると

こういうのはくみあわせが生じる

A=(3:4/5:6/)
1:2/A/7:12
1:2/A/7:2/A/7:12
1:2/A/7:2/A/7:2/A/7:12

B=(:2/3:4/5:6/7)
1B:12
1BBB...B:12
という証明パターンになる。
うれしいか?

B=(3:8/9:10/11:6)
1:2/B/

ここでやっているのは、グラフを1次元表現にしていること。
グラフではなくパス



2020/12/09水
・resolventを作る前に、そのresolventのpcodeが*pcodepool*にあったら、作るのやめる、ようにした
・pcodeが同じでも同じresolventとは言えない。olidのpairが同じ場合、どちらかがインスタンスになり
　同一ではないということがある。
　だが、証明の基本構造はpcodeが一致すれば同じと考えられる。
　そこで、pcodeが同じものを作らなくてもよいのではないか?

　すくなくともFactはpcodeで一致する。ルールの適用がかわるだけ。★ ★　★　★　★　★　★　★　　

2020/12/06日
・vvの形の証明がほしいのでつくる
・fullproofが同じであること
　? ある2つの証明木が、構造によらずすべてのpairが同じなら、同じといえるか?
　　つまり[]にいたるmguの合計(積?)は同じか?
　　もしそうなら、木構造をのぞき、mguのリスト/集合がその証明木の情報といえる。

・fullproofはそれらしいS-式を出すようになった。cidレベル。
  lidも追加してみたが、これをみると、cidは不要な気がしてきた。
　ruleも出してみたが、これは証明の情報としてはいらないかも。mguだけあればよい。
　cidのかわりにbodyにした。消えていないlidがあとで消されるが、そのときのlidは名前がかわってるので
　このlistがあれば復元可能という意味で完全ではないか。
　* play-provervv02.lispを作ってみて、これは自明な気がしてきた。
　　Πmguが同じなら同じ情報なのは自明。
　　もしも証明図が違っていて同じラ∪mguになったら同じ。意味のないことを言っている。

★　定義として、同じpair集合であることを情報として等置な証明図であるという。でよいのでは。

・nameが指定されなければ自動で番号を振るかどうか。振る必要がないような気がしてきた。

todo kqc に関数を定義する約束にする。
　　(info)が、みているファイルや目的を示す。
    とはいえ、文字列で書いたりするのはめんどうだ。どうするか.
    (file)と(info)。めんどう。やめ

　
2020/12/05土
・prover goalベースを作る。
　入力のaxiomsをなんと名付けるか　core, base, 
　制限事項: 
  1) 条件
　　　(1) goalは1つのclauseのみ
　　　(2)
  2) 補足機能 情報抽出に必要そうな機能
　　　(1) pevalの実装
　　　(2) 変数名に!X:出力, ?Z:入力をゆるす。
　　　(3) pinfoでolid版とlid版
　　　
　3) 確認すること
　　　(1) clauseの左右を変えても同じ結果になる
　　　(2) liteal in clauseの順番を変えても同じ結果になる

　4) goalから派生するresolventsのみトレースする
　　　A  : base of clauses1
　　　GS : set of goals
　　　G0 : initial goal

　　　(G0) -> (G1 G2 G3)
　　　G1のPを消すtry(Pの選択はliteral順による)
　　　　G1 -> (G1,1 G1,2 G1,3)　G1.1, G1.2にはPはないがG1.3にはPが残っているとする。相手が-P,P,αのような場合

　　　　G1,G2,G3について、それぞれの先頭リテラルを消そうとすると、残る述語記号Pについてばらばらになる。
　　　　消えない場合もあるので、それは必ずおきる・・・

　　　　G1,G2,G3の全部について同じPを消す試みをすると(G1.* G2.* G3.*)順は変えるとして。
　　　　述語の消え方は統一できる。残るのもあるけど。

　　　　結局: AからPを消そうとする方法か。A/P-, A/P+:前者はPが消えたclauseの集合。後者はPを適用したがPが残っている。
　　　　　　もともとPがなかったclauseはA|P と書くか。

　　　　　　A|P A/P- にはPはない。+Pも-Pも。
　　　　　　A/+P にはPは残っている。


★ clauseのolidとlid
　ccodeとcanonic
  bodyofではない?

・ proofをS式で取り出せるようにした。いままではprint-proof[0]しかなかった

　　　


・package化。proverを作るのに必要な部分を1つのパッケージにする。
　　・代入
　　・unification
　　・resolve
　　・resolve-id
　　・proof

　　・prover


　

2020/11/29日
・環境のsave/restoreはどうやればできるかを考える
・proverの作り方について検討する
　総当たりというのは、無意味な気がしてしまう。clauseの組み合わせという考え方(CC)
　述語記号を消していくという考え方(PC)
・20201024のtodo。readkqc*を作る
・play-rubbish-kqcio.lispをつくり、現状のすべてのkqcをreadekqcしてみた。確認よう
・するとreadekqcでreadefileは動くが、そこに(eval (define myadd ...))としたあと(eval (myadd 2 3))とすると
　　myaddがundefinedになる。
  これは書き方が間違っていてた。(eval '(defun myadd (x y) (+ x y)))でうごいた。
　evalを書かずそのまま書くような方法が必要か? evalでなくeでもいいけど
 


2020/11/28土
・make-lsymtolids をmake-lsymlistにした。make-psymslistも作成。
・名前のつけかたを考えよう。lsymofがどのような型からの変換/抽出なのかを示した。


2020/11/23月
・dump-clausesで引数がないとき*clist*にする関数dump-clausexを作った
　機能のわりに苦労してしまった。macroがよくわかっていない
・play-prover0[1234].lispとkqc/provers/prov00[1234].kqcを追加した
・(lidof cid i) = (nth i-1 (bodyof cid))を作った。prover*.lispをわかりやすく書くため

・prover02.lispのr30-c26でFAILになる。(resolve-id 'l30-1 'l26-1) 順番は逆でも同じ
* (print-literal 'l30-1)
L30-1 ().(+ E A A) 
* (print-literal 'l26-1)
L26-1 (X.422).(- E X.422 X.422) 

なぜ?
(- E x x)のように同じ変数だからか??

* (defparameter cc70 (readskqc "((71 (x) (+ P x x)) (72 () (- P a a)))"))
CC70
* 
cc70            
(C71 C72)
* (dump-clausex cc70)
C71=(VARS (X.433) NAME 71)
 L71-1 (+ P X.433 X.433) = (OLID L71-1 PLID NIL CID C71)
C72=(VARS NIL NAME 72)
 L72-1 (- P A A) = (OLID L72-1 PLID NIL CID C72)
NIL
* (resolve-id 'l71-1 'l72-1)
:FAIL

ということらしい

ぜんぜんできていない。つかれた

*   (intend-equal "015a unifications" '((x . a)) (unifications '(x) '(f x x) '(f a a)))

 015a unifications: Ito Failed at NIL
   Expression: (UNIFICATIONS '(X) '(F X X) '(F A A))
    Intented ((X . A))
    Evaluated: NO
NIL

だった。
ito-rubbish-unif.lispにこのケースを追加した。"015a unifications" 
ちなみに、(f x x)と(f y (g a))みたいのはOKだった


★原因と修正内容
原因は、unificの前提である d1!=d2が、unificのrecursionの中では正しくない場合があること。
(f x x), (f a a) のときにおきる。2つめのx, aがa,aになる。

unificsの修正 : 先頭でd1とd2が等しいとき、その時点までの代入mをそのまま返すようにした
makesubsubsの修正: 最初に同じ場合、sを返すようにした。sはその時点までの代入)

ito-rubbish-unif.lispにケースを追加 上の15aの引数の順番を逆にした15b追加,
ito-rubbish-resoid.lispに追加



2020/11/22日
・ccodeの役割はなに?
　clause setに追加するとき、除外するのはccodeが同じで、instanceになっているもののみ。
　あやしい
・実験　ccodeの分布・・・証明の順番でccodeはかわるからよくない
　pcodeで考えるべきかも
・proofはlidがみたいのでsigをはずしてprint-proof0とし
　olidの木はprint-otreeという名前にした
・print-proof(0)の表示がすこしおかしくて、cidが右になっていたりbodyがなかったり
  bodyは追加してみた

・make-lsymtolids がLsymbolにそれを持つlidのリストを設定する
　lsymof はlidからlsymbolをつくる
　これでいききできる

★ make-lsymtolidsがlidsのlist-listを返すけれど、lsymbolのリストがよくないか???

・play-rubbish-prover.lispにはいま3つのaxiom集合を定義しているが、環境がまざるのでわけよう
　そうすると微妙な違いそれぞれについて1つのファイルを作ることになりそう。
　別のディレクトリにまとめておこう。kqcでなくasetみたいな

　テスト用だからそれでいいのかkqcを作ったほうがよいのか

　いまはproofを手で作っているので、それはlispファイル(play----のような)が必要
　データはkqcでよさそ
  play-prover[123].lisp -> kqc/provers/prov00[123].kqc
とした
  lispの中身はplay-rubbish-prover.lispのまま。nameも1, 20, 40はじまりになっている

・

2020/11/21土
・cmarkerをccodeに変更
・ito-rubbish-proverのあとplay-rubbish-proverを実行するとcidがずれるのでbreakする
　playは単独で実行すべき
・play-rubbish-prover.lispを整理した。cidが重複していたので、番号をつけかえた。
・ccodeをソートしたolidのlistをそのままstringにしてみた sccode 
　ccodeの場合は()があるかないかだけの違い
　proofについてcodeを考えてみていて、pcodeはこういうふうに作ればいいのではないかと思う
　ただしproofの場合、sortすると順番が狂う・・・それはそれでよいかな
  pcodeはソートしない。S-expのソートがなになのかわからないので。listとatomのリストのソートか・・・
  atomとpairを順番にstringにして、それらのリストのアルファベット順のソートではどうかな
　その場合pinfofとは違うなにかになる。
・ソートしたものがspcode
・codeのまとめ

ccodeは1clauseのみのolid表現
pcodeはproofなので、そのclauseのよってたつすべてのolid表現になっている
pinfof系は、文字列でなくS-式で表している
proofをlistにすると(さらにsortするということは)　証明の順番の情報は落としている

関数　  文字列　
ccode   cidのbodyのsorted list
scode   cidのccodeの文字列

pcode   cidのproofの文字列 without sort
spcode  cidのproofのsorted 文字列

pinfof  cidのproofのpairのlist without sorted
spinfof cidのproofのpairの文字列のsorted list(S-式)

例)
* (proofof 'c50)
(:RESOLUTION (W.449 U.450 U.452 X.453 X.437 Y.438)
 (Y.459 U.455 X.458 X.457 X.458 Y.459) (L49-1 L44-1))
* (ccode 'c50)
(L42-2 L44-2)
* (sccode 'c50)
"(L42-2 L44-2)"

* (pcode 'c50)
"((L41-3 L44-1) (L41-1 L43-1) (L41-2 L42-1))"
* (spcode 'c50)
"(L41-1 L43-1 L41-2 L42-1 L41-3 L44-1)"

 
* (pinfof 'c50)
((L41-3 L44-1) (L41-1 L43-1) (L41-2 L42-1))
* (spinfof 'c50)
("L41-3 L44-1" "L41-1 L43-1" "L41-2 L42-1")

・まとめ
　あるcidについて、proofには、そこにいたるすべてのolidがあり
 bodyには残っているolidがある
　だからそのcidについてのすべてがそこにあるように思う。

* (pinfof 'c50)
((L41-3 L44-1) (L41-1 L43-1) (L41-2 L42-1))
* (ccode 'c50)
(L42-2 L44-2)
* (bodyof 'c50)
(L50-1 L50-2)

* (print-proof0 'c50)
C50 RESOLUTION : <L41-3:L44-1> 
L49-1 (W.449 U.450 U.452 X.453).(+ C U.452 W.449) C49 RESOLUTION : <L41-1:L43-1> 
L48-1 (X.440 W.443 U.444 W.445 U.446 X.447).(+ A X.440 W.445) C48 RESOLUTION : <L41-2:L42-1> 
L41-2 (X.429 Y.430 Z.431 W.432 U.433).(+ B Y.430 Z.431)  input C41
L42-1 (W.434 U.435 X.436).(- B W.434 U.435)  in  input C42
L43-1 ().(- A A B)  in  input C43
L44-1 (X.437 Y.438).(- C X.437 Y.438)  in  input C44


2020/11/18水
・olidの変数あり意図を書いてみた

・olidの並びをcmarker(clause marker) と呼ぶ
・その順序で並び替えたclauseのbodyはcanonicと呼ぼうかと思ったが、どう使うのかな

・cmarkerは、clauseの識別子で、renameを除いて一意になってほしいが、instanceなどの可能性はある。
  同じcmarkerを持つ2つのclause C1,C2はliteralは同じ順番なのでその順番でliteralの比較ができ
　それぞれのliteralはσがあって Li・σ = Lj・σになる
　インスタンスになるとは限らないのが難点
　少なくとも、cmarkerが違えば同じにならないのと、literalはuniqueになるのかな。
　同じolidのものが複数あるとuniqueではないような・・・

　ここはもうすこし考えよう

・やりたいことは、集合a∈Aを高速に判定したい。
　同じclauseをいくつも作ることは悪なので、それを除外したい。
　resolvent rができたとき、r∈Rかどうかを高速に判定したい。
　cmarkerが同じものがないならば、残しても良い。ということはいえる。
　cmarkerが同じとき、どうするか・・・








2020/11/17火
・OLIDはinput lidではなかっただろうか。作ったときのlidになっているような・・・
　O=original?
　親のpidがあればそれに設定しているので、この解釈でただしいはずなのだが、bugぽい
　意図から確認する
　resolve-idのところが間違っているのではないか。意図かけるか??
  修正したが意図を確認するためには、もうすこし長い証明が必要。

・plidはひとつ前の親のlidなので正しい(P=parent)

・setlidの判定が無駄なのでplidに変更。

・olidの意図を書いた。

・geneof でClauseのげのむを定義した
　これを使ってclauseの同一性を調べられるかどうか

2020/11/15日
・(load "ito-rubbish-tools.lisp")  ;;これはrubbish専用のITO helperだから、ファイル名ちょっと違うかも
　　rubbish-itohelper.lispみたいなほうがよいか
・lidからoppoのlidsをもとめるfind-oppolids作成。
・サンプルkqc追加

2020/11/14土
・kqcで他のkqcを読み込めるようにした。(readekqc "another.kqc")と書く
　reqdekqcは読み込まれたファイルの中に書いてあると再帰的に実行する。
　ということは、親ファイルを書くと無限ループになる。気をつけろ!!
　観察コードはplay-rubbish-kqcio.lisp

・同じnameのclauseを作ると*clist*にcidが重複する
　pushをpushnewに変更した

・lsymにllidのリストを設定する関数をつくった(lsymlist)

・lsymからopposを作る関数のことを考えるとlsymを(sign . psym)にしたほうが楽だったかも
　-Pから+P、+Pから-Pを作るの時間かかる。(sign . psym)なら((oppos sign) . psym)なので・・・

2020/11/11水
[julia版機能をとりこむ]
・literalがevalできたらevalする。できたらというのは計算してT/NILがきまったらといういみ
・kqcで他のkqcを読み込めるようにする。(include "another.kqc")とかのeval


2020/11/08日
・ito-rubbish-tools.lispからresoidの部分をけして、ito-resoid.lispを書き換えようとおもったが
　rubbish-tools.lispの意図という意味ではito-rubbish-tools.lispは全部必要そうなので残した。
・noraunバージョンはもういらないのかなと思うが、はっきりしない。
・print-proofで[]を表示するようにした。[]でないときはclause全体がみえていない。次の段でliteralのみ。
　みせかたを考え直すか。木の表現までは考えていないが・・・役に立つような表現があればつくろう。

2020/11/07土
・rubbish-tools: 変数と元の変数を同一視するため、prefixとして見る比較を作った
　varsとmgu=(vars.sigma)はいいが、termの比較は中をみていかなくてはならない。
　sigmaの場合はいいがと書いたが、そこもtermなので中を見る必要がある。と思ったが
　sigmaの場合は特にvarsが必要なさそう。

　2つのterm eとtで、変数を同一視して同じだとみなすばあい
　(issame vars e t)で、varsはeの変数を指定する

・toolsをito baseで整理した。
　toolsを使ってito-resoid.lispを書き直すべき。　もう遅くなったので明日にでも・・・

・手順と現状
　(load "ito-rubbish.lisp")でtoolsも読み込む。
　ito-toolsにはresoidのテストも含まれているので整理が必要

2020/11/03火
・ito-rubbish-tools.lispでintend-ru-clause, intend-ru-literalを変更。
　property名を明記するようにした。というか:rest plistをやめた。
　&rest にすると何故か引数の数が正しくないエラーになる。
　clauseとliteralのplistのkeyは固定でよいと思う。ならばkeyをつける必要もないような気がするが
　それはpropertyなので順番が違うこともあるかもしれないということでキーにしている。あとづけ

・learn-macro.lispに&keyつけた

★まだ、termの変数バリエーションはやっていない。
　　(issameterm vars t1 t2)　みたいなのか
　　やった
　　varsみて、prefixかどうか判定した
　基本的にはよさそう

・追加
　　(remove-atom x) unboundにする
　　(dump-clauses ...)は、unboundのlidとかcidは中身をみにいかないようにした

・こういうのはどうか
　root がidで
　そこからたどるpropertyを指定して
　最終的な値を確認する

　(path 'c54 

・itoにsetupとteardownを指定できるようにしようとito2.lispを作っているが
　ぴんときていない

・resolventのliteralの順番は、lidのアルファベット順にしたらどうか。
* (string<= 'L50-1 'L52-1)
2
* (string<= 'c 'a)
NIL

みたいな関係で
右と左をいれかえるのはまずいか??
 



2020/11/01日
・したいことの整理
　ノートに書いた

・意図の構成
　ito-rubbish.lispというのを作って、cidとかlidの構造に着目したintendはここにおく。
  rubbish固有の意図ライブラリといういみ。

・toolsに作成。
  ito-rubbish-tools.lisp作成。ru-clauseとru-literalは意図とおり


2020/10/31土
🕷 ito-rubbish.lispをするとC1が複数でてくる。中身は同じになっているが、それは後が勝つからではないか。
　　1つの環境でinput以外で同じcidになることは禁止したい。今はどうなのだろうか。

・整理したい
 - make-input-clause
 - make-resolvent

 - clauseと周辺の関係作成
 - 証明情報の設定
　・inputは空証明情報
　・resolventは系譜

 - Lsym = (sign . Psym) => Lid*
　　　　= ±P -> Lid*


・pairingはinLidで指定する。
　これにcidが作用して、cidのlidになる
　という仕組み

・inLidからoppos のinLid*をみつけられる(oppositeかcounterでもよかった)

 - inLid :Lsym -> (sign . Psym)|±Psym => Lid*

もしも、inLidのcidがすべてunitでなかったら、resolutionでは[]はできない
+P+Pみたいのがあったら別・・・

clauseのリテラル数が減らないと[]はでない

*条件(雑)
 1) cidの外側にopposがある
 2) 同じcidの中に同じlsymのlidがある(same sideと呼ぶか)

いずれにせよ、それらのlidのlitが符号を除いてunifiableであることが必要

opposの場合は変数が共有されず、samesideでは共有される。

この条件が雑だというのは、Psymが同じでも、termレベルで失敗することがあるから
厳密には、必要条件


・lidの選択方式
　- cid,index -> lid
　- cid,inlid -> lid

★ ツールボックス　意図を確認するための道具だが証明を作るためには使われない
　だから性能が悪くてもよい

　・あるclause集合からcid, lidの構造を作る
　・作ったcid,lidの構造をクリアする
　・変数の比較(noranで無視した場合の意図を確認するにしても、ranの場合もやってみたい)
    intend-rubはrubbish専用の意図関数。

　　a) (intend-is-prefix prefix rans) ransのプレフィックスがprefixになっている。
　　b) (intend-rub-sameclause cla1 cla2) claはrawclause(つまり全部S-expになっている)
    c) (intend-rub-sameliteral vars lit1 lit2) 
    d) (intend-same-exps v1 e1 v2 e2) e1とe2はv1,v2のrenameによって同等
　　　　　(intend-same-exps '(x1 y1) '(f x1 y1) '(x2 y2) '(f x2 y2))
　　　　　みたいな。意図の場合、x1,y1はprefixだけx,yでよいと思う。
あるいは
    e) (intend-same-exps v1 e1 v2 e2) v1とv2はprefix(.まで)が同じで、e1とe2はv1,v2のrenameによって同等

　ranの変数はtermに染み込んでいることがあるので、same-expsはtermの底まで比較する必要あり。with same

★ちよっとまて、なぜx.になる? x.234ではないのか???
 play-rubbish-resoid.lispの最初のread-kqcだとちゃんと変数に数字がつくので🕷ではないらしい


202/10/29木
・意図にだけ使う関数というものがあると思う
　- Lid-Cidを全体的にセットアップする
　　・input clause
　　・resolvent
　　　かならずしもresolutionをする必要はない
・どのような意図を作るか
　- 全体の構造をまとめて設定できるような関数かマクロを作るのはどうか。
こんなかんじ

setlitとsetclaはマクロ
(setlit l10-3 (- R X.443 Y.444) :OLID L10-3 :PLID NIL :CID C10)))
(setcla c10   (L10-1 L10-2 L10-3) :VARS (X.443 Y.444) :NAME 10)))


* (symbol-plist 'l10-3)
(:OLID L10-3 :PLID NIL :CID C10)
* (symbol-plist 'c52)
(:VARS (W.432) :NAME 52)
* c52
(L52-1)
* l10-3
(- R X.443 Y.444)
* l10-3
(- R X.443 Y.444)
* (symbol-plist 'l10-3)
(:OLID L10-3 :PLID NIL :CID C10)
* c10    
(L10-1 L10-2 L10-3)
* (symbol-plist 'c10)
(:VARS (X.443 Y.444) :NAME 10)
* c56

* (symbol-plist 'c54)
(:PROOF (:RESOLUTION (X.433) (A) (L53-1 L51-1)) :VARS NIL :NAME :RESOLVENT)
* (symbol-plist 'c53)
(:PROOF (:RESOLUTION (X.430 Z.431 W.432) (X.433 B A) (L50-2 L52-1)) :VARS
 (X.433) :NAME :RESOLVENT)
* (symbol-plist 'c52)
(:VARS (W.432) :NAME 52)
* (bodyof 'c52)
(L52-1)
* (symbol-plist 'c51)
(:VARS NIL :NAME 51)
* c51
(L51-1)
* c52
(L52-1)
* c53
(L53-1)
* c54
NIL

　
2020/10/26月
・LICENSE.txtを追加した
・

2020/10/25日
問い
・Lsymを作るのはinputのときだけにする
　子のliteralのlsymはinput lidで決まるから

・varの名前のぶれ(gensymによる)は、genの意図でその差をとるだけでよいような気がしたが
　それを使った関数の意図で、その違いが重要になってきたら話が違うかも。

・[]からの距離を前にも考えたような気がする。
　距離はresoするごとにかわってしまうが、inputが距離を変えるのだと思うとなんかできそうなきもする

・作る (L^i_j,C^p) -> L^p_k
　つまり、resolventにinput lidを指定すると子lidがでてくる関数
　どう役に立つのか?

　L^i_jはatomなので、その値に子のlidのリストを設定するか
　今は値はLITになっている。共存させるかどちらかをplistにする。
　子lidリストは追加されていくので、あんまりplistは効率よくない
　では、値だと効率よいのだろうか?

・L^i_jを含むC^pのリストは役に立つか?

・input lidのmapとplanで証明をコントロールできないか
　
・input clauses のリストをAAとすると、AAのひとつの証明はAAのすべてのlitを使うわけではない。
　L1.1,L1.2,L2.1...とAAのlidを並べて、このリストから必要なものを消していっても、全部消えたから[]がでるというわけではない
　全部消さないうちに[]になる。
　終わりが来ることはわかるのでよいが、そのためにはクローンresolutionが必要。

・clone resolutionでは、-P+Pだけをcloneしてもだめで、-P+Pを消すために必要な他のclauseもクローニングが必要・・
　あんまり役に立たないかも

・例
　[A] = (1) +P+Q (2)-Q+R (3)-R-P
の場合、これからたとえば
  (4) +P+R, (3)-R-P
ができて
　(5) +P-P か (5') +R-R
ができてこれから[]ができるために必要なclauseは
　(5)の場合
　　(6)-P (7)+P
　(5') の場合
　　(6')-R (7')+R
となる。
　(*) -P (**) -R
とかではだめ

つまり、[A]から[]を出すには、±Pか±Qか±Rのどれかがあればよい。
が、ペアである必要あり。

[A]は、unit clauseを決めないということ。

goalを考えるのなら、goalが決まればどれが使われるか決まると考えられる。








・


2020/10/24土
・ソースヘッダをつけたほうがよいかも。
他のソースをみてみる

🎂readkqcはreadafileを呼び、これは1つのS-expしかよみこまない。
全部よみこんで1つのリストにしたい

・lsymofの意図を作ったら、意図の書き方がおかしいのでlitofの意図を書く
　letでバインドした変数(L1)を'L1で参照してlitofをすると、L1の中身がAだといわれる。
　何か違うL1をみているのかもしれない。

・(make-clause)でちゃんと作ってみる。

・そのとき、cidがとても大きな値になることがある。しかも、そのときのLid(L123-5)の5がとても大きい。
　*maxcid*を参照しているような予感

　やはりcidとvarで同じrub-gensymを使いながら、変数の.のあつかいをしているから混乱しているらしい。
  .をつけるかどうかはrub-gensymの外でやるか、

　・newvarはreso.lispとresoid.lispの両方でよんでいて、それでbase.lispに定義をおいているが
　・rub-gensyの引数は数字でC23とかではない・・・それでよいのか??
  ・gensymの引数は数字・・・なにか違う
　　(gensym x)はxの後ろに数字^nをつけて新しいシンボルを作る。
　　全体としては(intern (string (gensym x)))でよいが、xになにを指定するか。
　　cidの場合、
　　　　a) 入力clauseならnameを使い C<name>とする。
　　　　b) resoleventは、Cではじまる新しいidでよい。

　　lidの場合は、cidの後ろに-nnnをつける。nnnはリテラルインデックス
　　変数の場合は、(vrootof)で.の前をとりだせるから、(gensym (vrootof v))でよい


 　・つまりmake-cidで文字列がかえってきてsetcidでcidとして文字列を渡していたのでNGだった。
　　　make-cidでinternすると意図は通ったが、それでよいか

   ・play-rubbish-resoid.lispの最後のプロックで[]がでるところまではいった
　　そこまでのどこかでNGになる

　・cidが長いのは、make-cidでcid作るときにrub-gensymしているのが原因だった。

　・lidが長い。これも、make-lidでlid作るときにrub-gensymしているのが原因。rub-gensymを消したらOK

・変数名が変わるのは意図の判定を煩雑にする。
　意図ではgensymを無効にするか・・・noranを使うか

・noranを使うにしても、変数名とidでは.をつけるかどうか違うので、そこらへんを考慮した意図が必要

　newvarで.をつけてからrub-gensymしている。これで意図のときx.ができておかしくなる。
★　通常は変数に.がつくが、意図のときはつけたくない

・全体はranで意図確認して、genとgen-noranの間の違いの確認を別のプロセス上の意図確認する
　抜ける部分もあるがこれでどうか

・idはL1-2で変数はx.234 という仕様



2020/10/23金
・今、(+ P)としているが、+Pのほうが楽のはず。
 (intern "+P")でしよう
 (intern (format nil "+~a" 'P))
 (intern (format nil "-~a" 'P))

　(+ P)のままだとhashtableになる。
・現状、oppoは使っていないし、lsymof の値も使っていない。
　+Pにしても大丈夫そうだ

・なにがしたいかというと、+Pの値に+Pのリテラルのリストをいれる。

* (defvar xxx (intern (format nil "+~a" 'P)))
XXX
* xxx
+P

;;
* (defparameter +P ())
+P
* (push 'L1.2 +P)
(L1.2)
* (push 'L2.2 +P)
(L2.2 L1.2)

このような操作をする。



2020/10/21水
・baseはresoidの一部の機能なので、この構成は正解なのではないだろうか。

・resoidの意図で失敗していた、変数がgensym化されたものの比較の件
　毎回sbcl起動直後には同じ変数明になるので、一回だけ通る意図ということにしよう。
　意図は通るが、一回しかできないということをどう表すものか・・・

・ちなみに、intend-equal*　とかして XとX.nnnを同一視するのも考えられるが
　sigとかvarsとかいろいろな場面にでてくるのでどうしたものか。
　意図の構成を変えればいいのかも

・maxcidで同じidになるとかいう警告をどうしたものか。

2020/10/20火
・reso.lisp/newvarsをbase.lisp/make-clauseで使っていた。itoでみ定義になる。
　newvar, newvarsをbase.lispに移動し、itoもそれにあわせて修正。
　newvarする操作はreso固有なので、違和感あり。
　vrootofもresoからbaseに移動。
　とりあえずリファクタリング終了。
🎂itoの中で期待にXとなっているところ、計算値がX.234となっているために失敗する。
　どうしたものか
　intend-equal でなくて intend-same というのを作り、atom 'abc をintendしていたら、abc.nnnと一致させるようにする?
　それがよいかどうか
　しかもこのitend-sameはrubbish固有になる。
　よくない・・・


2020/10/18日
・DVC関係しようと思ったが、時間がなくなった
・resoとreso-idの関係は、独立なので、resoはなくてもいいのだが、そこで定義してるutilityをresoidで使っているのでファイル構成のリファクタリングが必要になった。
　調べてみると、rubbish-reso.lispのresolve以外はreso-idで使うことがありそうだった。そのままにしておこう。(resolve)もなにかで使うかもしれないし。
・いずれ整理しよう
・resoid.lispの関数の合成の中にはreso.lispにあるものが使えるかもしれない

・dvcfy-clause, dvcfy-clausesを作る
　clauseの形が問題になるので、resoid.lispで作成する。
　dvcfyすると新しいclauseができる。
　そうなると、もとのclauseはないほうがよさそう・・・
　「もとのclause」というもの自体作らないのでよさそう。
　make-clauseは入力clauseに対してのみ使われる。resolventは親から作るのでresolve-idが介在する

　・意図は手で確認した。
;* (defparameter cc50 (readskqc "((50 (x z) (+ P x)(+ R a z)) (51 () (- P a)) (52 (w) (- R w b)))"))
;cc50
;CC50
;* (C50 C51 C52)
;* 
;(dump-clauses cc50)
;C50=(VARS (X.417 Z.418) NAME 50)
; L50-1 (+ P X.417) = (OLID L50-1 PLID NIL CID C50)
; L50-2 (+ R A Z.418) = (OLID L50-2 PLID NIL CID C50)
;C51=(VARS NIL NAME 51)
; L51-1 (- P A) = (OLID L51-1 PLID NIL CID C51)
;C52=(VARS (W.419) NAME 52)
; L52-1 (- R W.419 B) = (OLID L52-1 PLID NIL CID C52)
;NIL

・resolve-idについては、修正前
* (defparameter r501 (resolve-id (pickl 1 (nth 0 cc50)) (pickl 0 (nth 2 cc50))))
* (defparameter r502 (resolve-id (pickl 0 r501) (pickl 0 (nth 1 cc50))))

* (dump-clauses (list r501 r502))
C53=(PROOF (RESOLUTION (X.417 Z.418 W.419) (X.417 B A) (L50-2 L52-1)) VARS
     (X.417) NAME RESOLVENT)
 L53-1 (+ P X.417) = (OLID L53-1 PLID L50-1 CID C53)
C54 CONTRADICTION : (PROOF (RESOLUTION (X.417) (A) (L53-1 L51-1)) VARS NIL NAME
                     RESOLVENT)=
NIL


　X.417が同じ名前でresolventにでている


・resolve-idでどうなるか
　うまくいっているようにみえる。

;* (defparameter r501 (resolve-id (pickl 1 (nth 0 cc50)) (pickl 0 (nth 2 cc50))))
;R501
;* (dump-clause r501)
;C53=(PROOF (RESOLUTION (X.417 Z.418 W.419) (X.420 B A) (L50-2 L52-1)) VARS
;     (X.420) NAME RESOLVENT)
; L53-1 (+ P X.420) = (OLID L53-1 PLID L50-1 CID C53)
;NIL
;* (defparameter r502 (resolve-id (pickl 0 r501) (pickl 0 (nth 1 cc50))))
;R502
;* (dump-clause r502)
;C54 CONTRADICTION : (PROOF (RESOLUTION (X.420) (A) (L53-1 L51-1)) VARS NIL NAME
;                     RESOLVENT)=
;NIL
;* (print-proof r502)
;C54 RESOLUTION (X.420) <- (A) : <L53-1:L51-1> 
;L53-1 (X.420).(+ P X.420) C53 RESOLUTION (X.417 Z.418 W.419) <- (X.420 B A) : <L50-2:L52-1> 
;L50-2 (X.417 Z.418).(+ R A Z.418)  input C50
;L52-1 (W.419).(- R W.419 B)  in  input C52
;L51-1 ().(- P A)  in  input C51
;NIL

以上でDVCに関係する部分の実装おわり

・X.417とX.420は、新変数があるので名前がかわっているようだ。
・たりないものはなにか
　- これが最善か? redundantな処理はしていないか

今日はここまで

2020/10/17土
・まず、すこし前から、gensymはrubbish-gen-noran.lispを使うようにかえている。

・DVCくみこむ

　1. post rename
   given (vs . e)
　　1) vs => ns (新変数のリストを生成する)
　　2) 操作概念上e@{vs<-ns)を実行する。
　　これはp-notでは vs.(e@ns)でありns.(vs.(e@ns))とでも書くようなこと。
　　説明: vs.(e@ns)はvsを変数リストとしてe@(vs<-ns)を実行するという意味。(vs<-)の部分は消えるのでvs.(e@ns)となる。
　　　　　その前にns.をつけた"ns.(vs.(e@ns))"は、vsをbindingとして代入をしたあとに、変数リストをnsにつけかえる。
　　これがうまくいくためには、代入はp-notでなくてはならない。つまり、vs.e@nsでeの中の変数がnsに起き変わった部分が
　　ふたたびeにはいらないことを保証する必要があるから。

　2. 入力時DVCfy
   post renameでDVCが満たされるためには、入力clauseでDVCが成り立っていなくてはならない。そのため、入力clausesの
　変数をすべてつけかえる。
　　given (vs . C)
　　1) vs => ns (新変数のリストを生成する)
　　2) ns.(vs.(C@ns))をclauseとする。

・まず、作ってあった(newvar)をみたら、symbolを作っていたので、できたsymbolに(intern (string ...))をつけた



2020/10/12月
・変数はshrinkvsで最小限になってるぽい
・ただし、dumpcsのmguは元のvarsで表示されているので多い
・必要なのはresolventのvarsのrename
・entry-litとentry-clauseでどうすればsubstpされるか
　entry-clauseでやればいいのか

2020/10/14水
・ito-rubbish-resoid.lispがとおった
  いろいろ修正したのがきちんと意図に反映されていなかった

2020/10/11日
・resolventのcid C111-Rから-Rをのぞく
　特にRはいらない

・(dumpcs)は*clist*のdump-clauses

・追加tracep はplidを追跡していく。symbol-plistするのでolidもみえる

・まだDVCはやっていない。proofをみると変数がそのまま残っている・・・

・dump-clauseでcontradictionにCONTRADICTIONと表示するようにした
　print-clauseはそのまま

・(pickl i cid)はcidのi番目のliteral idを取り出す
　play-rubbish-resoid.lispがすこしみやすくなった

・clidの設定を間違えていた。setlidの修正
　意図を書かなくては

20201010土
・setlidでolidを設定するようにした。必要なのか??
  olidはつねにinput literalのlidを示す
　plidはつねに親のlidを示す

　setlid で設定するように変更

・load-rubbish.lispにresoidとproofを追加
・olidofを追加 in base

・意図はまだ作っていない

・cid, lidにgensymパートをいれないようにする。
　必要ない


20201009金
・そういえばlidにorgをつけてないな。olidか。
・途中

20201008木
・resolve-idのresolveとproofの分かれ目をきれいにした
・cid->proofのあたりを関数にしたが、きれいに分けられるか??

20201005月
・(inspect)でいろいろ見てみた
・play-rubbish-resoid.lispに、pr,-r/p,-p/[] のスクリプトを書いてみた

20201004日
・確認
　　PvR -R / P -P / []
   2段の証明ができた
・resolventのvarsがちがっていた。vsでなく shrinkvsにした。
・(print-clause (cidof l12))みたいにすると簡単
・resolventのcidが*clist*に追加されていない。*llist*も
　あれ? はいる。itoの中でclearbaseしているからか。問題なし
　最後に追加したitoでclearbaseしていたからずれた

・ベンチマークのフレームワーク
・性能評価ツール
・

・package化の案
　1) symbol, expression
　2) substitution(A)
　3) unification(A)
　4) raw resolution
　5) resolution and proofs
　6) strategy
　　　strategyを構成するためのfunctions。
　　　特徴と処理

・utilityとして
　1) かけるか?? gensymの差異を回避できるか?


・ときたい問題
　- 製品の仕様と故障の現象から、故障の原因を導き出す?
　- まどマギの表面的な事象から、背景の世界を導き出す
　- DLによるFactsの収集と、あらかじめ作ったルールの集合から、今起きている問題を導く(??)
　- Factsからルールを導けるか(帰納)
　- 個々のルール(間違っているかも/有限のFactをまとめた)からの一般化
　- 時間によってかわるもの


・予想
　- わかり切った結論しかでない(演繹とはそういうものでは?)
　


20201003土
・すること
　- proof
　　cid -> parents, mgu
    mguはparentsから作れる場合もあれば作れない場合もある
　　ということはcidのpropertyにもつことになりそう
　　proof情報は独立。mixtureみたいな構成
　　ということでよいのでは
　　意図をどう書くか

　- cidにproof=(:reso mgu (plit1 plit2))を設定するようにした。entry-proof
    mgu=(vars sigma) このvarsは親のvarsのappend

　- resolventのvarsがちゃんと設定されていないかも
　　　わからなくなったのでひきつづき

　　　元(x y)
　　　mgu (y y)
　　　resolventのvarsは(y)
　　　mguは(x y)<-(y y)
　　　resolventのvars　は(y)になる。xは消えているので(shrinkvs)
　　　proofのmguには(x y)<-(y y)が必要みたいにみえる。
　　　というか(x)<-(y)は必須

　　　ということはproofにおけるmguは親の世界のmguであり、varsは作業中の
　　　(append (varsof lid1)(varsof lid2))みたいなものでないといけない

　　resolventのvarsはshrink
　　mguは親のvarsとmgu

 　　解決




　　　

　- strategy
　　once resolutionはproverとしてどういう能力があるのか

　- unificationの証明
　　test/instanceだけではいつまでもバグがのこるので、性質の証明でおわりにしたい
　

20200927日
・proofの続き
・(symbol-plist 'aaa) でも表示できる。symbolでなくatomでもよい

・proof情報をcid,lidに混在させるかどうか
　1) clause/resolventはproofと渾然一体なのだから混ぜて当然 => yes
　2) resolution とproofを分けて考えたほうがsimpleではないか => no
　　　proofはresolutionのメタな情報

・lidにplidを追加し、resolve-idでその値が正しく設定されていることを確認した
　　が、この設定が最善ではないような気がする
・消えたlidはmguでつながるので、proofというか*mgu*もほしいかも。
　mgu1 = <L1:L2>の関係。varsはvarsof(cidof(Li))できまる
  mgu1 = (vars . terms)
 どっちだ

  A案)
　mid = (:vars (x y) :subs ((f a) a))

  cidとmidはどう関係??

  B案)
  mid = (:cid cid :subs ((f a) a))

  
  ? mid -> L1 L2

　proofとの関係は?
　　
  step = cid, (lid1 lid2) 
  sig1 = <lid1:lid2>

  midがないと、再現できるかどうか
　midがあると Lid1, Lid2が不要か???


A案のmguはいるのかなあ。
midの値がtermのリストで、midのplistに(:cid cid)を持つ
すると、cid -> varsofで(vars .

20200926土
・今日はproofを考えよう
・sigmaはresolve-idの前半で得られている
・proofの構造は?
・案1)
  proof=step*
  step=parent*
  parent=lid, rule

  親clauseは(cidof lid)でわかる
  親が1つの場合(renameとかmerge)や2つの場合(resolve)も同じ型のstepが使える
　どうだろうか
・lid, cidの構造
　cid 
   :body->lid*
   :vars->atom*
   :step->(rule . lid*); rule=:reso/(lid1 lid2), :rename/(), :merge/(lid1 lid2)in same clause
   :name -> any
   :sigma -> :reso=><lid1:lid2>, :merge=<lid1:lid2>, :rename=>generated
     :renameのときは、sigmaの左がおやのvarsの一部で、右は新しい変数リスト

しかし、sigmaはproofの構成物ではないだろうか

  lid
   :cid -> cid
   :lit -> literal::S-exp
   :prev-> lid {input=>lid=nil,reso=>(lid1 lid2)
   : 

#で1以上の繰り返しを表すことにしよう。*は0回以上の繰り返し



20200923水
・cidの値にはbody、lidの値にはlitを設定した
・(cidof 'xxx)のように'が必要なのが気になったのでmacroでつけなくていいようにしてみたが
  意図はつけなくてはならないので、よくわからなくなってしまった。
　つけることにして、macroは使わないようにした。
・print-literalにlitが表示されていなかったので修正した。symbol版では表示されないのではないか

20200922火
・atom版をつくってみる(20200921atomid)
　局所的にながめながら修正すると何が正解かわからないのでだめ
  genで、(gensym ...)　のあたりを(intern (string (gensym ..))) みたいにした
・atomのvalueとpropertyは別になっているつまり
　(setf B '(:name 1 :body '((+ P x))))
　と
  (setf (get 'B :name) 1)
  (setf (get 'B :body) '((+ P x)))
　は違う。後者はBの値がなくてもよい。
　alistのように、valueからひいてくるのではないらしい。つまり
　(setf B '(:name 1 :body '(a)))
　とやって:nameの値を引くことができないような・・・
　さて、どうするか

・(make-clause)すると、cid, lidのpropertyにははいっていた。
  valueがないのでそこに生をいれておけばいいのかな・・・
・意図はエラーにならない。symbolのかわりにatomが使われているだけなので・・・
　タイプしたアトムが使えるので、こっちのほうが楽

・(symbol-plist 'cid)でproperty-listがとれる・・・もしかして何か間違っているということはないだろうか

・なさそう。print-cluaseとかdump-clausesとかも動くのでよいのではないか


・(inspect 'cid)が面白い。

　
・atom版をmasterにした。symbol版は20200921symidとした。


　
20200921月
・証明情報をどう持つか・・・resolve-idの外側で作るのかな
・cidの重複が何度もでているということは、resolve-idで作ったcidについて*maxcid*などがメンテナンスされていないらしい。
・internでatomのpropertyに設定するのができるかどうかすこし考え中
　それをしようとすると、baseあたりを全部書き換えたくなる
　つまりlidやcidをatomにするので・・・
・今は、cidやlidを容れておくatomを作っている。これはテストのためであり、実際に使う時はこのatomはいらない・・・のだろうか。
　そうとも思えないからつらい。



20200920日
・意図がとおっていないのは、resolve-idで作る形を変えたから。
　どうテストすればよいのかがはっきりしていない。
・いいのだが、resolve-idしてできたsigmaをどこに残すのかはっきりしていない
・resolve-idで、データを作って、最後にentry-clauseでまとめてidに登録している。
　このインターフェースがだめだというのもある
　意図を書くとき、idの中身を取り出して、S-expとして比較していて
　それを取り出す形が煩雑。
　特に、clause+sig(v.t)というのは意味がわからない。
　どうすればよいか??
・いまのところ、意図が成り立つように書いてみたが、直さないとならぬようだ。


20200919土
☑️srcをjuliaに、lispをjuliaのとなりに移動する
☑️aliasの修正
・動作確認　ito-rubbish-resoid.lispで同じエラーになったのでよし

・でもito-rubbish-resoid.lispで失敗する理由は?

🎂atom作れないと言っていたけど、internでatomにするか? そうすれば、同一性はたもてる


20200915火
・inputのとき番号が増えない
  make-clause->make-cidで*maxcid*を設定した
　入力nameが*maxcid*と同じときメッセージを出す・・・完璧にはほどとおい
・load-rubbish.lispにload-rubbish-resoid.lispがあってエラーになっていたのでコメントアウト
・resolve-idにもどって、整頓した。cid, lidがつくられてつながる
　lidにはRがはいり、cidには入らない。どうでもいいのでそのままにする。
　この部分はテスト作っていない

・できるかぎりテストドリブンでやっているが、うまくいかなくなることがある。
　複雑なものは難しいかな。
　todoがちゃんと書けるくらいに整理しないとだめか。

・演習問題程度なものは、繰り返しやるので、設計が明確になるが、初見の場合、それは実施できるものなのか
　とは思う。

20200913日
・resolve-id のresolventに複数literalがある場合の意図で、subsubpをしていたのはまちがいだった。
  substpが正しい。
・さらに、テストはlidのリストをlitのリストとして比較したかったが、lit*ofがなかった。
　cidに対するbodyofはあるが、生のliteralはなかったという話。
  baseにlit*ofを追加し、resolve-idのテストを修正した。
・lit*ofはテスト用の関数のような気もする。これを使ってprint-clauseを書き直す?
　と思ってprintをみたらlitsofを作っていた。
　やはりUI系の関数ということか。printからlitsofを消して、lit*ofにかえた。
・subsubpのbugfix
  めちゃくちゃだった
・resoidの意図にもどったが、resolventをつくるためのpropの設定ができていない

🎂issue itoに、baseとbase-noranを作ったが再定義のwarningがでて醜い。
　どう解決すればよいか。

・resolventのcidはまあRでいいか。
・*clist*, *llist*, *maxcid*の管理部分を作る
  どういうタイミングで増えるのか?
  new-cidは*maxcid*をふやしていく。inputのときがうまくいっていないような・・・

・あれ? load-rubbish.lispでエラー。ito-rubbish.lispはOK


20200912土
・atomの作り方/作れる
* (defvar vvv (intern "GOG"))
VVV
* (set vvv 123)
123
* vvv
GOG
たしか、今使っているパッケージにできるはず。

・resolventを作る方法を考える。いきさつの細かいことは忘れている。
new-resolvent(vars, sigma, ((Li . Liti),...))
　Liは親のLid, Litiはsigma適用後のLit
 1) make ncid(*maxcid*をもとにmax+1にするか・・・
　　そのためにはkqcioでinputのmake-clauseのときに*maxcid*をmaxにする。
 2) ncidのvars(nvars)を作る(vars, sigmaから?)
　　・ncid.vars = nvars
 3) nameは*maxcid*
    ・ncid.name = *maxcid*
　　resolventのnameは全部"R"でもよいような気がする
    親はlidのprevとproofのparentでわかるので数字である必要はない
    でもnameがみんなRというのはどんなものか・・・proofを別にもつからそう思うのか
　　全部Rということは、gensymが作るランダムな部分が区別要素になる・・・
　　もしも自前で区別要素(distinguish part)が作れたらrandomは不要か

 4) bodyを作る
　　4.1) LiからnLkを作る
　　4.2) nLk.cid = ncid
　　4.3) nLk.prev = Li
　　4.4) nLk.lit = Liti

となると
　cid => parents (:reso C1 C2)みたいになるのか
  (:rename C1)とか
  proof情報をcidにつけて大丈夫か


・rootofはCの次から.までをとってくる
　C12.xxxx => 12
　CR.yyyy => R
まあこれでもよいか

・resolve-idで最後にsubsubpしているが、literalのリストにたいするsubsubpにならない?****

　

20200907月
・lidからnewlidの場合

20200906日
・resolve-idの続き
・PvQと-PvRがQvRにならないところまで。Qになってしまうエラー
・resolvent のlitに代入したとき、新しいlidを作りたい
・そのときresolventのcidが必要
というあたりが未定

・string => atomはないんだよなあ
・jupyter common-lispをインストールしてみた
　ito-rubbish.lispうごく
  https://github.com/yitzchak/common-lisp-jupyter
　に書いてあるようにした。
  rosもいれていたが、rosでのインストールは失敗(ros install common-lisp-jupyterで名前がわからないと言われた)
  quick-lispいれていたので、quick-lispのupdateをした。
　sbclを起動し、(ql:add-to-init-file)はいらなかったかも。
　ql:update-dist "quicklisp")
　githubからrepositoryをcloneして、そこでやってみた。
　20190521以前のものと書いてあるやつ。
(ql:quickload :common-lisp-jupyter)
(cl-jupyter:install)
(quit)
して
jupyter console --kernel=common-lisp
これをするとterminal上で、jupyterのconsoleになってしまい、やめた。
^Dでないと終わらなかった。
jupyter 自体は
どこででも
jupyter notebook
でできるようだ
newにcommon lispがはいっている






20200905土
・cid, lidを数字にするのはやめて、もとにもどそう
・まず、文字列を内部形式に変換する。fileから読み込む(kqcio)の一部に含める
  まず、rubbish-kqcio.lispとito-rubbish-kqcio.lispを修正。readastring, readskqcを追加
・rubbish-base.lisp、setcid, setlidの意図
　base-noran.lispでやっていた OK
・resolve-idの意図をつくろう


20200830日
・DVCの効果をうまく評価できない。どうしたらいいか。
　分析必要


20200823日
・L100とL200のresolveをするとき
  <origin(L100):origin(L200)>が失敗するならresolveを試みる必要はない。
　<L100:origin(L200)>も失敗すれば<L100:L200>も失敗する。
  L200の祖先でL100とresolveに失敗するリテラルL120があるとすると
  <L100:L120>faile, <L200:L120>=σ1(L200はL120のインスタンス)
  <L100:L110>=σ2, <L200:L110>=σ3で<L110:L120>=σ4の特徴はなにか?

・lid,clidはもともとの数字またはatomのままでいいような気がする。
 　が、数字にするとsymbol-plistが使えないので、どうやってリンクをもたせるか悩ましい。
　 plistとしてもたせる?
   cidlist=(1 '(1 2 3) 2 '(4 5) ...)
   lidlist=(1 '(lit '(+ P x)...)
　　　だめだ。

  今のcid, lidでだめになりそうなところは、人間がlidやcidを指定するとき、文字列をmake-symbolしてもだめというところ。

  たとえば、lidを*lidlist*から探すときは、
(setf *slidlist* (map 'list #'string *lidlist*)) ;; stringify

(defun findid (id idlist sidlist) 
  (loop named findsid 
    for sid in sidlist as ssm in idlist do
     (when (equal id sid) (return-from findsid ssm))
  )
)

(findid "L1-1.418" lll *slidlist*) ;; (#:L1-1.418)

(eq (car lll) (findid "L1-1.418" lll *slidlist*)) ;; is T ok

でstringからsymbolに変換はできるが、ちょっとtime consumingすぎる。

1. 人間がlidやcidを直接指定する場合はどんなとき?
2. Web にしたとき、inputの文字列からcidやlidを作る必要がある。
3. 直接指定する場合、cidにname(番号)がついていたらそれでとってこれるだろう。
　lidはその(bodyof cid)のn番目を指定して取ることはできる。


*番号をidにする場合、連続性は仮定しない。
　だから、配列にいれるわけにいかない。

・cid,lidを数字にして、symbol-plistの構造でなく、number->alistにする実装を確認した。play-rubbish.lisp


・人間がlidやcidを直接指定する場合は、stringに変換してclistやllistから検索るのでよい。性能が必要ないから。
　ということで、lid, cidはsymbolのままで続けよう。
　自動の場合は問題ないような気がする。

・そこでopposの処理を作ってみる。これはresoの一段上の制御になる。rubbish-baseでいいのかな。

・Lid -> (sign . Psym) -- oppo --> (-sign . Psym) -> Lid*



20200822土
・oppoをもとめるため、-Pと+Pというシンボルを作り、その値またはplistとしてlidを持たせるというのはどうか
・symbol +P,-Pの値としてlidのリストを持つようなことを考えた
　make-symbolするたびに見た目はおなじだかeqで異なる判定されるシンボルができるらしい
　シンボルはどう作ってもuniqueだと思っていたのだが・・・ packageが違うのだろうか


・


20200817月
・input ⇒ literal pairのunify ⇒ ngは無視し、σのみをとってグラフ再構成
　⇒ σの合成についての新しい制御を導入すれば、Flowができそう。
　ポイントは、clauseの集合を代入の構築物にする点。
　そのアルゴリズムがもとのrefutationの集合と同等かどうか?

・プログラム合成には興味がないが、proofと代入(の構成物)の対応は興味深い。
・代入の構成物は、実行可能性に拘らなくてもいいのかも。
　(x,y)←(a,f(y))は、
　　(1) {if x=a then y←f(y)}
　か
　　(2) {(x,y)←(a,f(y))}
　というmguに対応するというような考え。


・<L1・σ1:L2・σ2>=σ3となるためには、<L1:L2>がunifiableでなくてはならないという話。
・proofに出現するすべてのliteral/ resolventのliteralはすべて入力リテラルに元があり
　それのインスタンスになっているという話。





20200816日
・input clauseの組み合わせで、mguを先に作ってしまうというのはあるのではないか。
　あとはmguの合成だけで処理する
　これは、命題論理のproverと一階述語のproverの中間になる
  mgu+remという混在はどう考えるのか

・cid,lidのplistによる連結は、時間によって変化する公理系を実装するのが難しいかも。
　公理系1つを1つのプロセスとし、プロセス間通信にする???

・今は設計の情報あつめになってきた。
　観点がかわりつつある。新しい視点


20200815土
・todoをissueにもっていった
・(resolve lid1 lid2)=>clause Aを作ってみる。cidでなくclauseかな

・graphをどうするか
　操作の流れ
　cid -|body|->lids-|select|->lid->(sign, psym)-|oppo|->lids
　という流れになる。oppoで(neg, psym)にする必要はなさそう

 a) (plist::(p lids)..., nlist::(p lids))...)
 b) ((p lids lids)(q lids lids)...)
a)は、全体をpogとnegに分けたもの
b)は、述語ごとにpogのlidsとnegのlidsをもたせたもの
oppoを考えると、b)が妥当


・今日作ったもの
  remof(lid) = bodyof(cidof(lid))からlidを除いたlids

  varsof(lid1) + varsof(lid2)であたらしいvarsを作るが、このとき
　unionではなくリストの並置。appendか。

・現状の問題点
  - lidにsubsubpしているのでlitはそのまま
  - 新しいlitにlidをつける必要あり
  - あとでcidをつけるとなるとcidのbodyは更新されていない
  - varsは必要なものだけにできるのか?

・グラフのapi
  - lid -> lsym -> oppo -> lids
  - goal -> lids

・sibling(lid1,lid2) == cidof(lid1)==cidof(lid2)





20200814金
・read-kqcではcidsしかでないが、lidsもほしい・・・

・(alllids cids) :cidsから含まれるすべてのlidを取り出す
・(lidsof cid ns): cidのbodyからns番目のlidを取り出す
・(choose ns os) ; general select ns th of os

・graph0を作ろうとするがどうするか
graph0 = (P (:+ (L10 L20) :- (L11)) Q (:+ () :- (L77)))
みたいなplistをかんがえるも、これは2次元のplistか・・・
plistはkeywordで検索するようなイメージの例ばかりで、keywordが自由なのはないのか?
plistはkeyword-valueと考えるのが正解な気がしてきた

idを管理するのには適さないのかも・・・いやまて・・・
(gensym)はなんのためにあるのだ・・・




graph0 = (P ((L10 L20) (L11)) Q (() (L77)))

でよいか





20200813木
・(read-kqc)を(print-cluases)で表示。(clausesof)でlistにする。
・varsが()だとNILになってしまう。printは()にしたほうがよいかも
・rubbish-printには
 - print-clauses
 - clausesof
 - dump-clauses

・シンボルわからん
　(readkqc )で読み込むとcidのリスとができるが、そのリストのcidを
取り出してsymbol-plistなどは動く。
　しかし、その名前をreplで入力すると、(symbol-plist)はnilになる。
　みためではないのか・・・

・idは数字にしようかな
・symbolでいいかな。idsのインデックスで指定すればいいんだし数字にしたらsymbol-plist
　みたいな操作ができない

・あと変数を作る必要があって、変数名+数字にするとsymbolになるから・・・そこはさけられなさそう。
　だとするとtpuのように決まった変数のリストを使ってrenameするか・・・



20200812水
printを作ろうかと思っていたがito-r*-base.lispがエラーになったのでそれを修正。
noranと同じなので不要な気がする。
gensymを使わなければよい


20200811火
・symbolに小文字が混じると||で囲まれることに気付いた。
・cid, lidはsymbolで動作した。base-noran
・kqcioで読み込んでbaseまでするようにした。itoはかけていない。

・cidもlidもただの数字でよいのではないか
　と思っていたが、itoが動いたのでそのまま。ううむ

・明日はprintを作るか・・・


20200810月山の日
・idとstringとatomの関係について調べる。
  atom -> stringは(string -)でも(symbol-name -)でもOK

・(symbol-plist -)がよさそう。symbolに対してplistのインターフェースを提供
　(symbol-value 'a)もあるが、結局p-listにしたいので、(symbol-plist)がよさそう

　ということは、atomを使う必要はないような・・・

・symbolは、REPLで入力するのがむずかしい。見えるままではだめなのか??
  #:C1. と :C1. は違う。。。


20200809日
・cid, lidを生成する関数に、デバッグ用に固定のidを生成するものを作ろう
　メタレベルで切り替えてコンパイルすればどちらかになるような方法がないか考えたけど
　よくわからないので、実装ファイルを二種類にして

  rubbish-base.lispからmake-cidとmake-lidをrubbish-gen-noran.lispにうつし
 itoの先頭ではnoranをloadして使うようにしよう。
　gensym版はそれ固有の意図を作る。

・rubbishをwasteにかえるのはどうだろか
　cheapwasteでもよいし
　wastelogicでもよい

・ずれていると思ったのは、ruleの部分
  stepid(sid)

  sid -|left|→lid
　　　-|right|→lid
　　　-|subs|→mid


　mid -|vars|→V*
　　  -|subs|→T*

  ρの場合はT*はN*でNは変数名

・symbol - atom - stringの変換方法忘れた
 symbol-name: symbol -> string
 make-symbol: string -> symbol
  symbolかstring -> atom


20200804火
手でやってみている。
mguとcidとlidの対応がずれているような


20200802日
🎂ID管理などを行う部分をbaseと呼ぶことにする。
rubbish binからbinも考えたが、binはバイナリなのでやめた。
julia版にあわせてcore・・・もともとcoreはいただけないと思っていたのでやめた。
pureだとresolutionの関数の意味に感じる

特別な意味を感じないbaseにしようと思う。basic・・・BASICはいやだ
rootはlinuxのrootだし

base

🎂 (isterm e)など書いてみたが、これ、使うかな。

使いそうなものを書いてみる


20200801土
水曜に作ったresolvとisolatevsは裸の機能の実装だったが、それに証明情報を対応させようと
すると難しい。

そこで、その前に証明機構などを作る。

機能仕様や実装について、何となぜをまとめておくことにした。
なぜそのような実装を選んだのか。何を作りたいのか、というようなこと。

cheaperlogicにlisp実装だけを移動したい。
リポジトリは作った。

そうなるとcheaplogicとcheaperlogicの両方にかかわるdocumentはどこに書けばよいか。
cheapthoughtにおくほうがよさそう・・・
まあ、交わることはないと思う。

gitの履歴がとぎれるので、やめた。
たぶん、cheaplogicをcloneして、いらないものを消したりdir構成を変えてから
別のrepogitryとして作るのか・・・
面倒になったのでやめた

履歴を残さないでいいのならできるが
prover話のつながりが切れるのもよくない・・・

20200729水
ツールはリポジトリlisptoolsに移動した
~/lib/mysbclは~/lib/lisptoolsに変更
そこはcloneした
.sbclrcのmylibの参照する*MYLIB*をこのパスに変更したので
ツールは(myload "ito.lisp")みたいになる

🎂ToDO20200729   unif, resoの'NOは:NOにする
した

(resolve)で、varsをきれいにするのがすこしわからなかった。これは(shrinkvs)
最終的にはこれで正しいはず。
<L1:L2>に出ていない変数も残る。

次はrenameで、関数名は(isolatevs)
これの意図は作っても動的に変数名が変わるからだめかな。

変数名を決めてからrenameする部分をわけてみた。
isolatevsではないな・・・ただのsubsubpか・・・

vs -> nvsにしたあとで意図は(subsubp nvs ncls vs)で元のclsに戻して比較してみた。

これで、次のレいやーで証明情報やidと実体の対応付がうまくいくかどうか
もう一度設計にもどって考えてみる。


20200726日
・全体デザインすこしずつ

・ proof stepについて検討
(v l1 l2 r1 r2) から
v.σ = v.<l1:l2>
v.r = v.(r1+r2)*σ
ρ=new(v)
 σ' = ρ.(v.σ@ρ)
 r' = ρ.(v.r*ρ)

** ρ.(v.A)は、ρ.Aを作る操作。変数リストのつけかえ

結果 (ρ σ' r')

step
 (v l1 l2 r1 r2) : l1 l2 ⇨ σ, v.(r1∪r2)*σ  => ρ(v.σ@ρ) ρ.(v.{(r1∪r2)*σ})@ρ

どう表現すべきか

 v1.c1 v2.c2 ; v = v1∪v2
 ----------- v.σ = v.<l1:l2>
 v.r         ; r = (c1-l1)∪(c2-l2)
 ----------- ρ = gen(v)
 ρ.{v.(r*ρ)} ; 右のρは定数とみなして代入し、左のρは変数としてバインディング

ここに表現されていないがc1,c2から最後のところまでの代入は
　ρ.{(v.σ)*ρ} 
になる。





20200725土
renameの部分を作り始めた

20200724金
1 resolveのパラメタに関数を渡すにしろ、defparameterで名前をつけるにせよ、funcallが必要なのだ・・・
　schemeならいらないのかな。

呼び出すところ全部にfuncallをいれるのはいやなので・・・

  (defparameter *funp* ...function to be called...)
これをresolveを呼び出す部分で定義して、resoでは

　(defun sfun (x y) (funcall *funp* x y))
みたいな関数sfunpをそれぞれ作っておくか・・・
resolではfunでなくsfunを使う
引数の数は固定なのでこれでつながる。

これが働くためには、substpとかsubstsとか別のモジュールにする必要がありそう。
それぞれが完結していないと
しかし、spは両方使うので、どうすべきか・・・
たぶん、unificaionspを使う人にとってのsubst, subsubなのでsubstpとsubsubpだけでよいのではないか。

この変更はreso layerのみ。


🕷 <(P x):(Q x)>がnilになる。NOになるべき
disagの定義で関数名が違うときNOにしていなかった。
何か他の不具合があったようだが、有効にしてなにも問題がなかったのでそれでOK





20200723木
1. make alias sbcl='sbcl ... --userinit ~init.lisp ...'
  init.lisp contains definition *MYSBCL* and myload

  *MYSBCL* has a path to my lisp utility file.
  myload load file from *MYSBCL*


2. refactor lisp files
🎂名前　rubbish prover
🎂ファイル構成
　subst, subsub(pnot, snot): 代入
  unification: snot, pnot, sp版
  resolve: S-expレベルのresolution(proofはまだない)
  essential: clause管理とresolveのつなぎ. COREはrubbish binと呼ぶ?
             proof管理
　rubbish provers: proverはいろいろありうるので、全体をrubbish proverと呼ぶとすると
　 simple-rubbish :単純なprover... control over resolvent num, proof steps
    p-f correspondence 
　 view-rubbish: Web GUI prover with human interraction

ファイル構成をかえた
今まで作ってきたlispコードはoldsに移動
rubbishコードのファイルは、〜rubbish-〜.lispとした


☕️TODO20200723   ito.lispを違う場所で使いたくなった。juliaのLOAD_PATHみたいなのがほしい

ito.lisp and ito-ito.lisp are soft link to ~/lib/mysbcl
とし
(myload "ito.lisp")
でロードするし。
(load "ito-ito.lisp")
で意図できる。でもオリジナルはcll





20200720月
#|...|# がコメントのように働く・・・でもS式にはならない
それでいいのか?
kqcはこれでコメント書くことにしよう。
特に修正なし


20200719日
🎂どういうデザインにしようか考え中
　julia版をみなおしているが、ややこしくてどうしたものか。
　viewproverは動いた。
  みためはともかく・・

　dataにある、ものをなんと呼ぶべきか
　juliaではcoreと呼んでいた。readcore()で読み込むと、coreになるからそれでいいのかな。

　coreは一般的すぎてどうかな。
　specみたいな用語があるとよい。

　coreは何か?

  .cnfはclause normal formかなにかそういう名前だったような
　　でもjuliaとlispでは違う形になっている

 factsでもないし
 descriptionでもないし

 lispの場合、evalすれば実行される。
 macroで定義するように書くか

　something writtenで、swではどうか。拡張子は.swf swiftとぶつかるのか
  swnかsowか
　ならば、something to want(stw), something to desire(std)
  something to wrettenでstwか

 sowはstatement of workだそうで、statementが使えるかも

 statement of worldとかstatement of desireとか。後者ならsodか

 quelque chose (qqc)にしておこうかな。長い語は出さない

https://franpon.com/study/1701101

 略語はqlcらしい。ということはklcでもいいのでは
 みんなすでに使われている
　kqcかな
https://www.filemagic.com/ja/list/k/page/7/
　によると、一般的でないファイルなので、これにきめよう kqc(quelque chose)

 kqcのreadkqc関数を作った。単に全体を1つのS式として読み込むだけ。
1行ずつにするとend-of-fileがわからない・・

 kqcio.lispでito-kqcio.lispも作成した

🎂 bterm/lispを別リポジトリにしたほうがよいかどうか・・・



20200718土
* refactoring
resolutionを作る準備として、play-disag.lispのファイル名れべるのリファクタリング
play-disag.lisp ⇨ unif-disag.lisp

* disagというキーワードを入れ続けることの違和感あり

* ito-reso-disag.lisp
 デザインをはじめよう

 1) julia版のcoreみたいにするか
 2) resolve : +L x -L -> mgu / exception 
  a) (resolve core 'C1 'L1.1 'C2 'L2.1 #'unifications #'substs) ;;; ???
  b) (resolve '(x) '(1 (1.1 + P x)) '() (2 (2.1 - P a)) 'L1.1 'L2.1 #'unifications #'substs)
  c) (resolve '(x) '((+ P x)) '() ((- P a)) #'unifications #'substs) ;; left most lit removed

 3) resolution C1 x C2 with l1,l2 -> R


 4) いったんnative formに変換してresolutionするという形?

  core -> native -> resolvent -> core(clause, proof)

  julia版のdvc_resolutionをみると、引数にとるのはlid1, lid2, coreのみで、
　そこからvars、cid->lidsと求めている
　まあ、必要最低限はそこかな。それにしてもjulia版のことはすっかり忘れている。
  coreについては気持ちはわかるが、どう使っていたのかがわからないというれべる。
　うまくいくのかどうか考えながら進むしかない。

  lid -> cid
  lid -> cid -> vars
  lid -> cid -> lids 

　これの利点は何か??

 julia版は、id -> nativeをDictでやっていたと思うがhashtableでよいか。

 (make-hash-table)
 (gethash key hash)
 (setf (gethash key hash) newvalue)
 (loop for k being the hash-keys in *hhh* using (hash-value v) do ...)
 (maphash #'fn hash)
 (hash-table-count hash)

 alistやplistを使うのは、メモリ最小条件だから、どっちかな・・

★ clauseあたりのliteral数が少ないならlistのほうがよい。
★ その境界はどのあたり???



* 全体
最近、何かファイルを作ると一連のファイルをあわせて作ることになる

xxxx.lispなら
ito-xxxx.lisp
load-xxxx.lisp
perf-xxxx.lisp

ファイルxxxx.lispから自動生成できないかな

0. generate-module
1. load 
 (load "xxxx.lisp")
xxx.lispがひとつとは限らないが、それは手でなおすのか?
どこまで生成するか

2. ito-xxxx.lisp
 xxxx.lispから関数名をひろってきて ito-ffffを定義する?

3. perf-xxxx.lispはどのitoを使うかわかるか?

*とりあえずファイルを作っておき、その中身は
(format t "~%yyyy-xxxx is not yet written~%")
としておくか・・・
ファイルを作る手間だけは除ける





20200712日
learn-lisp.lisp -- for-acrosssいうのがあったのですこし調べた

20200705日
TODO20200531a: defunをdefmethodに変えてgenericにすると性能落ちるだろうか
TODO20200704   genericを使いたいので学ぶ 使えなさそうなのでやめる

・簡単なmethod定義をしてみた
　classは使っていない

;;;* (defclass be ()
;;; (myname myvalue))
;;;#<STANDARD-CLASS COMMON-LISP-USER::BE>
;;;* (defparameter *name1* (make-instance 'be))
;;;*NAME1*
;;;* (setf (slot-value *name1* 'myname) 'Jiro)
;;;JIRO
;;;* (setf (slot-value *name1* 'myvalue) 123)
;;;123
;;;* *name1*
;;;#<BE {1002CD9A73}>
;;;* (slot-value *name1* 'myname)
;;;JIRO

exp*はどうするのかとか、

どう考えてもデータはS式のほうが簡単
method dispatchが高速になるかどうか・・・

とりあえずやめておこう


20200704土
今のunifyをgeneric functionを使ったらどうなるか。
性能を比較したい。

generic function/methodを使うためには、disaptchのためのパラメタのオブジェクトで
区別できなくてはならない。ExprもExprのリストもconsでは分岐できない・・・

故にdefclassでクラスを作る必要がある
(この段階でメモリを食い過ぎるような・・・)

区別したいもの
 - atom(constant と variable) -- symbolとは違うはず
   もしかしたらconstantはsymbolでvariableはatomかも
 - number
 - string

 - expression
 - expression list
 - sigma : set or list of primitive substitution(var term)

くらいだろうか

だんだんわからなくなってきたので、中断

* load-test.lispがload-ito.lispでなくてはならないことが判明
関連する場所を修正

* commonlispのブロックコメントはやはりないみたい
　何回も探して、毎回なかった。
　とりあえず、
　:'a,.s/^/;/



20200628日
性能測定関数をいろいろかえてみた
perf.lispに関数をまとめた。
perf-disag.lispでそれを使った

10000回実行の結果
** ITO-UNIFICATIONS of 10000 times**
Evaluation took:
  0.119 seconds of real time
  0.118683 seconds of total run time (0.116848 user, 0.001835 system)
  [ Run times consist of 0.010 seconds GC time, and 0.109 seconds non-GC time. ]
  100.00% CPU
  320,912,577 processor cycles
  52,494,336 bytes consed
  

** ITO-UNIFICATIONP of 10000 times**
Evaluation took:
  0.164 seconds of real time
  0.163658 seconds of total run time (0.162857 user, 0.000801 system)
  [ Run times consist of 0.002 seconds GC time, and 0.162 seconds non-GC time. ]
  100.00% CPU
  442,854,369 processor cycles
  92,962,816 bytes consed
  

** ITO-UNIFICATIONSP of 10000 times**
Evaluation took:
  0.167 seconds of real time
  0.164944 seconds of total run time (0.148711 user, 0.016233 system)
  [ Run times consist of 0.012 seconds GC time, and 0.153 seconds non-GC time. ]
  98.80% CPU
  450,921,876 processor cycles
  58,092,976 bytes consed
  
T
* 

non-GC timeを見ると、spもpもあまり違わない。pがすこし遅い
consの数は

s-p-sp順
          s        p      sp
total   0.119  0.164   0.165
non-GC  0.109  0.162   0.153
cycles   320M   442M    450M
cons    52.5Mb 93.0Mb  58.1Mb

こうしてみると、consの数はp>spだが、cycleはspのほうが多くなっている。
処理時間については、s>p>spだが、pとspの差はそれほどない。
GCの時間をみるとp,spよりもpのほうが少ないのは偶然か?

順番を変えてp,s,spの順で実行してみた
T
* 
(performance `ito-unificationp PN)
(performance `ito-unifications PN)
(performance `ito-unificationsp PN)
** ITO-UNIFICATIONP of 10000 times**
Evaluation took:
  0.172 seconds of real time
  0.170481 seconds of total run time (0.168257 user, 0.002224 system)
  [ Run times consist of 0.005 seconds GC time, and 0.166 seconds non-GC time. ]
  98.84% CPU
  463,369,783 processor cycles
  92,961,872 bytes consed
  
NIL
* 
** ITO-UNIFICATIONS of 10000 times**
Evaluation took:
  0.113 seconds of real time
  0.112033 seconds of total run time (0.111277 user, 0.000756 system)
  [ Run times consist of 0.003 seconds GC time, and 0.110 seconds non-GC time. ]
  99.12% CPU
  303,392,274 processor cycles
  52,461,568 bytes consed
  
NIL
* 

** ITO-UNIFICATIONSP of 10000 times**
Evaluation took:
  0.130 seconds of real time
  0.129126 seconds of total run time (0.128284 user, 0.000842 system)
  [ Run times consist of 0.003 seconds GC time, and 0.127 seconds non-GC time. ]
  99.23% CPU
  349,702,717 processor cycles
  58,063,936 bytes consed
  
NIL

p-s-sp順
          s        p      sp
total   0.112  0.170   0.129
non-GC  0.110  0.166   0.127
cycles   303M   463M    350M
cons    52.5Mb 93.0Mb  58.1Mb

s-p-sp順(再掲)
          s        p      sp
total   0.119  0.164   0.165
non-GC  0.109  0.162   0.153
cycles   320M   442M    450M
cons    52.5Mb 93.0Mb  58.1Mb

totalは関係ない処理も含んでいるので比較しても仕方ない
non-GCは、spがかなりずれている。
cyclesはなぜこんなに違うのだろうか。
ランダムな要素はないので、みんな同じにならないのはなぜか??
cyclesにはGCの処理も含まれるのか?

この結果からは、
処理時間については、pもspもsより時間がかかるのと
pとspの違いは逆転もするので、なんともいえない。

一方で
consは順序によらないので、処理の特徴をとらえていると思う。

consによると、sを1としてpとspは
        s     p    sp
cons比  1   1.8  1.11

となり、p-notのmguを作るにはspのほうが軽処理になっている。




20200627土
unificationの性能測定をしよう
unificationのp,s,ps

とくにpとsの比較が必要。

spは、pのあとにp2sをやっているので、性能がでないのは当然

代入の性能も調べるべきか? unificationの中で代入しているので、分けなくてもいいような気はする。
とはいえ、代入だけの性能も調べるべきか。

play-disag.lispがいままでの中で一番完全なので、これだけ調べればよいだろうか。
disag版とそうでないやつの比較も必要。
disag版は高速にするために作り直したのだから、高速になってないといけないので、その確認。
とはいえ、非disag版が不完全なunificationになっていたら、比較の意味がない・・・

方法
1. ito-unificaitonsとito-unification-pのテスト項目を同じにして(関数をパラメタにとるように
　すべきか?)
　それぞれのitoの実行時間を計測する。
　代入のpとsでデータ構造が違っていること。

結果
実行方法
(time (dotimes (i 100)(ito-unifications)))
(time (dotimes (i 100)(ito-unificationp)))
(time (dotimes (i 100)(ito-unificationsp)))

結果
ito: unifications is snot unify
......................
Evaluation took:
  0.002 seconds of real time
  0.002100 seconds of total run time (0.001871 user, 0.000229 system)
  100.00% CPU
  5,738,598 processor cycles
  524,288 bytes consed
  
  ito: unificationp is p-not unification
......................
Evaluation took:
  0.004 seconds of real time
  0.004096 seconds of total run time (0.003722 user, 0.000374 system)
  100.00% CPU
  11,057,668 processor cycles
  917,504 bytes consed
  
  ito: unificationsp after unifications, s2p makes p-not
......................
Evaluation took:
  0.003 seconds of real time
  0.003419 seconds of total run time (0.003020 user, 0.000399 system)
  100.00% CPU
  9,301,424 processor cycles
  589,824 bytes consed
  
評価
sよりpが2倍くらいconsしていて、処理時間も二倍に近い。
spはpを高速にするために作ったものであり、結果もそれに従っている。まとめると
s > sp > p
p-notのunifierを得るには、spがよさそう。

このテストデータには偏りがあるはずなので、結果は無条件には成り立たないかも。
想定に一致するので、信じてしまいそうになるが、別の偏りのあるデータだとどうか。
次のTODO
表現の種類による性能の違い
たとえば
・insideが発生してNOになる表現ばかりのばあい
・複雑だがunifiableの表現の最後でa!=bでNOニナルバアイ。
　　おそらく、失敗する例は性能よいのではないか。最後までやらないで終われるから。
・unifyする項目がいきつもどりつして成功する場合
  これがテストを作るのも大変・・・
・引数の順番を逆にしたとき性能がどうかわるか。
　順番に代入が作られていく場合と、代入が逆流していく場合。
　*disag-unificationで、別のunificationを呼び出す場合<x:y>だったのが、disag処理で
　途中までの代入の適用で、<x*s1:y*s1>=><e1:e2>となるケース。
　? unifyのパターンがそこで変わってしまい、性能に影響するか?

🎂 このケースは、disagだからおきる。
　<x:y>でも<x:e>でもdisag pairについて、他の部分で発生したσを適用してからこの
　pairの解決が必要になる。
  <x:y>で考えると、本来変数同士の比較なので、特別な必要がないはずなのだが
　unificの中で再びunifyしなくてはならないのが根元。

　ではこのパターンは、非disagでも性能が遅くなるのか?


  












20200620土
unificationpとunificationspのテストを追加し、動作確認した
unificationspは、unificationsを呼んでいるだけだが、NOがかえってくる場合いったん介入する必要があった。しくなかった

unificaionsは、makesubsubpなどの処理を見直した。makesubsubsの真似をしただけ。

意図はもっと複雑なものを考えるべきな気がする。
・(x:y)の両方に代入がかかって、(t1:t2)になってふたたびunifyするパターンが不十分ではないか

・さらに、t1,t2の中でふたたび同じ現象がおきル場合とか・・・



20200614土日
catch-throwの仕組みを勉強して、
unify?を呼び出すところをunification?にしてcatchとし
NOをreturnしていたところを(throw 'unification? 'NO)にした

20200607日

TODO20200606: vとeがftermになる部分のテストは未。テストは作った。
　これは一番単純な場合なので、複雑なテストも必要
 014 unifics v e with m again: Ito Failed at (ITO-ALL-DISAG ITO-UNIFICS)
   Expression: (UNIFICS '(X) 'X 'W '((X F Y) (W F A)))
    Intented ((X F Y) (W F A) (Y . A))
    Evaluated: ((X F Y) (W F A) ((F Y) F A))
原因
　内側でおきる<(f y):(f a)>に何もしていない
・実装の継続
これはトップレベルが変数で、それらに対する代入の後、unifiableな例
 014 unifics v e with m again: Ito Failed at (ITO-ALL-DISAG ITO-UNIFICS)
   Expression: (UNIFICS '(X) 'X 'W '((X F Y) (W F A)))
    Intented ((X F Y) (W F A) (Y . A))
    Evaluated: ((X F Y) (W F A) ((F Y) F A))
調査
　内側でおきる<(f y):(f a)>に何もしていないのか
　これは途中経過のテストのつもりだが、このような状態がおきることはあるのか。
　この状態になるはずのm=()の意図を作ってみた。
  unificsの016,017。途中でこのような状態にならない。

　この意図は問題をおこせない・・・

  これは最初どういうunificationから始まるのか
  unificsの020はNOが意図だが、この例になった。

  unificsとmakesubsubsにtraceをかけてみると、たしかに内側のdisagをしていない

  -- makesubsubsでunifysを実行したあとのトレーす

* (unifics '(x y z w) '(h x (f z) (g x) b z) '(h (f y) w (g w)  y a) ())
  0: (MAKESUBSUBS (X Y Z W) NIL X (F Y))
  0: MAKESUBSUBS returned ((X F Y))
  0: (MAKESUBSUBS (X Y Z W) ((X F Y)) W (F Z))
  0: MAKESUBSUBS returned ((X F Y) (W F Z))
  0: (MAKESUBSUBS (X Y Z W) ((X F Y) (W F Z)) (F Y) (F Z))
    1: (MAKESUBSUBS (X Y Z W) NIL Y Z)
    1: MAKESUBSUBS returned ((Y . Z))
  0: MAKESUBSUBS returned ((X F Z) (W F Z) (Y . Z))
  0: (MAKESUBSUBS (X Y Z W) ((X F Z) (W F Z) (Y . Z)) Z B)
  0: MAKESUBSUBS returned ((X F B) (W F B) (Y . B) (Z . B))
  0: (MAKESUBSUBS (X Y Z W) ((X F B) (W F B) (Y . B) (Z . B)) B A)
  0: MAKESUBSUBS returned ((X F A) (W F A) (Y . A) (Z . A) (B . A))


(B . A)て何か??

vsにBははいっていないから、定数同士でNOニナルノデハ??

(B.A)がでてくる理由
  makesubsubsの最初atom判定していたが、これだと定数でもいってしまう。
　はisvar判定に変える必要があった。
　そしてどちらも変数でない場合はNOにする。

　だんだん処理がふえる・・・いいのか

　unifysからきたとき014と015は発生しないのだろうか。

 014 unifics v e with m again: Ito Failed at (ITO-ALL-DISAG ITO-UNIFICS)
   Expression: (UNIFICS '(X Y) 'X 'W '((X F Y) (W F A)))
    Intented ((X F Y) (W F A) (Y . A))
    Evaluated: ((X F A) (W F A) (Y . A))

 015 unifics v e with m again: Ito Failed at (ITO-ALL-DISAG ITO-UNIFICS)
   Expression: (UNIFICS '(X Y W) 'X 'W '((X F Y) (W F A)))
    Intented ((X F Y) (W F A) (Y . A))
    Evaluated: ((X F A) (W F A) (Y . A))

となっているので、(Y.a)が(F y)にsubstされるということか。
それは意図が間違っている

　意図を修正してパス。

　処理量を考え直すべき

確認)
  unificsがNOヲカエシタトキドウナルノカ?

・019 unifics 追加
　意図の目的は、2 innerだったが、NOガトチュウデハッセイスル令になっていた

　問題ないみたい。



・内側の複雑な場合


20200606土曜
まず、前回残していた意図外れをあわせよう
1) insidepを作ること
2) v:eに対して<v*m:e*m>で再びdisagreeになる件の明確化

1)をまず実装する
・insidepのトップではx:xがNILになるのでinsidepとinsidep0をわける
・makesubsubsの中でvとeのinsidepをテストしたが
 020 unifys: Ito Failed at (ITO-ALL-DISAG ITO-UNIFYS)
   Expression: (UNIFYS '(X Y) '(F X X) '(F (G Y) Y))
    Intented NO
    Evaluated: ((X G Y) ((G Y) . Y))
　となる。
変数のXに(x. (g y))を代入して(g y)になっている。変数がわがf-termになったので
こうなっているらしい。

makesubsubsの中でもう一度vとeの向きを決めるのか?
だとするとここでdisagの再実行がおきるのか・・・

・vとeがftermになる部分のテストは未でその前まですみ


20200531日
- play-disag.lispの定義順序を整理する
  snotで作ってpnotには最後にs2pで変換する
　　これの計算量もみておきたい

- ito-disag.lispも合わせて変更する

- 足りないものは何か?
  - insideは未★
  - 深いところから上にもどつたとき -- 不十分
　- 複雑なunifの意図も作ってみたが、深いところから上にもどるようになっているのか??

- 不要なものを削除した

- unifyspとunifypの名前を交換した
　unifyspがunifysしてs2pでp-notにするのでunifysp
  unifypは、fnからp-notにしているはず　★要確認

s2p, p2sをunifyより前に移動

ito.lispで意図は違うけど、今はここまでにしている、みたいなのはいらないか
たとえば、intend-notequalで、バスしても実はこの意図は違うというようなの必要か

間違った結果にならないという意図はどうか?
intenでなく、exceptみたいなものかな
(except-notequal "2+1 は3以外になってはいけない" 13 (+ 2 1))
みたいなことが書けた方がよいのかも

意図は意図なのでintendか・・・



20200530土
disag版の作成中
🕷 unifypの結果のσで、左に定数がきたりする・・・
  makesubsubsで、d2が変数のときも、d1を左にしていた

🕷 unifysで、変数リストでなく出現順にσが作られていく
　これは🕷ではない。当然そうなる。

🕷 追加意図 
  017 unifyp: Ito Failed at (ITO-ALL-DISAG ITO-UNIFYP)
   Expression: (UNIFYP '(X Y Z) '(F Z (H Y) (H (H B)))
                       '(F A (H (G X)) (H (H X))))
    Intented (B (G B) A)
    Evaluated: (X (G X) A)
　・Xへの代入が後だからか、YへのXの代入とか無視していて正解なのか???
　　s2pの問題??
  ・unifysをしてs2pで正解になる。
　　unifypをそのように修正した
　　テストok







20191217火
1. Genieのaddはできてもusingでエラーになった
　updateしてbuildしたら動くようになった


20191214土
1. testunify.jlにUnification theoryの例を追加した
   testunify.jlは動いた
2. viewprover.jlで、Genieのupdateに失敗・・・ネットにつながっていないからかも。


20191109土
1. 実装でいくつかアイデアができて、ソースも整理したくなってきた。
　いろいろアイデアがでてきて考えきれないので、すこしコードにもどりたい。

　名前がいろいろ必要

 作りたいものは、たんなるproverではなく、いろいろしたい
　たとえば、cluaseを追加してaxiomが変化するときの状態をみるとか
 

20191026土
1. prover のlimitterとして成功した回数にしよう。
　resolution以外もあるので、どう数えるか・・・
  core.proofの要素数にしてみよう

20191022火
1. cirf001.cnfで、axiomsからmalの行をけしてみた
 [d].[-Dev(d,on,black,charged),+How(d,mal)]

goalをこうして
[d,w].[+Dev(d,on,black,w)]

wにはmalfunctionがこないので、異常の原因を探しにいくことができない。

2. malになったとして、原因をどう調べるのか問題
cirf003.cnf

 1) Cause(d,cau)を導入
 2) テストに失敗した場合+FailX(x)を追加する
 3) current fact -> Mal() -> dispatch test -> Cause with fail

という流れ

全体のprover flow
1) malfunctionかどうかの証明(cirf002b.cnf)
2) テスト対象の発見
3) テスト結果(Fail=Fact)の追加により、どこでエラーになっているかがわかる
これは、テスト対象を示していない。
4) 失敗したテストをFact Fail(x)にしているのは直感と反する。というか
　テストに成功したほうをFact Test(x)と書いてもうまくつながらなかった。
　なぜ??
5)成功したほうを-Fail()とかくと無視されてうれしいが、
　相手のいない述語のリテラルが消えないという理由だけで、
　-Fail()は書かなくても無視される。(ないから)
　明示的に書いているこのと意味は?
6) 証明を作るということと、できるかぎり多くの証明から情報を集めるというのは
　目的が違う。現象の解釈も違うのでは?

[] 手順
(1) 知りたいことをgoalにして書く
　・正常・異常という概念はメタな概念であり、書かなければわからない。
(2) Factは2種類
　1) 現状の装置の状態をしめすFact
　2) テストの結果であるFact
　まず、1)のFactを含む証明から、正常か異常かを判定
　異常の場合、テスト結果をFactとして追加して、それが原因かどうかを

　いやまて、テストがFailしている段階でもうそれが原因と考えられる・・・
　FailのFactはよくない。

　テストというものがFailしたらまずいというものなので、そうなってしまうのか・・・

　ちょっと考えていたことがずれていた。






　


3. いくつかの問題
1) cirf002d.cnfで、conjをC and Dにしてみたが、終わらなくなった
2) 




20191021月
回路は、QAの例になっている。
そこでは質問が必要になる。

1. cirf001.cnf
　何を質問すべきか?
　何を尋ねることができるか。

1.1
　まず、この装置が正常か異常かを問うてみよう。
　となると正常か異常かを表す述語が必要になる。それをHow(how)とする。
　Dev(d,sw,lamp)は装置の状態を示す。

　cirf001.cnfは、axiomsで、ground levelでgoodかmalかを書いている。

　正常・異常というのは、具体的な装置の構造の性質ではない。
　装置を観測するとは、装置の違いを示せる部分についての解釈が状態と呼ばれるもので、
　その状態を述語化したものが観測。

　と考えると・・・

　swとlampは装置の状態を示す2つの部分。
　swをonにしたらlampがwhiteになるとかいう因果関係はありそうだが
　ここではそれは考慮しない。状態にのみ着目する。

1.1.2 正常異常以外に問うことのできる状態は何があるだろうか。
1.1.3 もうすこしhop数を増やしてみたい。
1.1.4 たとえば、故障したとき、その原因をどう調べればよいか。

1.2 cirf002.cnfはバッテリーもふくめたもの
1.2.1 この例では、axiomに変数anyを含め、sw=offのときは、batteryがchargedでもemptyでも
　　　lamp=blackになることを書いた。それはうまく働いて[]がでている。


2. ちなみに、この場合、知識をclause集合K, 質問をQ、回答をAとすると、Aは

　　A = Kσ、A <= Qτ

　　になる。つまり、答えは質問のインスタンスになる。
　　もちろん、Kのどれかのインスタンスでもなくてはならない。

3. 状態を定義する。解釈を定義する。状態についての質問を作る。ということなのか?
3. 状態を定義する。解釈を定義する。状態についての質問を作る。ということなのか?
3. 状態を定義する。解釈を定義する。状態についての質問を作る。ということなのか?



20191019土
1. DVC proverが間違っていないような気がしてきたので、それを前提とすると
　どのようにproverを作らなくてはならないかを考え始めている。
  about_prover.txtで書き始め

2. 回路の例を考えていくと、どう書くかもはっきりしないが、その理由は
　何を書きたいかがはっきりしていないからと思えてきた。

　何を書いて、何がわかるのかを考えている。what_problem_to.txt書き始めた。


20191013 日
1. cire002.cnfで lamp=black, sw=off, bat=charged をやってみた。
　証明できているが、よくわからない。
  printproofs1()で証明の詳細、printmgu()で個別のproofのσをみられるようにした。

2.cire003.cnf
 1) Dとdはいらないので消した
 2) resolventの数も増えてきたのでprintmgusにしろprintproofsにしろみにくいから
　  printcontradictions()を作って[]の証明の深さ(depth)をprintするようにしてみたが
　　全部10になって、区別がつかない。

    printdepth(cid, core)はdepthを表示する。追加した。
    printの最後に[]の数を表示するようにした


20191012 土
1. 回路を全部書いてみた cire001.cnf
　部品とその状態をわけて書かなくてはならないのだが
　うまく書けていないと思う

2. 今の書き方だと、部品はその全状態に等しいと考えている。
部品完動と電流の流れの部分をこんなふうに書いている。

[a,B,b].[-WorkB(a,B,b),+Curr(a,charged,b)]
[a,B,b].[-WorkB(a,B,b),-Curr(a,empty,b)]
[a,B,b].[+WorkB(a,B,b),-Curr(a,B,b)]

そして電流の流れについてこんなふうに書いているから

[d,x,y,z].[-Curr(1,x,2),-Curr(2,y,3),-Curr(3,z,1),+Curr(d,x,y,z)]

混乱している。

部品とその状態をどう関連付けるか。

P(.., p, s, ...)

と書いてみたが、たとえば回路の部品の順番が固定されてしまう。
# I want to write as this, but no Curr but CurrX
#[d,p1,p2,p3,x,y,z].[-Curr(1,p1,x,2),-Curr(2,p2,y,3),-Curr(3,p3,z,1),+CurrD(d,x,y,z)]
[d,p1,p2,p3,x,y,z].[-CurrL(1,p1,x,2),-CurrS(2,p2,y,3),-CurrB(3,p3,z,1),+CurrD(d,light,y,z)]

たぶん、CurrXとCurrがunifyできなくてはならないのかも。単に述語記号からXを消すだけなら
[L].[-Curr(L,1,x,2)...]
とか書けばよいが、このLは定数になるので、
[d,x,y,z].[-Curr(1,L,x,2),-Curr(2,S,y,3),-Curr(3,B,z,1),+CurrD(d,L,light,y,z)]

かな

そうなるとWorkXも同じように描きたくなる。

そもそもneg側のx,y,zには何がはいるのだろうか。
そこは部品だから、pos側のy,zが状態なので型のミスマッチになる。

柔軟さと情報の完全性がうまく書けない。

部品と状態と型をわけるのか?

SW, sw, {on,off}
swはスイッチの名前
SWは部品の名前('スイッチ')

+Work(SW,sw) 
+Curr(p1,SW,sw,p2)

回路の点はp1,p2 定数
この文脈では定数でいいのか。

Curr自体はどこでも成り立つので変数を使う
Curr(x,P,y)
部品Pがxとyをつないでいて、電流が流れる。

直流の+と-はどうなるのか??

3. 再検討

部品の名前と、その状態を(D,d)とかければいいが、
今のProverでは書けないので、述語の引数として D,d,と書くことにする。

Work(p1,D,p2)
p1,p2は位置の定数でなく、変数であってほしい。
しかし、そこに電位差があり、電流が流れる状態でないとDがWorkかどうかわからない。
Dは特定の部品の名前であり、ここでは状態については述べない。
Dが動作しているかどうかの判定に、電流が流れるp1,p2が必要なのでp1,p2を含めている。


Curr(p1,D,d,p2)
Currは電流が流れることを言っているので、p1,p2は具体的な回路の位置を示す。
だから、定数で表されるだろう。
回路の点は、その回路における点なので定数になる。
Dは部品名でdは状態。
だとすると、Currは電流が流れることだけでなく、そのときの部品の状態も書いている。
分けよう。

たとえば、
[p1,p2,D].[-Work(p1,D,p2),+Curr(p1,p2)]
か。

これはp1とp2の間にDを置くとDが機能するならば、p1,p2の間に電流が流れている
ということ。

[L,S,B].[-Conn(p1,p2,L),-Conn(p2,p3,S),-Conn(p3,p1,B),
 +Curr(p1,p2),+Dev(L,white,S,on,B,b)]

は、p1とp2の間にLampがあって、p1とp2に電流が流れていれば
その装置の状態は、L=white, S=on, B=b になると言っている

Devは、装置全体としての状態の記述。
装置の名前Dがなくても大丈夫か??

回路の構造を
[L].[+WorkL(p1,L,p2)]
[B].[+WorkB(p2,B,p3)]
[S].[+WorkS(p3,S,p1)]

と書くとConnとの対応が必要になるが、それは必要か?

WorkXは位置は関係ない。
しかし、任意の位置について確認したわけではないFact。

これで書いてみた

cire001.cnf
goal: [].[-Dev(L,white,S,on,B,b)]

[]は3つできている。
詳しくみなくてはならない。


☆ 同じFactは繰り返し使われない

4. 同値をそのまま書くと、空代入のループができてしまう。
　そこの対処もいずれ必要かも。
　goalによって方向がはいるので、ループが回らなければいいのかも。
　あるいは、先日考えたように、空代入はスキップ可能と考えるとか。壁になるやも。
 

20191006 日
1. つづき
  proverがおかしいのかもしれない

2. もっと単純にした場合、sw=onでlampはつき、(cird001.cnf)
  sw=offで lamp=blackになった。(cird002.cnf)
　Workは部品ごとに違う名前にする
　変数にしていないものがあった。これはこれまでもよくあった。
  変数にしないからunfiyできない。

3. 待てないくらいに終わらないのは、🕷かもしれない。
  他にも、いろいろ不安。

4. +Dev(dev,d,lamp,l,sw,s,bat,b)のように書いたらどうだろうか。
　中身を全部書くのはおかしいけれど、


201910015 土
1. 回路cirb001 機能と構造をわけたものの見方について検討中
2. なぜか1回、resolutionに失敗してそこから先にすすまない。
　resolventがでないとてがかりがない

20190929日
1. view prover(vcirc004.cnf)では1つしか[]をみつけられないということに気づいた
　cnfでは、複数の可能性について書いているのに、1つしかみつけられない。

　ここは、cheaplogicdata/circ004.cnfで全部みつけるほうがよいような(状況によるか)
　気がするので、やってみた

2. DCについての期待(DC2,DC3,DC4,DC5)を書いた。
　　Factはgoalのみ
   *発見
　まず、DC2->DC3でemptyのパスだけのときは意図どおり、emptyをみつけた
　次に、DC4を追加すると、emptyとcutの両方がみつかる。
　DC5まで追加しても同じ。

　そこで、テスト結果として、connのFactを追加した。DC5でconn
　これをすると、[]{conn}が追加されただけだった。

　つまり、テスト結果として特別扱いされていない。

　テスト結果は、期待とは違う扱いがなされなくてはならないということか。

　たぶん、テスト結果のFactは生成される[]で必ず使われなくてはならないのではないか?

　だとすると、Goalと同じ類のclauseということになる。

　つまり、Goalは1つではなく、Goal setとして与えられ、Goal setのclauseは
　proofにすべて含まれなくてはならない。
　というような仕組みが必要ではないか。

　もうすこし、実例を手で計算してみよう。

　ExpectとFactの違いはここではないだろうか・・・


3. canoを使うよりKeywordのほうが、見やすいような気がしてきた。


20190928土
1. やることを整理
   参照:todo20190928.txt

2. 回路を見直したら、記述のレベルがあって、レベルからレベル
　　への遷移がおきるような仕組みがよさそう circ004.cnfで試し書き
   未完

3. stepでevalのときどの述語でevalしたのかわかるとよい。

4. evaluateの中でisProc()でないときなぜかgroundかどうか判定していたが
　groundであるだけでliteralを消してはいけないだろう。
　その部分のコードをコメントアウトした。
  viewreso.jlの94-97
　何か問題がおきるだろうか?
　あとproofの関連性がわからなくったような・・・

5 .load_cheaplogic.jlの順番が間違っていた
   primitive.jlとcommon.jlが逆


20190921土
1. 制御をもっとクリアにできないか。
   20190906にもやろうとしたが、できている気がしない。　


20190908日
1. ソースを読み直していると、lsymof()のような関数はprimitives.jlに
　あればよいと思うが、なんとかreso.jlに定義されていたりする。
　違う概念に同じ名前がついていたり・・・refactoringをした。
　lsymが、literal symbolという意味とlogical symbol(in parser.jl)
という意味で使われていた。
　それで整理した。

  test_*.jlは一通り確認した。


20190907土
1. argsof()を追加
　Exprでリテラルとtermを表現しているために、この二種類を区別できない。
　しいていえば+/-の有無が違うが、それをみてliteralかf-termかを判定するような
　ことは書きたくない。不要な計算がはいるから。
  tag をつければよいけれど、それはそれで単純でなくなる。

2.　単純というのが、何についての単純なのかははっきりさせなくてはならない。
　それが違うと話がかみあわなくなる。

3. dvc_reso.jlとkp_reso.jlに同じ関数が定義されていた。
　この二つが同時に動くことはなく、kp_reso.jlは、もう使うことなどない
だろうと思ってきたが、いちおう整理することにした。
　View proverでQAシステムを作るとき、kpがあるとよいような気もする。
　でも、機能的にはdvcと変わらないので、何かしたいという気にはなれない。


20190906金
1. vlogic.jlのソースを見直した
どうもgoalproverの処理が混線していると感じる。

2. half 🕷 goresolve()でくるはずのないところでceaseview()を呼んでいるような気がする。
きたらわかるように@warnをいれておく

3. 🎂 goal::list(lid) の各lidについて
 - oppositがあるかどうか
 - canoがあるか
 - Procかどうか

を判定したい

3.1. その前に、Exprに関するprimitiveを作った。
　signof(::Expr)とかlsymof(::Expr)みたいなもの。
  e.args[1]とか書きたくない。
　ひとそろい作ろうか・・・

3.2 Exprは、LiteralだったりAtomだったりtermのリストだったりする
clause2of()::CForm2
CForm2=(cid, vars, body)のbodyはExprのArray

literalof()::LForm2
 LForm2=(lid, body)
 bodyはExprのArray


20190901日
新しいcirc004.cnfを試してみた。内容はabout_circuit.txt

正常な場合、cw=on & lamp=lightのときはすぐに[]になるので
異常ではないことがわかる。

sw=on, lamp=blackだと質問してくる
pow=charged, wire=discで[]になる


🕷 printmgu(:R1, core, true)で
julia> printmgu(:R5,core,false)

R1:<L3:L3>=x/black;y/on;ERROR: BoundsError: attempt to access 4-element Array{Symbol,1} at index [5]
Stacktrace:
 [1] getindex at ./array.jl:728 [inlined]
 [2] printmgu0(::Array{Symbol,1}, ::Array{Symbol,1}, ::Bool) at /Users/shin/Projects/github/cheaplogic/Prover/coreprint.jl:214
 [3] printmgu(::Symbol, ::CORE, ::Bool) at /Users/shin/Projects/github/cheaplogic/Prover/coreprint.jl:232
 [4] printmgu(::Symbol, ::CORE, ::Bool) at /Users/shin/Projects/github/cheaplogic/Prover/coreprint.jl:225 (repeats 4 times)
 [5] top-level scope at REPL[35]:1

になる。
debuggerでみると
printmgu0の中で

1] sigma: Symbol[:black, :on, :z_C1, :w_C1]
3] ovars: Symbol[:x_C1, :y_C1, :z_C1, :w_C1, :x_C1, :y_C1, :z_C1, :w_C1]

長さが違うので、overrunしている。

単にくっつけたな。

printmgu()でprintmgu0()を呼ぶときこの変数リストをovarsof()で作っているが
leftとrightのovarsをくっつけているのが敗因。
step.ruleが:evalと:viewのときはleftだけにする
解決



昨日考えたことをまとめた。
about_circuit.txt

cnfの中身をgoalを除いてdescriptionと呼ぼうかと思う。
前はaxiomsと呼んでいたような事柄。

descriptionのclauseはいまのところ次の3つに分かれる。
もっとあるかもしれない。

1. Fact

2. Premise

3. Unconfermed


20190831土
今日は成果なし

eval-view-reso(EVR)の制御を明確にしようと考えた。
まず、viewといっているものは全部、いわゆるDialogで、画面にメッセージを出して
すぐに帰ってくるものだけ。

だから、そのループが単独の関数としてかければよい。

1つのtargetでWebループをまわしたとして、Webのデータの制御とEVRのループの
間で同期をとる必要があるように思える。

たとえばwebの最初のtargetまで制御がいくと、そこでWebはrequestがくるのを
待ち続ける。
そこで表示すべきhtmlをEVRで作ると、それが表示されるような制御になると考えている。

結局、webの制御と平行した動作を書くことになる。
Genieのappの仕組みが使えないかみてみたが、途中でgiveup。

きれいな表現がないものか。

きれいな表現にするということは、そのしたのレイヤーに複雑なことをまかせる
ということになるが、そこはそこできれいになっていないといけない。

今日は何も進展がない(12:30)


20190825日
昨日のつづき

R2でcan't progressになる
1. can't progressの理由は??
  glidのopponentがないため。
　templateができていない。

  goreadcore()でalltemplateof()をしていなかったためにlevel0ができていなかった。

　修正した。templateはできたが、can't progressはかわらず。なぜか?

  KCは+も-もあるので問題ないと思うがどうしてか
  ↓が先か

2. R2の変数にblackとonが代入されていない。R1にはあるので、resolventの作り方がおかしい
　きのうはできていたような気もする。昨日の修正の影響か??
  L2_R1をresolveすると、blackとonが消える。

  addnewclauseのσに値を設定してみているが、間違っているかも。
　一度、全体を見直す。

  -VSW(on)というのができているが、これはgroundなので消せばいいようなきがする。
　つまり、cannoでgroundだったら消して良い。
  これはviewの前にやりたいので、evalの中でよい。

　条件の時、literalを消して新しいgoalを作りたいのでevalでやるとめんどう。
  似たような処理はviewでやっているから、viewでやりたい。

　choosecanoidでは、isCano()判定しているのでisgroundをみればいいような気も
　するが、それでidを残していっても消すときがいつかくる。

  VSW()とVLAMP()はいらないけど、どういうふうにはずすか?

  とりあえず-VSW()と-VLAMP()をはずしたが同じ。

　もしかして-ではなく+限定か?

　たぶん単純な間違いのような気がしてきた。cnfの間違いの可能性もある。

  [+DC(),-KC()]にしてみたが同じ。

R2:[z_C7R2,w_C7R2]. L6_R2.-(KC(black, off, z_C7R2, w_C7R2))
ができていて
C3:[]. L7.+(KC(black, off, charged, conn))
があるのに
ceaseview()にくるのはなぜか??

R2ができたあと、なぜかそのままceaseview()にながれている

goresolve()でresolvelid()のあとgidがかえってきたら
contraかceaseのどちらかになってしまうが、
resolutionが成功すればgidがかえってくるのでこの制御は
おかしい

 resolventができたときの処理が抜けていた。

 作ったら通った。

3. [x,y,z,w].[+DC(x,y,z,w),-VPOW(z),-VWIRE(w),-KC(x,y,z,w)]
のように書くと、POWとWIREのVIEWが両方聞かれる。
たしかにそうかもしれないが、POW(emtpy)ならそれでlamp(black)ではある・・・
原因をすべて確認するというやりかただと言えば、論理的でよい。

同様に、sw=on & lamp=lightでも聞いてくる。

ここらへんはcnfの書き方の問題なので、プログラムは一旦完成とする。


20190824土
1. 回路問題のcnfを書いてみている(docs/about_circuit.txt)
 はっきりと書き方がわからない
　resoでresolventの変数がひとつもなくなっている。
  ?) R1からR2にいくとき別の変数が同じになっているような
  vdata/vcirc003.cnv
proof
R1:<L3:L3>=[black,on,z_C1,w_C1] by view
R2:<L2_R1:L4>=[z_C6,w_C6,black,on,z_C6,w_C6] by reso

julia> varsof(:R1,core)
2-element Array{Symbol,1}:
 :z_C1R1
 :w_C1R1

julia> lvarsof(:L4,core)
4-element Array{Symbol,1}:
 :x_C6
 :y_C6
 :z_C6
 :w_C6

julia> stringclause(:R1,core)
"R1:[z_C1R1,w_C1R1].[L2_R1:-(DC(black,on,z_C1R1,w_C1R1))]"
と
julia> stringclause(:C6,core)
"C6:[x_C6,y_C6,z_C6,w_C6].[L4:+(DC(x_C6,y_C6,z_C6,w_C6)),L5:-(VSW(y_C6)),L6:-(VPOW(z_C6)),L7:-(VWIRE(w_C6)),L8:-(KC(x_C6,y_C6,z_C6,w_C6))]"

から

julia> stringclause(:R2,core)
"R2:[].[L5_R2:-(VSW(y_C6)),L6_R2:-(VPOW(z_C6)),L7_R2:-(VWIRE(w_C6)),L8_R2:-(KC(x_C6,y_C6,z_C6,w_C6))]"

R2のvarsが[]なのはなぜか?

[ Info: (:addnewclause, Symbol[:z_C1R1, :w_C1R1, :x_C6, :y_C6, :z_C6, :w_C6], :R1, Any[:L5, :L6, :L7, :L8], Any[])

🎂 fitting_varsでresolutionの結果の変数がひたすら減っていくだけだ。
   変数名のつけかえのあとにfittingをしているのだろうか??

☕️ addstepのrenameσは右と左のσの[-,-]でなくてはならないのに、view proverのreso ではaddstepでそうしていなかった。







20190819月
1. 問題をどう書くか、どう問えるかを考える
  1) 簡単な電気回路(スイッチ、電源、ランプ)を考えて、
     スイッチを入れてもランプがつかない理由を答える。
　　　data/circ001.cnf
　2) どう書くか。関係に着目してFactを書く。
　3) Queryは-P,+Qではなく-P,-Qのパターン(2つのclauseに分かれると、関連がわからなくなる)
  4) 断線の可能性も考慮した版: data/circ002.cnf
  5) Queryの書き方をもうすこし考えるべき


20190818日
1. test_*.jlを確認する
 1) 🕷 test_kplogic.jl でCOREの再定義がおきた。
　　　　COREの定義にいろいろ追加していたからだろう。
    ☕️ kpcore.jlのCOREの定義が古いようだったので、コメントアウトしてみた
       でtest_kplogicは正常にとおった

 2) test_naivelogic.jlは
        kpcore.jlの意味は忘れたが、なぜこのような定義が必要なのか?

###
(vars, t1, t2, σ) = (Any[], :(P()), :(Q()), Any[])
(vars, t1, t2, σ) = (Symbol[:x], :(()), :(()), Symbol[:x])
naiveunify: Error During Test at /Users/shin/Projects/github/cheaplogic/Prover/test_naiveunify.jl:28
  Test threw exception
  Expression: unify([:x], $(Expr(:quote, :(()))), $(Expr(:quote, :(())))) == [:x]
  BoundsError: attempt to access 0-element Array{Any,1} at index [1]
  Stacktrace:
   [1] getindex at ./array.jl:729 [inlined]
   [2] unify1(::Array{Symbol,1}, ::Expr, ::Expr, ::Array{Symbol,1}) at /Users/shin/Projects/github/cheaplogic/Prover/naiveunify.jl:47
   [3] unify(::Array{Symbol,1}, ::Expr, ::Expr) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:302
   [4] top-level scope at /Users/shin/Projects/github/cheaplogic/Prover/test_naiveunify.jl:28
   [5] top-level scope at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.1/Test/src/Test.jl:1083
   [6] top-level scope at /Users/shin/Projects/github/cheaplogic/Prover/test_naiveunify.jl:26
###

   ☕️ unify1(v,t1,t2,σ)の冒頭でt1==t2のとき↑σとした。unify()から呼ぶときはt1==t2のときunify1にこないのだが
　　　ほかのパスがあるらしい
🎂 printcore()よりもprint(stringcore(core))のほうが、cidの順番がみやすい。
   print(stringclause(core))もよいがCanoがみえない。

2. C24 in vev002.cnf, で、ループにおちいっていた。
   C24のリテラルはCanoがなく、resolveだが、opposがない。 
   resolvelid()でnothingをかえすようにしていたが、呼び出し側でloopするviewをつくっていた。
　 failview()をだすようにして解決

　 ただし、failview()の定義をみると、:Failのときに出すviewらしい。
　 can't progressなので同じものを使ったがだめかも
   
3.🕷 C21 in vev002.cnfでViewの値を2つ指定しても、resolventにリテラルが残っている
　そこでconfirmするとき消えるらしい

  - isground(glit)をしていたが、このglitはσoをかけていなかったので変数があり、消されなくなる。
　　factifyはσgをもってきていて、σoでなくσgをかけてground化し、解決
    ☕️動作確認(V[8,6]でR1から-P4()が消えることを確認)

  - V[7,6]とすると-Q(6)ができる。resoで相手をさがすとまず+Q(5)がみつかるがこれではFailになり
　　そこであきらめてしまうのでFail can't progressになる。

　　failになったら他の選択肢をさがすべき。opposがあるかぎり頑張る

    resolvelid()の中のopposのloopで、unify()からICMPがかえってきたらcontinueをするようにした。

    ☕️ 動作確認(V[8,6]で-Q4(6)で[]になることを確認)



4. メモ
　↑X を書いてみたかった

  macro ↑(v)
   return :(return $v)
  end

　としたら

  function a(x)
    if x == 3; @↑8 end
    @↑ 19
  end
  として
  julia> a(3)
  8
  julia> a(23)
  19

とは書けた。





　  
20190817土
1. maxでなく、そのリテラルの前のwhendoit+1にしてみた
今の例では,partialもabortもうごく

結局、サイクリックにまわすことになる

同じwhendoitの中から、ランダムに選ぶようにしても、根拠がないので
今のままにするしかないか・・・

2. よくみると、V40_R1[8,y]にすると、L41_R11[y,z]になってしまう

355  σo = getσo(varc, varg, pm)
357  σo = apply(varc, σo, gvar)
のところでgvarがclauseのvarsになっていて、長さがvarcと違う。
varcはcano(unitclause)のvarsなのでliteralの変数の数だが
gvarはちがう

たぶんgatmの引数部分だけをもってくるべき

357  σo = apply(varc, σo, gatm.args[2:end])
とした。

3.Viewで入力すると、そのインスタンスが一回残っていて、confirmさせられる。
　これでいいのか 🎂

4. 今はViewでCanoリテラルをすべて消去したあとResoに進む
   少なくとも1つViewを解決したらResoに進めばよいような気もするが
　順番はいるのはよくないような気がする
　今のままがよいか



20190816金
1. viewでabortやpartialのとき、次は別のリテラルを選ぶようにしたい
2. しかし、他に選択肢がないときはよい
3. goalの各リテラルについてtouch valueをつける。
　　基本は0。partialやabortやFailしたときはgoalのそのliteralのtouch valueを増やす。
　　0でないものだけ管理すればよい。Dictで。
　　次に対象とするliteralを選ぶとき、touch valueの一番小さいものから選ぶ。

4. まず現状を調べる
 1) V+Rがないので、C21で作る
 2) まちがえて-P4,-R4と-R4(5),-R4(6)とやったが[]になった
    CanoのP4について -P4()と+P4()-R4()という定義にしたためで、-R4にいっていなかった。
　　-R4()と相手のいない場合の例を作った
🕷 3) V[6,-] => viewlogic.jl:324でException varc,σo,varg = [W,Z],[8,Z],[y]
    [W,Z]なのに[y]が1つしかないから。
 4) V[-,5] => これもループ。V[5,5]で[]。
 5) V[-,9] => これもループ。V[5,9]と入力するとcan't progress.
 6) abortするとずっと同じリテラルでループする

5. choosecanoid()を修正した
global DIL = Dict()
global maxdil = 0
を追加した。
関数を追加した
doitlater(glid) glidのカウントを設定する
doitlater(glid, wdi) glidのカウントをwdi+1にする。
どちらもmaxdilを最大値にする

whendoit(gid) gidのカウントを参照する

abortのときは、glidのカウントをupする。
partialのときは、glidとridから新しいglidをもとめ、前のglidのカウント+1にする

choosecanoid()では、lidsをsortするときby=whendoitを指定する。


6. chooseresolveid()を修正する



8. stringclause()でRがCの中にまじっていた。ltid()をRとCを区別するように修正した


20190812月
週末は、小説の整理をしていた。

🎂証明の進展ではなく、proving attemptsについて変化を調べなくてはならない。

証明とmguは対応するけれども、<L:R>がfailしたという情報は、proving attemptsが進んだ
ということを意味するのであり、存在しないmguを見ているだけではわからない。

input literalsのすべての組み合わせ以外に証明で使われるpairはない
(axiomsが変化しない場合)
だから、Lpairsを列挙すると、証明の全体像がみえるはず。
命題とそれに制約をつけた述語。

proving attempts=Lpairsの並びあるいはLpairsの木がprovingの進展状況を示している。


🎂 NTPのワードベクトルのように、input literalでベクトルを作ってうれしいことがないか??
どのようなベクトルを作れば良いか
literalには変数を含むものがあるが、
何で区別するのか

述語記号
リテラル記号
input リテラル

たとえばclauseが似ているということを定義できるか?

literalは述語記号と符号が一致していれば似ているのか

全input literalのベクトルというのが素朴な考えとしてありそう。

変数はどうするか?

cheaplogicの最初の頃に作ったproverもどきは似ているかも







20190809金
viewでかえりのとき、isgroundでなけれぱliteralを消さないようにした。
1. 一部の値を入れてgoalは変化した。🎂
2. 次も同じリテラルのviewになり、🕷
3. 値の決まっていないところはcano変数がでていた。🕷
4. そのcanoViewの値のはいっていなかったところに55を代入したら
2019-08-09 19:24:59:ERROR:Main: ICMP(:Y, 55, :unify0sn)
　となった。変数リストがうまくいっていない。
 vargは[]。
5. view後の新goal(R1のL50のvarsが[]になっている

[ Info: noabort
┌ Info: after_apply
└   (catm2, varc, catm, σo) = (:(P(22, Y)), Any[:X, :Y], :(P(X, Y)), Any[22, :Y])
┌ Info: after_unify
└   (σg, varg, gatm, catm2) = (Any[22, :Y], Symbol[:x_C3, :y_C3], :(P(x_C3, y_C3)), :(P(22, Y)))
[ Info: (:factify_clause, :L50, Any[22, :Y])

applyはいいみたいだが、Yをy_C3に変える代入がない
🎂σgをつくる前にσoにvarc.<catm:gatm>をかけておく

うまくいった





* 直接いけるか? 
 http://localhost:8000/go?op=readcore&corepath=vdata%2Fvev002.cnf
 いけるみたい。

20190730火
vlogicのソースの整理ができた

アルゴリズムの見直しが必要


20190803土
1. viewの制御を見直した。
1.1. viewでliteralを消していいのはViewのもどりがgroundになっているとき
1.2. giveup条件がいくつかある。そこでもgroundが条件になる
1.3. viewで入力しつくしたあとにresoをするようにしたい
1.3.1 ∵ resoでバックトラックが発生したときviewにまで戻れない
1.3.2 バックトラックなのか、総当たりなのかはまだ未定

2. isground()を作成した。with tests

3. viewlogic.jlとviewreso.jlにコメント追加。特に関数のコメント
重要な修正はまだ。

4. stringcore()でclauseの表示順を数字にあわせた。つまり
  今はC12のあとにC2がくるのをC2のあとにC12がくるようにした。
　桁数の少ないものを前にした


20190721日
1. 見てみるとおかしな点はすぐにわかった。修正する(20分)
2. vev002.cnfで確認する

🎂 ViewでだめなときにValidでうまくいったときContradictionはおかしいので
　　UIとしては「証明不可能」とか「証明済」といったメッセージがよいはず。
　　そうなるとHorn clause的な表現がよいことになる。まあそうか。

🕷 vev002/C12 x=8,y=1
[ Info: postview
[ Info: postview
[ Info: postview
2019-07-21 09:19:40:ERROR:Main: type Char has no field lcmap
2019-07-21 09:19:40:ERROR:Main: /go?op=postview&X=8&Y=1&how=confirm 500

2019-07-21 09:19:40:CRITICAL:Main: type Char has no field lcmap
getproperty(::Any, ::Symbol) at ./sysimg.jl:18
cidof(::Nothing, ::Char) at /Users/shin/Projects/github/cheaplogic/Prover/newcore.jl:227
lvarsof(::Nothing, ::Char) at /Users/shin/Projects/github/cheaplogic/Prover/newcore.jl:205
postview(::Dict{Symbol,Any}) at /Users/shin/Projects/github/cheaplogic/Prover/vlogic/viewlogic.jl:322
(::getfield(Main, Symbol("##79#80")))() at /Users/shin/Projects/github/cheaplogic/Prover/vlogic/viewlogic.jl:78

☕️ resolvelid()の中でcatchしていたunifyのfail
　　だがresolvelid()はgidとcoreを返すもので、failからfailview()::htmlが
　　かえってきてもタイプミスマッチになっていた。
    resolvelid()を読んでいる側でcatchするようにした。

🕷 C18のビューがおかしい。

GLID: L31_R1のビューで
{X=x_C14, Y=y_C14}
になり、値を入れてconfirmすると

2019-07-21 10:08:45:ERROR:Main: ICMP(:x_C14, 8, :unify0sn)
2019-07-21 10:08:45:ERROR:Main: /go?op=postview&X=8&Y=2&how=confirm 500

2019-07-21 10:08:45:CRITICAL:Main: ICMP(:x_C14, 8, :unify0sn)
unify0(::Array{Symbol,1}, ::Symbol, ::Int64) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:34
unify0(::Array{Symbol,1}, ::Expr, ::Expr) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:67
unify1(::Array{Symbol,1}, ::Expr, ::Expr, ::Array{Symbol,1}) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:215
unify(::Array{Symbol,1}, ::Expr, ::Expr) at /Users/shin/Projects/github/cheaplogic/Prover/unify.jl:302

🎂 x_C14とかが変数になっていないのではないか






20190720土
1. addnewclauseなどの関数をみなおす
2. addstepを各ruleについて作る(引数違うからできるのでは)
3. 夜中にaddnewclause, addstepで全部書き換えたが、ちゃんと動かない
　細部は明日にする


20190714日
1. 処理を見直す
2. 不要なコードをコメントアウト
🕷 昨日の修正でViewのabortすると、次に他の処理に移らない。
   あるliteralのViewでabortしたら、次はviewでもresoでも別のliteralにしてほしい
　 おなじliteralのresoに進む道もあるかも　要考
🕷 項目に値を入れずにconfirmした場合どうなるべきか
　　1) 今は、その値は無視してliteralが消える。それでいいような気もするが
　　2) 値がないのに消えていいのか?
　　　　- 人間がその値を指定しなかったのは、いずれ決まると考えているからか
　　　　- かといって、その項目を理由にview literalを消さないと、すでに入力した
　　　　　値が無駄になる。その場合は、literalを消さずに残すということになると
　　　　　abortと同じ問題がある
🕷 askUのあとのpostview->factify_clause()の中でevaluate_literals()を繰り返して
　　いるがこれのproofを作っていない
🎂 factify_clause()の367行以降はどこかでもやっていた
　addnewclause()かな
🕸 


20190713土

1. about_viewprover.txt <- howto_viewlogic.txt
  viewproverの概要説明とvev002.cnfのclauseの概要

2. viewで失敗して次のviewにいくかresolveに進むかするような制御を考えようとしたが
　自分の意図が不明確だった
  ViewはFactを作るわけではないので、askU()をすると必ずliteralが消えてしまう。
　C10でP-viewにx,y=10,100などといれると、結果goalはvalidになる。

  ということはViewで中断した場合、literalを消す操作自体をやめなくてはならない。

  askU()が作るhtml(in goalprover():viewlogic.jl)で cancelをしたとき
  たどりつくtargetで、goalprover()のchoosecanoid()を再度実行して
　次のcanoidをみつけられるとよい。
　choosecanoid()をclosureにするか、どこまで確認したかのindexを持つか。
　indexは、resolveに進んだときはresetする。

　ややこしすぎ
　たんにおわればよい

  askUで次のtargetはpostviewになっているが、そこでcancelしたときの
　処理をすればい。

　cancelは、今は入力をなしにすることになっている。
　abortみたいなのが必要かも。
🎂🎂🎂 inputタグのtypeにabortはないか? value??

　makeView2()にabortボタンを追加した。

<input type=\"submit\" name=\"how\" value=\"confirm\"></br>
<input type=\"submit\" name=\"how\" value=\"abort\"></br>

 name属性は、サーバにname=>valueを送信する。

 postview(pm)で、このpm[:how] == "abort"のとき
　goalを変更せずに次のステップに進むようにした。
 htmlは前のをコピーしただけ。

🕷 C12でViewをabortしたら同じ画面にもどった。
　resolveにすすむ予定。
　全体制御を誤解しているかも
🕷 入力に空があったらabortとみなすようにする



  


*** Genieがabandanされた場合にどうするか。
 a) Genieのrepositoryをとっておく
 b) route("/go") とGenie.AppServer.startup()だけ作り直す。
    他のhttpサーバを使って、作れるか???
 c) Genieのかわりのものを作る(bは一部だけ)


20190707日
🎂@showを@infoに変更
🎂ValidのときExceptionににならないようにした
　Validの扱いはこれでいいのだろうか???
🎂-P(x,y)->View->+S(x,y) -> ge(x,y) で[]が出るようなgoalを追加したが
proofはそうなっていないようだ

C15:[].[L28:+(S2(1,2))]
C16:[x_C16,y_C16].[L29:-(P2(x_C16,y_C16))]
C17:[x_C17,y_C17].[L15:+(P2(x_C17,y_C17)),L16:-(S2(x_C17,y_C17))]
C18:[x_C18,y_C18].[L40:+(S2(x_C18,y_C18)),L41:-(ge(x_C18,y_C18))]

P2のcanoを作った

このとき
P2Viewでx,y=1,2の場合はC15で[]
x,y=100,20のときはC17で[-S2(100,20)]になり
C18で[-ge(100,20)]となり
evaluateしてfalseなのでリテラルが消えて[]になる

resolventはできるが、proofができないのはViewだからだろうか。


20190706土
しばらく進展がなかった。resolutionをどうするかでなやんでいたので。

🎂evaluate, view, resolveの処理はいちおう作った。
まったく賢くない。

🎂制御の変更
　1. evaluateは、評価できるものすべてを一気に評価していたが
　　それをするとproofが作れなくなるので、1つevaluateで消すたびに
　　proofを追加するようにした。
　　毎回結果をuserに見せるような制御にした
　2. resolveは、1ステップだけ先に進めるようにした。

  (evaluate^*+view+resolve)^* という感じ。

　revolveの相手はoppositof()で求めるので、ループにはいってしまう
　可能性もあると思う。

　理論的には重要だが、応用の対象をGUIによる質疑応答にしているので、
　実際に、どれくらい複雑なclause集合を使うのだろうかと思う。

　3. Viewでliteralを消す時、proofを作るためにはFact clauseを作った
　ほうがよいような気がする。はっきりしない。
　

🎂P(x,3)からViewのYに3がはいるようになっていた。
　



20190630日
昨日のつづき。

|gvars|=4で|cvars|=2 の差かな

たしかにそうだ。
varg.remにσoをかけようとするとvargとvarcの長さが違うのでこうなる。

lvarの長さを持つσoをclauseのvarsのサイズに拡張しなくてはならない。

σoはbindingまで含めると varc.(varc←σo)

varcとσoの順番とlengthは同じ。(by cnf def)

1. varc.σoをvarg.σgに変換する手順

varcとvargは長さは違うかもしれない。
一致しているものは

gatmのargsをとってくると、|varc| = |gatm.args|
∵ canoはそのように定義するから。

まず順番をそろえる。
(下のclitはcatm, glitはgatmでもよい)

clit2 = varc.(clit*σo)
σg = varg.<glit:clit2>

bindingを示すと

σg = varg.(varg←σg)


ここでnew goalの形はこうなる

vars.rems

このことから

varg ∈ vars なのでvars.σsは

σs=varg.(vars*σg)

と計算できる。
これは、vargの範囲では
varg.σs = vars.σs
それ以外の範囲では等価代入
ε=vars.σs
という意味での拡張になる。


さて、
glitのbindingは varg.glit
goalのgindingは vars.goal

であり

σg = varg.varg*σo

となる。

ここで、varg in vars なので

σs=varg.(vars*σg)

newgoal = vars.(rem*σs)

である☕️

C12は進んだが、reso作っていないようなので、[]まではいかない
C2で例外・・・addstep()でglid0[1]はevalを除いたあとが[]のときindex Exceptionになる。
親のgidl[1]をparentにした

C1から確認
C1 Valid OK
C2 Contradiction OK
C3 View入力でなんでも[] OK
C4 2つのViewでなんでも[] OK
C5 View先、残りevalで[] OK
C6 evalで残り1Viewで[] OK
C7 Viewは後出し。ViewPでx>=yなら[] OK
C7 ViewPでx<yなら[]ができない => validview OK ... 入力が代入されていない
   clauseがcoreに登録されていない
C8 ViewPは先出し。ViewPで>=yなら[] OK
C8 ViewPでx<yなら[]ができない => validview OK... 入力が代入されていない
C9 ViewP{x,y}とViewR{z,w}があり、x>yなら[]、OK
   そうでないならValid... OK 入力が代入されていない
C10  {x>=y}、ViewP{x,y}, ViewR{z,w}, S(y,w) 
　　　y = 1, w= 2, x >=1 なら[] NG Sのresoができず途中
     それ以外はValid ... OK

C12 {x>=w}、ViewP{x,y}, ViewR{z,w}, S2(1,2) 
　　a x>=2, y=1, w=2 なら [] NG Sのresolutionできず。Viewとevaluate部分はOK
    b それ以外はValie(かな) OK 

ここまででいったんcommit

goresolve()追加
うごかない
 


20190629土
・xxxview()でstringclauseを表示するようにした
・/startのところでglobal変数を初期化するようにした。
　続けていると値がおかしくなっていたので(gidが残っているために
　stepを続けているとみなしている)

・lidの表示で、literalも表示しよう
・xxxview()で/startに戻るようにしよう

fixing
・R1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))] cant progress more
ということはProcリテラルは、viewやresoにかからない(resoはまだない)のと
evaluateで変数が残っているから実行できないのでこうなる。

?変数は置き換わらないのか

C7:[x_C7,y_C7].[L15:-(ge(2,1)),L16:-(ge(x_C7,y_C7)),L17:-(ge(5,2)),L18:-(P(x_C7,y_C7))]
なので、まずPのViewがでなくてはならない。
なぜでないのか。
evalauteだけで終わっているらしい。


logをみると

stringcore(core) = "CORE: vdata/vev002.cnf\nCLAUSES\nC2:[x_C2,y_C2].[L4:-(ge(12,5)),L5:-(ge(114,55)),L6:-(ge(115,9))]\nC10:[].[L10:+(S(1,2))]\nR1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))]\nC8:[x_C8,y_C8,z_C8,w_C8].[L1:-(ge(x_C8,y_C8)),L2:-(P(x_C8,y_C8)),L3:-(R(z_C8,w_C8))]\nC1:[x_C1,y_C1].[L7:-(ge(2,5)),L8:-(ge(4,55)),L9:-(ge(5,9))]\nC4:[x_C4,y_C4,z_C4,w_C4].[L20:-(P(x_C4,y_C4)),L21:-(R(z_C4,w_C4))]\nC5:[x_C5,y_C5].[L26:-(P(x_C5,y_C5)),L27:-(ge(2,1)),L28:-(ge(4,2)),L29:-(ge(5,2))]\nC9:[x_C9,y_C9,z_C9,w_C9].[L22:-(ge(x_C9,y_C9)),L23:-(P(x_C9,y_C9)),L24:-(R(z_C9,w_C9)),L25:-(S(y_C9,w_C9))]\nC6:[x_C6,y_C6].[L11:-(ge(2,1)),L12:-(ge(4,2)),L13:-(ge(5,2)),L14:-(P(x_C6,y_C6))]\nC7:[x_C7,y_C7].[L15:-(ge(2,1)),L16:-(ge(x_C7,y_C7)),L17:-(ge(5,2)),L18:-(P(x_C7,y_C7))]\nC3:[x_C3,y_C3].[L19:-(P(x_C3,y_C3))]\n\nPSYM: [P,R,S,ge]\nCANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))\n"
:goalprover1 = :goalprover1
gid = :R1
glids = Any[:L16_R1]
nlids = Expr[:(-(ge(x_C7R1, y_C7R1)))]
:askU = :askU
chooselid = chooselid
gid = :R1
lids = Any[:L16_R1]
lid = :L16_R1
:nocano = :nocano
v = Inf
ix = 1

なので
R1:[x_C7R1,y_C7R1].[L16_R1:-(ge(x_C7R1,y_C7R1))]

★canoのL18:-(P(x_C7,y_C7))が無視されている。

C8は、Viewliteralを先頭に持ってきたが
R1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))] cant progress more
となり

stringcore(core) = "CORE: vdata/vev002.cnf\nCLAUSES\nC2:[x_C2,y_C2].[L1:-(ge(12,5)),L2:-(ge(114,55)),L3:-(ge(115,9))]\nC10:[x_C10,y_C10,z_C10,w_C10].[L4:-(ge(x_C10,y_C10)),L5:-(P(x_C10,y_C10)),L6:-(R(z_C10,w_C10)),L7:-(S(y_C10,w_C10))]\nR1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))]\nC8:[x_C8,y_C8].[L8:-(P(x_C8,y_C8)),L9:-(ge(2,1)),L10:-(ge(x_C8,y_C8)),L11:-(ge(5,2))]\nC1:[x_C1,y_C1].[L12:-(ge(2,5)),L13:-(ge(4,55)),L14:-(ge(5,9))]\nC11:[].[L15:+(S(1,2))]\nC4:[x_C4,y_C4,z_C4,w_C4].[L16:-(P(x_C4,y_C4)),L17:-(R(z_C4,w_C4))]\nC5:[x_C5,y_C5].[L18:-(P(x_C5,y_C5)),L19:-(ge(2,1)),L20:-(ge(4,2)),L21:-(ge(5,2))]\nC9:[x_C9,y_C9,z_C9,w_C9].[L22:-(ge(x_C9,y_C9)),L23:-(P(x_C9,y_C9)),L24:-(R(z_C9,w_C9))]\nC6:[x_C6,y_C6].[L25:-(ge(2,1)),L26:-(ge(4,2)),L27:-(ge(5,2)),L28:-(P(x_C6,y_C6))]\nC7:[x_C7,y_C7].[L29:-(ge(2,1)),L30:-(ge(x_C7,y_C7)),L31:-(ge(5,2)),L32:-(P(x_C7,y_C7))]\nC3:[x_C3,y_C3].[L33:-(P(x_C3,y_C3))]\n\nPSYM: [P,R,S,ge]\nCANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))\n"
:goalprover1 = :goalprover1
gid = :R1
glids = Any[:L10_R1]
nlids = Expr[:(-(ge(x_C8R1, y_C8R1)))]
:askU = :askU
chooselid = chooselid
gid = :R1
lids = Any[:L10_R1]
lid = :L10_R1
:nocano = :nocano
v = Inf
ix = 1

であり
R1:[x_C8R1,y_C8R1].[L10_R1:-(ge(x_C8R1,y_C8R1))]
だからView リテラルが無視されている

★★★ evaluateのあとでgoalを作るときに、Procリテラル以外のものを残すのを
忘れているらしい

evaluateの中でisProcでない場合のelseが抜けていた。
修正したらViewがでるようになった

今度は、
1. R1にはview リテラルのみになった
R1:[x_C8R1,y_C8R1]. L8_R1.-(P(x_C8R1, y_C8R1))

evaluate => R1のとき、今度はevaluateですべて消された
elseのときrgidsにgidをついかするように修正

すると

PSYM: [P,R,S,S2,ge]
CANO: Dict{Symbol,Any}(:P=>(Any[:X, :Y], :(P(X, Y))),:R=>(Any[:Z, :W], :(R(Z, W))))
GOAL
 R2:[x_C8R1R2,y_C8R1R2].[L10_R2:-(ge(x_C8R1R2,y_C8R1R2))]

X,Yへの代入がremにapplyされていない
σoのあつかいがおかしい


viewのσoがもどってきたとき、goalのremの変数名を新しいgidでrenameしているので
canoのX,Yへの代入はヒットしないのだが、
そこはvarsをこのremのvarsにすれば解決するはずでは??

factify_clauseの冒頭で
glid = :L8_R1
σo = Any[:x_C8R1, :y_C8R1]
glit = :(-(P(x_C8R1, y_C8R1)))

σoは入力値の代入だから[5,3]みたいになるはずではないか
R1のvarsもほしい

★ σoを作るときの変数をcanovarsof()にしたら、[]までいったC8,C7

そのあと、変数の数が違うためかExceptionが発生するようになった

そこで今日は力尽きた



20190628金
最初、何度やってもすぐにKeyerror(:R1)で終わった
裏で別のload_viewprover.jlを実行していた。

C7,C8で-ge(-,-)が消えなかった
どうも先にaskUで消えたリテラルのσが残りのgoalにapplyされていないようにみえる

20190623日
load_viewprover.jl 
 - vlogic
  - viewlogic.jl -- html view を作る部分
  - viewreso.jl  -- resolution の部分。logicと分けるのは難しいのか
  - vhtmls.jl    -- html生成関数
  - factify.jl   -- postviewでviewで消したclauseを作り登録する

手順
 include("load_viewprover.jl")

 一方

 vdata/vev002.cnf
 gid = C1 -> eval and => Valid
 gid = C2 -> eval and == Contradiction
 gid = C3 -> 1 Views and => Contradiction <= now here

 after View, Exception occured...

 gid = C4 -> 2 Views and => []
 gid = C5 -> View + exec => []
 gid = C6 -> exec + View => []
 gid = C7 -> exec + View with var => []

global gidやcoreに設定していなかった

それを直したらC4までうまくいった
C5はviewがでてほしいのに、何もしなくても[]になった

julia 再起動してやってみるも同じ
PのViewがなぜかできている

C6も同じ

C7 は空白画面になってしまった


20190616日
*** viewlogic uses a Web Page for a tool for getting FACT, 
I assume the inputs from an human is a fact.
Of cource, human may mistake. The reasonable treatment the input
should be cross check it with Base(Axioms).

*** The problem for an huge number of fact is not cleared.

viewlogic.jlはvlogic.jlをコピーしたが、まだ作っていないので動かない。

vlogic.jlが動く

・Viewの初期値がはいっていない。(defaultvalue? value?)
  修正した
　isvar@goal でないとき初期値にする

・viewreso.jlとvhtmls.jlを思に修正
  viewを作るために、goalからCanoを抜き出して、invarの数(canoにて)が一番少ないものを
　viewのliteralとする。
・ただし、invarの数が0のものがあったら、即決でそれをViewにする。

・askyouを作ろうとしているところ
　ここでhtml作成関数を呼ぶことはできるが、表示はviewlogic.jlからなので
　本当は、そこからaskyouを呼ぶようにする必要がある。ううむ



20190615土
viewreso.jlがsyntaxこわれていたので整理

vlogic0.jlとvhtmls.jl はGenieで targetを/go一個にし
targetの区別をopで行うようにした

実質的には前のvlogic.jlと同じような気もするが、
分岐を1つのrouteで表現できるのでましか。

vlogic.jlはvhtmls.jlと整合しなくなったので、動かない

globalを使っている箇所をsessionID+sessionDataで表現すれば
複数のcnfも扱える


証明の分岐の解決ができていない。




20190614金
・isCano(x,core)を作るためcanoのlsymのリストを作っておくことにした
　これはcoreにいれよう(なくてもなんとかなりそうだけど)

・isProc(x,core)は、procがevalされているので
　isa(lsym, Function)で判定する。このlsymはSymbolではなく関数名で
　あり、未定義の名前だと例外が発生するのでtry-catchで補足する

これらの関数をviewreso.jlに追加し、testviewreso.jlを作った
load_viewprover.jlを作成した。

・vlogic/vlogic.jlはviewとlogicが混じっているので分離したい
とりあえず、geneを使わないバージョンを作ってそれに

genieを組み合わせたい。
 ファイルの再構成
 vlogic.jl => vlogic0.jl (記念にのこす)
 viewlogic.jl を新しいvlogic.jl相当にしたので、vlogic.jl == vlogic0.jlになった


20190609日
・factify_clause()の関数名を昨日かえてしまったのだけれど
  genieで動かすvloigc.jlで呼んでいたのでもどした。
  viewreso.jlにこの関数だけはいっていたので、factify.jlという名前で
　追加し、動くことを確認した。

・Viewで入力した値は、fact literalを作っておくとproofに残るという点が
　メリット



20190608土
みなおし

関数名をrefute_goal()とし、glidでなくgoal全体を対象として[]を目指す関数と
とらえた。

3つのステップ
1. remove_false() or revmove_by_evaluation() or compIt()
 juliaの式としてevaluateし符号も含めてfalseならそのliteral=式を消す。
 trueならclause全体がtrueとなるので、refutation全体が無効になる。
　これを:FAILという名前の例外を飛ばしてよいのか???
 自然な前提として、このようなliteralはground literalである。
 groundかどうかをチェックしてからevalするかどうか。同じようことを二度する
　ことになるので、ground checkは不要。


  1) 実行可能なliteralは定義のある述語のliteralなので、CORE.procにある関数は
　　残りの述語として数えなくていい。その変数はresolutionがだめでも
　　askyouで必ず消せるから。消せなかったらrefute失敗

    残りのliteralがすべてproc述語で、groundなものが残っていれば
　　refute失敗。(か、その条件を満たす変数を不定の解として) と考えられる。

　　proc literalはoppositeにあっても、分岐条件なのでresolutionする必要がない。
　　それは+P(x)と-P(x)のモデルが共有されないということ。つまり同じxが両方の
　　clauseで存在できないので、resolutionする意味がない。

　　resolutionするときliteralを消せるのは、共通のxのモデルがあるから。
　　分岐では、それらのliteralには
　　　1) 共通のモデルがない
　　という条件を前提としていて、executableというのはまさにそういういみ。
　　現実世界で、p(x)かつ!p(x)がないのだから、resolutionには意味がないということ。

　　resolutionでは形式的にでもそのようなxがあるとして、矛盾すると言っている。
　　しかしそのようなxが存在できないのなら、p(x)と!p(x)で分けてrefuteすればよい。
　　・・・というようなことか。よくわからない。

2. remove_with_base() or remove_by_resolution() or inferIt()
 これは、goalのliteralをcoreのbaseで消す。
　グラフでは、goalのpsymのopponentにぶら下がるノードがあれば実行できる。

 いくつか問題
 1) ぶらさがるノードの中で1つだけが適用可能なら、安心してresolutionしてみればよいが
　そうでない場合もありうる
 2) resolutionでglitを消すと、goalのliteralが増える場合もある。
 
 3) 複数のnodeがあると、それぞれについて新しいgoalがありうる。
　・あるgoalのrefuteに失敗した場合、バックトラックして別のgoalを試す(Depth first)か
　・ひととおりの新goalを作っておいて、順番にトライしていくか(breadth first)

　・複数のgoalがあったとき、refuteできそうなgoalを優先して行う。という方法もあるかも。
  　そのとき、「refuteできそうな」の評価方法は?

  ・(literalが増えたとき、)ground literalでevaluateできるものがあれば、減らせる。
　・グラフにoppositeがないliteralがあればaskyouで値を求める。
　・

 4) どのliteralから消していくか


 5) 消す方法は、viewにすべきかresolutionにすべきか
    判断基準はoppositeのリテラルの状態とclauseの状態が材料になりそう。
    一番簡単な場合
　　　oppositがground unit clauseでunifiable
　　　oppositがunit clauseでunifiable

　　そういうものが複数あったらどうなるか。
　　　a) groundの場合、unifiableなら同一のliteralということなので
　　　　そのliteralはviewにしても意味がない(つまりconfirmしか得られない)
　　　　だから、そのliteralについてはresolutionしか必要ない。

　　　b) 変数があるときは、標準形の変数が減るようなlitralがあったら
　　　　resolutionは有望かもしれない。
　　　　resolventができたときのlitral数は少ないにこしたことはないが
　　　　evalで消えるものなら数えなくていい。


　評価基準案
  ・案1) 式に含まれる変数の数をみて、0に近いものはgroundに近いとする。
　・案2) Canonicalを情報1とし、ground clauseはすべて0とするのもある。
    これを<:>で評価できるか??
    空代入φは<P^c:P^c>=<P_g:P_g>=φ
　　P_gはgroundliteralであり、同じliteralの場合
　　ground literalは異なるものがいろいろあり、
    <P_{g_1}:P_{g_1}>は常にφであり(これはなんでもこう)
    <P_{g_1}:P_{g_2}>は失敗する。
    canonをP^cと書くとすると、<P^c:P^c> = φであり、

　　何かリテラルPが与えられたとき、

　　<P^c:P> = φは必ず存在する。

　 このφの形によって、[]に近いかどうかを判定できないか??


3. remove_with_askyou()
 これは、goalのliteralをcoreでは消せないとき、Viewでexternalに問い合わせる。
 externalが人間の場合のこと(AIプログラムが世界に対する判断をこのような形
で受け取ることが一つのテーマだが、それは難しいのでこの方法で試している)

 グラフでは、goalのpsymのopponentにぶら下がるノードがあれば実行できる。
 opponentにぶら下がるノードがあっても実行して悪いわけではないとも思う。
★　たとえば、resolutionで進展しないときに、人間に問い合わせるとか

 この考え方はよいのだがコードについて。
 literalからPageのhtmlを作り、そのurlをBrowserで開いて
人間が入力し、confirmすると別のurlでその値を受け取る。

htmlを作るところと、値を受け取るところは、同じ計算環境(session)
だが、計算のブロックとしては別になってしまう。

このような位相のπ/2のずれのようなことをわかりやすい形で記述できないか。
htmlの前と後で分けた時、一連の処理なのにもかかわらず計算が
分割されてしまう。

schemeかlispで何かフレームワークがあったような気がする。
具体的には知らないので、すこし考えてみよう。

★そのほかの問題
 1) resolutionとaskyouの順番
   removebyevaluation()はgroundに対してしか行われないので、この2つとは独立
　 resolutionとaskyouの場合、どちらも変数をinstance化していく。

   resolutionでいくつかの変数に定数が入った後にaskyouをすると、
　わかっている項目に初期値が入るようなことに対応して、おもしろい

　しかし、人間に聞いてわかることであれば、askyouで変数の値を決めて
　おけば無駄にresolutionしなくてもよい。つまり、resolutionを効率よく適用
　できたり、resolutionを回避できたりする。

　





20190606木
applytemp()の末尾
map(rid->lidsof(rid, core),rids)
の部分は正しいのか?
ridのlidsof()をとるのはいいが、グラフのPにぶらさがっているliteral
すべてにこれをしてどういう意味が??

viewreso.jlに追加
evalation(glid, core) を作ってみたが、この関数は何をすべきか。
glidがevalしてfalseになったとき、goalからglidを消したい。
その点はできていない。

go_resolution()は、graphでglidの相手がいたら、resolutionで
消去する。



20190605水
・unify(vars, array, array)を追加した。testも
・testnewcoreが昨日の分未修正だったので修正した

20190604火
・COREにcanonicalを追加
・printcore()の修正など

20190602日
・goalの引数に定数があるときの処理を考えた。
標準リテラルが必要になり、ややこしくなる。

今のままで、GUIダケでなんとかならないか考えたが、やはり無理そう。

・goalが[]になったとき、confirmすると/startlogicに戻るようにした。
　readcoreをしたとき、フラグをもう一度trueにする修正必要


20190601土
今週は、vlogic.jlとviewreso.jlをnavinavi/genieで作っていた。

coreやclausesをhtmlで表示するためにcorestring.jlを作ったのは今週ではなかっただろうか。

いちおう動くようになったので、vlogicをcheaplogicにコピーした。

動かしかた
@Prover
$ julia
> include("load_vlogic.jl")
vdata/vl002.cnf だと、2回glitを使えば[]になる

TODO:
1) goal literalの消去の方法は3つある
　(1) baseとのresolution
  (2) executeしてfalseになるとき消去
  (3) Viewで消滅させる
　* 消していく順番を決定する方法

1) もとのliteralの引数が定数の場合、その定数がviewに反映されない。
2) cancelまたは ViewのFactが -Pであるような場合
3) lvarsofがvarsofと同じになっている。
　 変数をliteralにあわせるには、標準literalが必要


20190512日
{GoalKeeper- Genie- SQLite}
ここ数日、webのViewとproverをつなぐ仕組みを考えていた。
clauseの集合Baseと、アプリの目的を示すclause Goal(B+G)を与えて
Viewで何かを決定すると、対応するFactが作られて
それをつかってF+B+GでGoalを変化させていくというイメージ。

外部でFactを作るという考えを試すのによいのではないか?

考えたこと
0. B+Gで、どの述語にViewを対応させるかは、あらかじめ定義しておく必要がある。
　　動的にPageを作るというのであれば、ここは自由だが・・(*ここ不十分)

1. Goalに対してBaseを適用して、Goalのリテラルが、Viewを持つものになるまで
　 変形していく。

2. すべてがViewを持つ=Factになりうる必要はないように思うが(*ここ不十分)
　 複数のLiteral in GoalがFactableになるまで変形すると、(*ここ不十分)
   FactableでないLiteralをのぞいて、
   Goalに対してPageの集合が対応し、Web画面が起動する。

*Factableは造語
 (factorialと似ているので、似た言葉がすでにあるのかもしれない
  ちょっと調べたがfactableは辞書にはなかった)

3 Factはground unit clauseかどうか
  -ViewでEntry Sheetみたいなものを考える。
　 そのとき、入力の必要のない項目は、変数のままにしておけばいいはずなので
　 GroundでないFact clauseがあってもいいのではないか。
　 Partial Fact。
　 Unit ClauseはPartial Factということか。

4. Factable LiteralとViewの対応はvarsになる。
　 FL と Vの間は、標準Literalを介してデータが相互に渡る。
   標準Literalは、引数がすべて異なる変数のリテラル。
　 Factable と標準をunifyすると、そのσはViewに表示すべき項目の値になる。
　 Pageはvarsを持つので、そのσをPageに適用すると、計算できる。

　 Pageで入力がconfirmされたときは、Pageのもつvarsに対する代入σも決まるので
　 pageのvarsは標準literalのvarsと同じであり
　 そのσをFactable≈標準に適用すれば、Viewから得たFactリテラルが作れる。

課題
・中間resolvent
  BにはFactableでないリテラルがあると思う。

  Viewから見ると、Logicに関連しており、画面遷移の論理ではあるが
　見た目とは関係ないもの。

・Viewの出現タイミング(Tabか遷移か)
  Goalの変換で、どこまでproofを進めればよいか?

  1) Goalに1つでもFactableがでてくるまで進めて、Factableに対応するViewを
　　 UIで示す。
     1Pageが遷移していくものになり、画面遷移をLogicで書きたくなるかもしれない。
     それは望まない。証明の都合で、画面遷移が変わるとか・・・

  2) GoalがすべてFactableになるまで証明を進めて、Goal単位でPageに変換する。
　　　並列でPageがでるので、Tab切り替えのようなものになるのではないか。

  3) Factの変換とViewの遷移のタイミング・・・

　4) Pageのある変数が別のPageの変数として使われているかもしれない。
　　そのとき、varsに対するσとして適用と反映をpageごとに行えば
　　同期がとれる。
　　この同期のとりかたは、Factとの同期と一致しているはず。

　5) Goalが複数のclauseになるとき
　　1 clause goalに対して、複数のclauseが適用でき、その結果
　  goalが複数になることはありうる。

　　Viewから見ると、tabで別れたPageが複数でてくる。
　　利用者はそれらのPageのどれか一つを入力しきればいい・・・

　6)条件のある場合、異なるPageになるはず。だがリテラルと条件の対応はわからない。

　7)





・executable literal に相当するのが factable.

・


▪️ Juliaで実装するとき、WebアプリのフレームワークとしてGenieというのがあって
Railsみたいにつかえる。WebからJuliaの関数を呼び出せるのはよい。
ということでGenieを調べている。

GenieでSQLiteを使っていたので、SQLiteをインストールした。
HPからとってきたファイルはsqlite3とsqldiff, analyzerのみ。
これですべてらしい・・・Liteだ。

DBは動くようなので、さらに、 Genieで, DB関連のものらしい
SearchLiteというモジュールを使っていたので
] add https://github.com/essenciary/SearchLight.jl
したが、途中でエラーになり中断。
LibPQで失敗しているらしい。

DBはなくてもよいし、 面倒なのでやめ。

きちんとドキュメントを読んでいないからかも。

▪️ Genieは Rendrerが使えれば十分だと思う。

View-Logicのお試し版はGoalkeeperという名前にした。
Goalを[]にする目的でrefuteしていくので。

### GoalKeeperについて

方法
まずは、単純な画面から作っていく。
20190504
Factを動的に追加してくシステムを作ろうかと思う。reactlogicと呼ぶことにする。

1 simpleproverを参考に考えてみたが、factを追加すると、cdb, ldb, templateを
updateする必要があり、 記号もふえるかもしれない。
evalonの処理は気にしなくてもいいような気がする。

2 factを追加する処理、updateと、factが追加されたら、goal x new Axiomsで
  証明を進める処理の2つが必要で、reactlogic.jlに枠だけ作っている。
  進められるところまで証明をすすめて、goal2ができる。
  それが[]なら、終わり。

　1ステップでなく、進められるところまで進めるのは、1つのgoalから
　共通の子供になる複数のresolventがでてくるのをとめるため。

　[g1,g2,g3] x {a1,a2,a3}で
　g1, a1 => 0
  g2, a2 => 0
　だったら、1ステップだと[g2,g3]と[g1,g3]ができてしまい、[g3]ができないとなると
　今できるはずの[g3]が次以降のステップにでてこなくてはならないことになり、ややこしい。

  そこで、[g2,g3]と[g1,g3]は途中ででるけれど、最終的なresolventとしては[g3]のみとする。
　これで問題になりそうなのは、新しいfactが前ステップにでてきたresolventを置き換えるような場合。
　上の例で考えると、次のステップでa4が加えられて、g2, a4 => 0となるとき
　もはやg2はないので、このa4は[]生成に関与しない。

　動的に変更されるaxiomという枠組みの中で、これは避けられない。

3. 現実的には、小さいaxiomsであれば、毎回、全axiomsから[]を導出するのでもよいかもしれない。

  ただし、途中のgoalを調べることで、まだ未解決の条件が何かを知りうるので、



20190503
 play.jlにあったreadstring()が未定義だったので、read(file, String)に変更した。
 1step proverを作ろうかと思ったかが、dostep1goalsがplay.jlで使われていて
 それの使い方を調べていた。
 テンプレートを一回適用する関数らしいので、だいたい目的にあっている。

 commitしようとしたら、未commitのdocsがたくさんあった。

---
実世界での操作から述語を生成(GUIとか機械学習による)し
それに基づいて証明を進めるという考え方の検討

runkb.jl, kb00[0-3].cnf
途中の状況があまり鮮明に描けないが、kb003.cnfで、作られたresolventを確認すると
必要なものはとれている。
原理が単純なのでよいと思う。

1. イベントからclauseが生成され
2. そのclauseを使って、goalから新しいresolventを作る
3. それが[]なら、完了

という仕組みはできるはず。

イベントの部分はreplを使えばよいだろう





20190424
1. in cheaplogic, unify0snとunify0nsでisvarの判定する引数が逆だった
naiveとcheapが同じ結果になる

20190421
1. check TPU of Chang&Lee
   the definition of substitution is different.
2. investigating ml007, what is different naive and cheap.
   naiveでは9個の[]ができるのに、cheaplogicでは1つもできない
   R10まではcheaplogicでもつくれているが、その先がないin cheaplogic.

20190420
Problem: How about the original algorithm?
Do for it.
1) preparation: reso.jl to reso.jl, unify.jl and others
2) test it
3) make naiveunify.jl for the original algorithm
4) test it

1. First, I think test_unify.jl is enough for naiveunify.jl
   But, some functions as fp_unify() should not need in naive,
   I made test_naiveunify.jl. 
   If I want to compare two unify(), I need common tests.
 


20190413
I clearfed the concepts about substitution-apply-unify.

1. Substitution(Σ) can have {x<-f(x)}
   Σ=VxT

2. apply(α) replaces a var with the corresponding term simulteniously.
   Because it, the substituion can be express unambiguously as 
    (v1,v2,v3) <- (t1,2,t3) without {}

   α: T x Σ → T
   α: Σ x Σ → Σ 

3. <x:f(x)> fails. It is caused by inside check.
   This doesn't except x<-f(x) from substitution.

   <> : T x T → Σ

I thought yesterday, this is not correctly implemented now.
But today reso.jl should be correct. 
I clearfy some tests around this.


