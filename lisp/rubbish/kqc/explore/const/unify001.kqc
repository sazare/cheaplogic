; unification anyway

;; x = <e1:e2>
;((e1 e2 x)(+ D e1 e2 x))

; ok
; (1 (u) (- D a a u)(- Const a)(- Const b))

;; twin nconj find the trueth?
;; if this, u may be anything. 
;(1 (u) (+ D b a u)(- Const a)(- Const b))
;; no □
; (1 (u) (- D b a u)(- Const a)(- Const b))


;; cant
; no
;(1 (x u) (+ D a (f (g b) x) u))
; no
;(1 (x u m) (- D m (f (g b) x) u)(- Const m))

;; should □
;; this means fail of unify. ignore u.
;(1 (x u) (+ D (f (g b) x) a u) )

;; this is ok or not
;; u is ε
;; (extract-mgu 'c35 '(c1) '(x.148)) => (:TUPLE Ε)
(1 (u) (- D (f a b) (f a b) u))

;; u is mgu
;; u is (x b)?
;; C1: 1 (X.149 U.150) ((- D (F A X.149) (F A B) U.150)) 
;; (extract-mgu 'c35 '(c1) '(x.149)) => (:TUPLE B)
;(1 (x u) (- D (f a x) (f a b) u))

;; fail case ... fail is represented by -D
;; but this doesn't cause □ something like this
((z)(- D a b z))
((c1 c2 z)(- D c1 c2 z) (- Const c1)(- Const c2))

((z)(- D a b z))
((z)(- D b a z))

((z e1)(- D (g e1) a z))
((z e1)(- D (g e1) b z))
((z e1)(- D a (g e1) z))
((z e1)(- D b (g e1) z))

((z e1 e2)(- D a (f e1 e2) z))
((z e1 e2)(- D b (f e1 e2) z))
((z e1 e2)(- D (f e1 e2) a z))
((z e1 e2)(- D (f e1 e2) b z))

((x y w z)(- D (f x y)(g w) z))
((x y w z)(- D (g w) (f x y) z))

;; successful
; ε is empty substitution
((x)(+ D x x ε))

((ww cc)(+ D ww cc ((σ ww cc))) (- Var ww))
((ww cc)(+ D cc ww ((σ ww cc))) (- Var ww))

((vx vy vz vw d1 d2)(+ D (f vx vy)(f vz vw) (σ vd1 vd2)) (- D vx vz vd1)(- D vy vw vd2))
((vx vz vd)(+ D (g vx)(g vz) vd) (- D vx vz vd))


;; local defintion
(() (+ Var x))
(() (+ Var y))
(() (+ Var w))
(() (+ Var z))
(() (+ Var u))
(() (- Var a))
(() (- Var b))
(() (+ Const a))
(() (+ Const b))

((x) (- Var (g x)))
((x y) (- Var (f x y)))

;((x) (- Var x)(- Const x))
;((x) (+ Var x)(+ Const x))


