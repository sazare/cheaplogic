
2023/02/20月
・p2codeの1pairごとの拡張関係
　(make-nnmap sccp2)でclassify-cid-by-p2codeの結果を使って木を作る

(p2c-n p2c sccp2n) p2codeから番号
(n-p2c n sccp2n)   番号からp2code

==== funcions usage
(require :gtrail)
(in-package :rubbish)
(readkqc "kqc/path/graph201.kqc")
 (pg (c1))


;; ccp2は同じp2codeをもつcidのリストつきのリスト
(defparameter ccp2 (classify-cid-by-p2code))

;sccp2はccp2のfirstの長さでソートしたもの。secondはcidのリスト
(defparameter sccp2 (sort-ccp2 ccp2))

;sp2は長さ順のp2codeのlist
(defparameter sp2 (loop for x in sccp2 collect (first x)))

;sccp2に番号をわりふる。cidのリストがついている
(defparameter sccp2n (numbering-sccp2 sccp2))

;sp2nは、p2codeに番号を割り振る。p2codeのみのリスト。
(defparameter sp2n (numbering-sccp2 sp2))

; amapはsccp2のp2codeのお隣り(arrow)map (p2code (p2c1 p2c2 ...))*
(defparameter amap (make-nnmap sccp2))

; amapのp2codeを番号に置き換えたもの
(defparameter mapn (map-in-number amap sccp2n))

========


2023/02/19日
・p2codeの次のspccp2 の要素をもとめる
  (find-next-p2codes p2c allp2c)

・s2codeに番号を割り振る
　(numbering-sccp2 sccp2)
  (find-p2code p2c scpp2n)



2023/02/18土
・p2codeの包含関係と長さ+1で、となりのclauseをp2codeベースで定義してみた。
・head部分が同じならp2codeを含むという見方で(p2-adjmap p2cs)を考えた
  (cnext p2 allp2code) でp2の隣のp2codeを取り出す。
　p2codeがそういうふうにソートされているわけではないので、このアプローチはNG
・(p2c-containp p2 allp2)はp2の全pairを含むp2code in allp2を選ぶようにする。
　これにp2の長さ+1の条件を加えて、となりのp2codeを決めた
　　(wnext p2 allp2code)と(p2-wadjmap allp2cs)を定義した。
　　これでよさそうだが、数が増えるので、使い方を考えなくては。

・(p2toc p2code) => このp2codeをもつcid
を作った。なかったっけ??(p2top p2code) => pcode。これを思い出しているだけ

・ソートしたり手がはいっているので、それを除去することを考える


2023/02/14火
1) propが描けるか確認した(昔、書けるように作った気がする)

 kqc/prop/prop001.kqc
(1 () (+ P))
(2 () (+ P)(- Q))
(3 () (- P)(+ Q)(- R))
(4 () (- Q))
(5 () (+ R))

のようにかけた。引数のない述語に見えるが+/-が分離しているのでこれが命題だ。


2) 複数の証明環境を持てるようにする方法を考えた
　docs/20230214-metaverse.txt

3) orphanがあったときどうなるかを確認した
　orphanをのぞいて[]になればOKな気がする
　docs/20230214-orphan.txt

4) prover-gtrailが終わったあと、継続することについて考えた
　docs/20230214-resume.txt
  (prover-gtrail *goallist*)
　でできる。
　*goallist*を好きなように作れば、好きなように続けられる。続けるというのは違うかもしれないが

5) macroを作った。pg=prover-gtrail, pm=pmetrics. 
'(c1)みたいに'をつけるのが面倒なだけ

例
RUBBISH(4): (pg (c1))

start-time: 2023-02-14T10:19:29.116715+09:00

  ### PARAMETERS ###
  goals                = (C1)
  *max-clauses*        = 1000
  *max-contradictions* = 30
  *max-trials*         = 100
  *max-steps*          = 100
  *timeout-sec*        = 10
  *enable-semantics*   = NIL

limit-over number of contradictions exceeds

end-time: 2023-02-14T10:19:29.140190+09:00

  ### SUMMARY ###
  time consumed = 0.035740 secs
  #clauses = 481
  #contras = 31
  #valids = 0
  #trials = 2007
  #max proof steps = 20
NIL
RUBBISH(5): (lscova)

((C35 C46 C53 C69 C94 C111 C121 C128 C148 C155 C168 C196 C203 C226 C245 C255
  C262 C288 C299 C306 C322 C329 C345 C373 C384 C391 C404 C427 C434 C462 C481)
 NIL)
RUBBISH(6): (pm c35)
[C35]
  depth                 = 7
  num of clauses        = 12  see (cids-of-proof cid)
  num of input clauses  = 6  see (inclauses-of-proof cid)
  num of input literals = 9  see (inliterals-of-proof cid)
  num of preds          = 2  see (preds-of-proof cid)
NIL

2023/02/13月
proof metrixを作った
 proofのメトリックス(になりそうなもの)を計算する関数と表示する関数(pmetrics)

 literals-of-cidは意味がなさそうなのでやめた。inliterals-of-cidで十分では??


2023/01/21土
summaryのmax steps of proof数が0だ
証明のdepthを数えていない。
各resolventを作った時にそのdepthを計算し、propertyにいれておくのでどうか。
resolventのdepthは親のdepthのmaxにする

それでよいか?
とりあえずなくても困らないのでこのまますこし考える?

summaryの中で(lscova)から[]のcidをもとめて、そのdepth-cidのmaxを表示した
一回だけなので性能は問題ない



2023/01/20金
p2codeとpcodeの関係を考えた
p2codeのほうが正確。pcodeは高速なのか? ややあいまいなきがする。

2023/01/18水
・p2codeを作成した
　これは、resolveされたLIDペアのリストを(list-mgu cid)からとってきたもの。
  pcodeの曖昧さは、p2codeならないだろうという考えで、どれくらい違うかみてみたい。

  よく必要になるuniqをrubbish-essential.lispに追加。


・p2top は p2codeからpcodeを作る関数。追加
例)

(p2top '((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L9-1)
   (L3-2 L5-1)))

(L9-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L10-1 L1-1)

see 20230118-aboutp2code.txt


2023/01/17火
スクリプトからrubbish を使う別の方法。recip参照

1. script2.shを次のように作る
---
#!/bin/zsh

./test-path --script testdir/test-run.lisp 10 "kqc/path/graph201.kqc" '(quote (c1)))'
---

2. test-run.lispを次のように作る
---
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail '(c1))

(print-analyze (analyze-pcode))
---
これは、rubbish-statistics.lisp/test-graphとほぼ同じだが、(require :gtrail)も
ここに書いているので、core ファイル(test-path) のようなものはいらない。
ただし、実行時間はよけいかかるだろうけど。
それはcoreを起動するようにすればいいだけなので、 ここの問題ではない。

3. 実行
 ./testdir/script2.sh

*** string -> s-expはどうするか?
"(C1)" -> '(c1) にする方法?

 (read (make-string-input-stream "(c1 c2)"))
 => (c1 c2)

複数のs-expの場合は、

 (let ((s (make-string-input-stream "(c1 c2)"))) 
    (list (read s)(read s))
 )
みたいな

test-run.lispを次のようにすればgoalも指定できた


--- test-run.sh
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail (read (make-string-input-stream (nth 3 SB-EXT:*POSIX-ARGV*))))
(print-analyze (analyze-pcode))
---

--- script2.sh
./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph201.kqc" (quote (c1)))' --eva
#!/bin/zsh

./test-path --script testdir/test-run.lisp 20 "kqc/path/graph201.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph202.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph203.kqc" '(c1)'
---




2023/01/16月
・sbclのaliaasをlispに変えた
sbclを生で呼びたいこともあるだろう

rlwrap sbcl
を使うことをおすすめする > 自分

メモリふやさなくてもgraph201.kqcくらいは動く
・
-----
shin@Chapterhouse rubbish % sbcl --script test-pathfinder001.lisp
Unhandled SB-INT:EXTENSION-FAILURE in thread #<SB-THREAD:THREAD "main thread" RUNNING
                                                {70051701A3}>:
  Don't know how to REQUIRE GTRAIL.
See also:
  The SBCL Manual, Variable *MODULE-PROVIDER-FUNCTIONS*
  The SBCL Manual, Function REQUIRE
...

lispファイルはだめか。
coreファイルを作って(require :gtrail)まではやっておくか
test-graphの定義はrubbish-statistics.lispに追加した
　最初は、sbclの起動時の--evalで定義するのを考えたが、タイプが多すぎる。
test-graphをrubbish-package.lispでパッケージのexternにいれた。


★ステップ1　コアつくる :gtrailロードしたもの
shin@Chapterhouse rubbish % rlwrap sbcl
This is SBCL 2.1.9, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
CL-USER(1): (require :gtrail)
To load "local-time":
  Load 1 ASDF system:
    local-time
; Loading "local-time"

NIL

CL-USER(2):  (sb-ext:save-lisp-and-die "test-path" :executable t)
[undoing binding stack and other enclosing state... done]
[performing final GC... done]
[saving current Lisp image into test-path:
writing 1728 bytes from the read-only space at 0x300000000
writing 1840 bytes from the static space at 0x300200000
writing 0 bytes from the immobile space at 0x300300000
writing 42532864 bytes from the dynamic space at 0x7003000000
done]

** sb-extの指定は不要


★ステップ2 実行
  rlwrap ./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph001.kqc" (quote (c1)))' --eval '(sb-ext:exit)'

この実行のあと、REPLに残りたいときは、--eval '(sb-ext:exit)'を指定しない。
たとえば 
(print-analyze(analyze-pcode0))
をしたいとき
----
(in-package :rubbish)
(defun test-graph (mc kqcfile goal)
  (defparameter *enable-semantics* nil)
  (defparameter *max-contradictions* mc)
  (readkqc kqcfile)
  (prover-gtrail goal)
  (print-analyze (analyze-pcode))
)
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
------
test-gtaphの定義をどこかにうつして、スクリプトは
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
だけ書くようにする

テストのしかた

./testdir/script.shを作り
実行
./testdir/script.sh >xxx.txt
xxx.txtに結果出力される
(scriptコマンドを使うとへんなコード(^Mとか^[)がでたり、出力されなかったりした)


2023/01/15日
グラフの例を追加。
00?は直線
10?は複数パスの例
20?はループのある例
　201はa->b->a
　202はもうすこし長い
　203は複数パスのあるループ

(analyze-pcode)
(print-analyze)
などを作った

すこし様子をみた


2023/01/11水
グラフのパスをみつける例を作った greph101.kqc, graph102.kqc

そして
(lnumof Lid) ln-mからn
(cnumof cid) cn から n
を作ったが、なんのために作ったのか忘れた・・・

思い出したpcodeでLidのリストをソートするとき、今は文字列でやっているので
(pcode ...) の結果が
(L2-2 L2-1 L10-1 L1-1)
みたいになる。これを数字の順にしたかった

今はname<という関数を作っていて、これは文字列比較している。

関連して、string<とかstring>とか使っているsortを全部(name< (lnumof llid) (lnumof rlid))を
使うようにかえた。

残り
　もしかしたら L2-1とL2-2のsortでL2-2 L2-1にしたいかもしれない。

