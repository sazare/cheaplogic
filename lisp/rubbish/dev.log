

2023/02/13月
proof metrixを作った
 proofのメトリックス(になりそうなもの)を計算する関数と表示する関数(pmetrics)

 literals-of-cidは意味がなさそうなのでやめた。inliterals-of-cidで十分では??


2023/01/21土
summaryのmax steps of proof数が0だ
証明のdepthを数えていない。
各resolventを作った時にそのdepthを計算し、propertyにいれておくのでどうか。
resolventのdepthは親のdepthのmaxにする

それでよいか?
とりあえずなくても困らないのでこのまますこし考える?

summaryの中で(lscova)から[]のcidをもとめて、そのdepth-cidのmaxを表示した
一回だけなので性能は問題ない



2023/01/20金
p2codeとpcodeの関係を考えた
p2codeのほうが正確。pcodeは高速なのか? ややあいまいなきがする。

2023/01/18水
・p2codeを作成した
　これは、resolveされたLIDペアのリストを(list-mgu cid)からとってきたもの。
  pcodeの曖昧さは、p2codeならないだろうという考えで、どれくらい違うかみてみたい。

  よく必要になるuniqをrubbish-essential.lispに追加。


・p2top は p2codeからpcodeを作る関数。追加
例)

(p2top '((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L9-1)
   (L3-2 L5-1)))

(L9-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L10-1 L1-1)

see 20230118-aboutp2code.txt


2023/01/17火
スクリプトからrubbish を使う別の方法。recip参照

1. script2.shを次のように作る
---
#!/bin/zsh

./test-path --script testdir/test-run.lisp 10 "kqc/path/graph201.kqc" '(quote (c1)))'
---

2. test-run.lispを次のように作る
---
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail '(c1))

(print-analyze (analyze-pcode))
---
これは、rubbish-statistics.lisp/test-graphとほぼ同じだが、(require :gtrail)も
ここに書いているので、core ファイル(test-path) のようなものはいらない。
ただし、実行時間はよけいかかるだろうけど。
それはcoreを起動するようにすればいいだけなので、 ここの問題ではない。

3. 実行
 ./testdir/script2.sh

*** string -> s-expはどうするか?
"(C1)" -> '(c1) にする方法?

 (read (make-string-input-stream "(c1 c2)"))
 => (c1 c2)

複数のs-expの場合は、

 (let ((s (make-string-input-stream "(c1 c2)"))) 
    (list (read s)(read s))
 )
みたいな

test-run.lispを次のようにすればgoalも指定できた


--- test-run.sh
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail (read (make-string-input-stream (nth 3 SB-EXT:*POSIX-ARGV*))))
(print-analyze (analyze-pcode))
---

--- script2.sh
./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph201.kqc" (quote (c1)))' --eva
#!/bin/zsh

./test-path --script testdir/test-run.lisp 20 "kqc/path/graph201.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph202.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph203.kqc" '(c1)'
---




2023/01/16月
・sbclのaliaasをlispに変えた
sbclを生で呼びたいこともあるだろう

rlwrap sbcl
を使うことをおすすめする > 自分

メモリふやさなくてもgraph201.kqcくらいは動く
・
-----
shin@Chapterhouse rubbish % sbcl --script test-pathfinder001.lisp
Unhandled SB-INT:EXTENSION-FAILURE in thread #<SB-THREAD:THREAD "main thread" RUNNING
                                                {70051701A3}>:
  Don't know how to REQUIRE GTRAIL.
See also:
  The SBCL Manual, Variable *MODULE-PROVIDER-FUNCTIONS*
  The SBCL Manual, Function REQUIRE
...

lispファイルはだめか。
coreファイルを作って(require :gtrail)まではやっておくか
test-graphの定義はrubbish-statistics.lispに追加した
　最初は、sbclの起動時の--evalで定義するのを考えたが、タイプが多すぎる。
test-graphをrubbish-package.lispでパッケージのexternにいれた。


★ステップ1　コアつくる :gtrailロードしたもの
shin@Chapterhouse rubbish % rlwrap sbcl
This is SBCL 2.1.9, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
CL-USER(1): (require :gtrail)
To load "local-time":
  Load 1 ASDF system:
    local-time
; Loading "local-time"

NIL

CL-USER(2):  (sb-ext:save-lisp-and-die "test-path" :executable t)
[undoing binding stack and other enclosing state... done]
[performing final GC... done]
[saving current Lisp image into test-path:
writing 1728 bytes from the read-only space at 0x300000000
writing 1840 bytes from the static space at 0x300200000
writing 0 bytes from the immobile space at 0x300300000
writing 42532864 bytes from the dynamic space at 0x7003000000
done]

** sb-extの指定は不要


★ステップ2 実行
  rlwrap ./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph001.kqc" (quote (c1)))' --eval '(sb-ext:exit)'

この実行のあと、REPLに残りたいときは、--eval '(sb-ext:exit)'を指定しない。
たとえば 
(print-analyze(analyze-pcode0))
をしたいとき
----
(in-package :rubbish)
(defun test-graph (mc kqcfile goal)
  (defparameter *enable-semantics* nil)
  (defparameter *max-contradictions* mc)
  (readkqc kqcfile)
  (prover-gtrail goal)
  (print-analyze (analyze-pcode))
)
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
------
test-gtaphの定義をどこかにうつして、スクリプトは
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
だけ書くようにする

テストのしかた

./testdir/script.shを作り
実行
./testdir/script.sh >xxx.txt
xxx.txtに結果出力される
(scriptコマンドを使うとへんなコード(^Mとか^[)がでたり、出力されなかったりした)


2023/01/15日
グラフの例を追加。
00?は直線
10?は複数パスの例
20?はループのある例
　201はa->b->a
　202はもうすこし長い
　203は複数パスのあるループ

(analyze-pcode)
(print-analyze)
などを作った

すこし様子をみた


2023/01/11水
グラフのパスをみつける例を作った greph101.kqc, graph102.kqc

そして
(lnumof Lid) ln-mからn
(cnumof cid) cn から n
を作ったが、なんのために作ったのか忘れた・・・

思い出したpcodeでLidのリストをソートするとき、今は文字列でやっているので
(pcode ...) の結果が
(L2-2 L2-1 L10-1 L1-1)
みたいになる。これを数字の順にしたかった

今はname<という関数を作っていて、これは文字列比較している。

関連して、string<とかstring>とか使っているsortを全部(name< (lnumof llid) (lnumof rlid))を
使うようにかえた。

残り
　もしかしたら L2-1とL2-2のsortでL2-2 L2-1にしたいかもしれない。

