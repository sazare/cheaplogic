2023/05/25木
・rubbish-goods.lispを追加
　長い函数名をmacroで短くする
(rp path) = (readkqc path) (print-clauses)
(pc cid)   = (print-clause cid)
(pcs)       = (print-clauses)
(ppg gs path) = (play-prover-gtrail 'gs path)

rubbish-goods.lispはgtrail.asdに追加した

[使い方]
(require :gtrail)
(in-package :rubbish)
(rp "kqc/...")
(pg c1)
や
(pg c1 c2)

;(prover-gtrail '(c1))
(pg c1)

;表示
(pc) = (print-clauses *clist*)
(pc c1 c2) = (print-clauses '(c1 c2))


または

(play-prover-gtrail '(c1) "kqc/ml002.kqc")
(ppg (c1) "kqc/ml002.kqc")
;;
;; 昨日までは(play-prover-gtrail '(1 2) "...")だったが、ここだけ数字だとよくわからなくなるのでC1 C2とするようにした



; set some rubbish parameters different
(load "pre-rubbish.conf")



2023/05/24水
・kqcやplay-*.lispの整理の前に、ひととおり動かしてみる。


2023/05/18木
・kqcを整理しておかないといけない。全部やりなおすため

記録する項目は?
kqc path/目的/特徴/補足/使い方

分類コードは?

実行するパラメタは?

*max-clauses*
*enable-reduce-syntax* 
*enable-semantix*

rubbish-setup-unif.lispで代入はparに設定している。だったらeval不要では??


2023/05/17水
・goalが複数リテラルの場合、矛盾があっても矛盾が出ない
kqc/merge/mg004.kqc
 (prover-gtrail '(c1))
C14: RESOLVENT NIL [((- P A) (- S A))]
C13: RESOLVENT NIL [((- P A) (+ S A))]
C12: RESOLVENT NIL [((- P A) (- S A))]
C11: RESOLVENT NIL [((- P A) (+ S A))]
C10: RESOLVENT NIL [((+ P A) (- P A))]
C9: RESOLVENT NIL [((+ P A) (- P A))]
C8: RESOLVENT NIL [((- S A) (+ P A))]
C7: RESOLVENT NIL [((+ S A) (+ P A))]
C6: RESOLVENT NIL [((+ R A) (- S A))]
C5: RESOLVENT NIL [((+ R A) (+ S A))]
C4: C4 NIL [((- P A) (- S A))]
C3: C3 NIL [((- P A) (+ S A))]
C2: C2 NIL [((+ P A) (- R A))]
C1: C1 NIL [((+ P A) (+ R A))]
こんな感じで永遠に続く

★現在のprover-gtrailでは、lsym∋lidがinputだけなので、全部2-literalsのこのような例では矛盾はでない。

entry-reduceでpushlsymをするようにした。
ただし、make-lidでlidを作ってから、それにsetlidをして、pushlsymをするなど処理が煩雑
entry-clauseでも同じではないか


2023/05/15月
step-solverでLLがLになるのは確認した。

prover-gtrailが、unitのないclause setで□をだせない点。
goal/factのある世界を考えていたのでこのようなΣでは□はだせない。

check-mujunのようにc ∈Σについて、Σ, c⊢□もでない

述語記号について +Pとか-Pを作ってΣ, +P⊢□もできない

これは、resolventをopposの+P, -Pに追加していないからかな。
+P, -Pにはinput literal idのみが登録されている。

・resolventはentry-lid
・inputclauseはmake-lid

resolve-id -> entry-clause -> setlid これは、lidのplistの設定

(input) make-lsymlist -> pushlsym ここで、lsym(+/-P)にlidを追加している。
　だから、resolventのlidをpushlsymすれば追加できる。


・矛盾解析に必要な機能は何か?

(entry-clause)と(entry-reduce)にpushlsymを追加したが、新しいlidを設定しなくてはいけないのに
もとのコードはもとのlidに設定していた。
entry-clauseについては、resolventを登録するという処理はなかったので、今まで問題にならなかったのか?

このコードは、


2023/05/14日
step-solverにstep-reduce-syntaxを組み込んだ
  step-reduce-syntax/reduce-id
　だからprover-gtrailもpure-prover-gtrail自体は修正していない。両方ともstep-solverを呼ぶ

* 名前:reduce-syntaxはreduce-propがよいのではないか?

[おかしい点]




2023/05/13土
・reduce-idは　pure-prover-gtrailにだけ組み込めばいいのではないか。mujunチェック用ということで。
　prover-gtrailでは、こういうことが起きないような気がするので様子見。

・単体で動作
　　reduce-id　　2つのlidでreduceする
       match-lids　cidからlidをみつける
       step-reduce  cidからlidみつけてreduceする

　print-proof0, print-proof修正した。0と無印の違いがよくわからない

　p2code, pcodeは動かない
　　だから check-mujunは動かない

2023/05/12金
・+P+Pα => +Pα
　の処理を追加したい。
　ルール名は  reduced-by-syntax
　+Pはequalのときだけ適用する。(equal lid1 lid2)でよい。
　もしも、<L1:L2>=σ≠∅の場合、L1α・σとすると、L1>L2なら、-σの範囲にあるtermが除外されてしまうので適切でない。
　逆にL2・-σも意味がおかしいので、まったく同一の場合だけ1つにするというルールにする。だから、命題算のルール。
　equal-litとかequal-lidという関数を使っていないので、名前はこれ
　reduce-by-semantixを参考に作る

　L1L2L3αの場合もL1αとしたい。proof-stepの構造としては、2▷1の形とし、3Literalの場合は、2回適用する。
　ルールが適用できなくなるまで繰り返すということか。

　rubbish-resoid.lispに含める。

  reduce-idは動いた。1ステップなので、これをどう組み込むか。

2023/05/11木
・Σ, c ⊢ ?
を考えた時、Σ∋cでない場合を考えたほうがいいのかなと思う。
Σ, cで証明する中で、cとcのresolutionは起きないのか?
+Pの形なら、resolveされないので問題ない。
しかし、cが-P+Pのような形なら起きるだろう。

述語命題なら、+P(x)-P(f(x))
Σ={+P(a), -P(f(a))}なら、□になる。
なるがどうした?

これは矛盾を含んでいるのか??
conj +P(f(x))で¬conj -P(a)を使ってrefutationするときは、{+P(f(a))



2023/05/10水
mutatから不完全な□を削除するようにした

問題は
-P(x,a)
が
+P(3,a)
のconflictの原因ということで消されてしまうこと


2023/05/09火
・□の件
mutateで発生する□は、処理後
RUBBISH(16): (p2code 'c19)

((L17-1 NIL))
こんな感じになっている。消したcidのlidがなくなっているため。
だからこの□は消したほうがよい

*変数がはいってくるとややこしくなる
-P(x,a)で初期状態を表した場合
+P(3,a)で-P(x,a)からx=3の場合を除外したいが-P(x,a)ifx≠3は、その次の移動で-P(3,a)がきた時
if x≠3を消すとかなんとかしたなくなる。それは大変
では
-P(x,a)∨+P(3,a)みたいにすればいいのか?

{-P(x,a)∨+P(3,a), +P(3,a)}と??
そして
-P(x,a)∨+P(3,a) x -P(3,a)で
-P(x,a)
に戻れば良い。もどるかな。

これは、Σ x cで、Σの中から〜cをすべて消し去るようなこと。cがunitだから意味ありそうに見えるがそうでなかったら?

proverの場合、-P(x,a)をそのまま残しておいて十分か?
というのは
+P(3,a)は-P(3,a)とのconflictで消せる
-P(x,a)は-P(3,a)と交わらないので透明
だから

なんかそれでいい気もする

では
-P(x,a)
は、空間全体にaが存在しないというよりは、デフォルトがaの不在みたいな感じがする。




2023/05/08月
運動の例で、はじめて矛盾解消ができた
20230312-conflict-disolver-lisp.txt

一番単純な例だと思う。
どこまで一般化できるだろうか

運動の例を最後まで実行するスクリプトを作って記録をのこそう。今は時間がない。

**
削除するclauseの判定をclauseのborn-whenの古いものを選ぶように変えた。

そして、全体を実行する。

bug1 : f2を実行すると、+Pがorphanになる。
RUBBISH(38): (mutate f2)
orphan lsym L13-1 in C13.
NIL

create-cid でf2を作ったとき+PにL13-1がはいっていない??
入力データでliteralのリストにしていた。
(() (+ P x))
とすべきところを
(() ((+ P x))
にしていた
プログラムの問題ではなかった。
★それがわからないのがまずい

こんな感じでどうさする。
(require :gtrail)
(require :mutat)
(in-package :rubbish)

; no a in [1:10]
(factisf (loop for i from 1 to 10 collect (list () (list '- 'P i 'a))))

(setq f1 (factIs ( () (+ P 1 a))))
(mutate f1)

(setq f2 (factis (() (+ P 3 a))(() (- P 1 a))))
(mutate f2)

(setq f3 (factIs (() (+ P 8 a)) (() (- P 3 a))))
(mutate f3)
---
ここで、check-mujunで作った□がずっと残っているのはよくなさそう。
あとで消すか
*clist*に追加しないようにできるか??

[]をremove-cidすればよいのだが、不思議なことに□があっても問題ない。
というのも、goal g は絶対に□とresolveされることがないから。★
これは逆説的で面白い。

とにかく□は残しておこうかなと思う。



2023/05/07日
rubbish-prover-gtrail.lispで
pure-prover-gtrailはprover-gtrailの一部であり、check-mujun用に抜き出したもの。
停止用チェックのメッセージなどをはずしている。

これ、ひとつにならないだろうかと思う。

check-mujunをrubbish-mujun.lispに分離
pure-prover-gtrailは、prover-gtrailと似ていることがわかるように、
　　いつか、ひとつにできるかもしれないので、もとのままにした。
　実際はcheck-mujunのためだけにあるので、こっちにいれたほうがよいかも。

1) mujun-setは、Σのclause cに対する矛盾集合(複数)をみつける関数。
　


・追加
(isinputcid cid)
(isunitclauses cid) => (isunitcid cid)


***　これで、矛盾集合からキーとするcidを選ぶ用意はできた。
　どう判定するかは難しい


2023/05/06土
運動の例で、動的fact列の処理を考えようとしている

mutat システムを作った
(require :gtrail)
(require :mutat)
(in-package :rubbish)
で使える。
20230312-conflict-disolver-lisp.txt
で例をやってみている

>>
aの存在しない状態を記述してから
factでaの位置を与える
矛盾したらも古いfactを消去する
<<
という手順

2023/04/25火
　新しいfactにより矛盾するΣと矛盾解消の例を考えたい


2023/04/08土
・4/2にΣの無矛盾性を判定する方法を考えた。これに続くこととして
　1) Σの部分矛盾集合のぎりぎりおおきいものの検出
　　そういう集合が存在するのかどうか?
　　複数ある場合について
　2)　Σから無矛盾部分集合を取り出すことはできるのか
　　これは操作の目的がうまく定義できないような気がする。

・証明器の正当性の定義と証明

2023/04/02日
・Σの無矛盾性チェックの実装
　rubbish-prover-gtrail.lisp
    (is-consistent *clist*)
    (pure-prover-gtrtail goals)

  ∀a ∈ Σについて　Σ, a ⊢□ を確認する。この証明があれば、Σ⊢〜aが証明されるということなので矛盾する。
　Σ, 〜a ⊢□ は常になりたつので確認不要。

2023/03/05日
・Σの拡張についてすこし検討した

2023/03/04土
・samplerunからadja、radja の行をコメンアアウト。使っていないので


2023/02/27月
・doc追加。tautologyとvalidの違いを書こうと思ったら、矛盾するΣとか
gを真にしてしまうΣとか


2023/02/26日
・digraphでpngを作る手順を作った
 digraphを作る部分 rubbish-digraph.lispにした
　最初に(require :gtrail)をするとコンパイラーでoffsetがどーのこーのいうエラーになった
　(load "rubbish-digraph.lisp")を一回やったらエラーがでなくなった。


2023/02/25土
・quicklispのgraphと名前にあるライブラリをさがしてみた
(ql:system-apropos 'graph)
いろいろあった
cl-graphは使い方がわからないし、maintainerがもうやっていないらしい
cl-digraphがどきゅめんとも書かれていて使えそう。
cl-digraphのグラフ表示は(ql:quickload 'cl-digraph.dot)
　pngが作れた。
(digraph.dot:draw *d* :filename "digraph.png" :format :png)
Graphvizのcl-dotを使ってcl-digraph.dotでグラフがかける



2023/02/24金
・自動ではいる改行を抑制したい
(setq  *print-right-margin* 200)
　~/.sbclrcに追加した

・show-parameter0, show-parameterで*kqc-file*を表示するようにした。
　他のパラメタと同じ扱いのほうがよいと思う。

・tkplotで、
　- layoutをeingold-Tilfordにするとツリー表示になる。逆さまなので
　　rotateをする。
　- epsを出力する
　　GIMPで変換する
　　1) 「名前をつけてエクスポート」
　　2) 出力形式はメニューから選べるので
　　　 pdfやpngにする。jpegはサイズがでかくなる

・p2codeに番号をつけたが、
　木の末端になるのは
　　1) contradiction(body がnil)
　　2) contradictionではないものは、proveの途中のものが残るような気がするが
　　　　[]と同じp2codeになるのはなぜだろうか?
　　　　literalが残っているが、input 射影で[]と同じになるもの。
　　　その意味は?

・作ったpdf, pngなどをgithubに追加したが、動かすたびに新規で置き換わるので、
  git statusでは、毎回untrackedになってしまう。よくないか
　次のcommitでgithubリポジトリから消えてしまうのでは?

2023/02/23木
・p2codeの木をRで描く
　sbclで隣接行列のlistをつくり
　そのままだと向きが逆なので転置
　adjmの転置なのがmjdaという名前にして
　mjda.r に出力する
・Rでは
  source(mjda-to-graph.R)
　とするとtkplot()でグラフ表示をし、手で操作できる。
　(コメントしているが、xquart()で plot(gr)してもよい)
　このとき、labelの値を隣接行列のnからn-1にしている
  0はinputで、そのあとのindexがnodeのindexより1大きいから

・Rのtkplotなどはpdfにexportできるので、その画像をdocsにいれてある


2023/02/22水
・Rでグラフを描く。
 sbclで隣接行列を出力する
　1. rubbish-analyze.lisp
　　　にグラフ関係をまとめた。他にもいれたい
　2. (defparameter adjm (conv-to-adjacent mapn))でbitmap行列に変換した
　3. (writeadj "adj.r" adjm) でファイルに出力。Rの形式

　R側ではこのadj.rを読み込むとadという変数に値が設定されるので
　matrix(ad, col=length(ad), row=length(ad))
　でmatrixが作れる


2023/02/21火
・隣接情報を取り出した。edgeの定義だけ取り出した

・どうやってグラフを描くか
　1) juliaでGraphs, GraphPlot
　2) Rで、library(igraph)のサンプルがあった

juliaもRもtkl/tkがないという
juliaはIJuliaのnotebookで表示できた。
RはMacの場合Quartzをインストール(CRANにリンクがあった)したらよかった
quartz()を起動すると別ウインドウで表示できるみたい。


2023/02/20月
・p2codeの1pairごとの拡張関係
　(make-nnmap sccp2)でclassify-cid-by-p2codeの結果を使って木を作る

(p2c-n p2c sccp2n) p2codeから番号
(n-p2c n sccp2n)   番号からp2code

==== funcions usage
(require :gtrail)
(in-package :rubbish)
(readkqc "kqc/path/graph201.kqc")
 (pg (c1))

;; ccp2は同じp2codeをもつcidのリストつきのリスト
(defparameter ccp2 (classify-cid-by-p2code))

;sccp2はccp2のfirstの長さでソートしたもの。secondはcidのリスト
(defparameter sccp2 (sort-ccp2 ccp2))

;sp2は長さ順のp2codeのlist
(defparameter sp2 (loop for x in sccp2 collect (first x)))

;sccp2に番号をわりふる。cidのリストがついている
(defparameter sccp2n (numbering-sccp2 sccp2))

;sp2nは、p2codeに番号を割り振る。p2codeのみのリスト。
(defparameter sp2n (numbering-sccp2 sp2))

; amapはsccp2のp2codeのお隣り(arrow)map (p2code (p2c1 p2c2 ...))*
(defparameter amap (make-nnmap sccp2))

; amapのp2codeを番号に置き換えたもの
(defparameter mapn (map-in-number amap sccp2n))

========


2023/02/19日
・p2codeの次のspccp2 の要素をもとめる
  (find-next-p2codes p2c allp2c)

・s2codeに番号を割り振る
　(numbering-sccp2 sccp2)
  (find-p2code p2c scpp2n)



2023/02/18土
・p2codeの包含関係と長さ+1で、となりのclauseをp2codeベースで定義してみた。
・head部分が同じならp2codeを含むという見方で(p2-adjmap p2cs)を考えた
  (cnext p2 allp2code) でp2の隣のp2codeを取り出す。
　p2codeがそういうふうにソートされているわけではないので、このアプローチはNG
・(p2c-containp p2 allp2)はp2の全pairを含むp2code in allp2を選ぶようにする。
　これにp2の長さ+1の条件を加えて、となりのp2codeを決めた
　　(wnext p2 allp2code)と(p2-wadjmap allp2cs)を定義した。
　　これでよさそうだが、数が増えるので、使い方を考えなくては。

・(p2toc p2code) => このp2codeをもつcid
を作った。なかったっけ??(p2top p2code) => pcode。これを思い出しているだけ

・ソートしたり手がはいっているので、それを除去することを考える


2023/02/14火
1) propが描けるか確認した(昔、書けるように作った気がする)

 kqc/prop/prop001.kqc
(1 () (+ P))
(2 () (+ P)(- Q))
(3 () (- P)(+ Q)(- R))
(4 () (- Q))
(5 () (+ R))

のようにかけた。引数のない述語に見えるが+/-が分離しているのでこれが命題だ。


2) 複数の証明環境を持てるようにする方法を考えた
　docs/20230214-metaverse.txt

3) orphanがあったときどうなるかを確認した
　orphanをのぞいて[]になればOKな気がする
　docs/20230214-orphan.txt

4) prover-gtrailが終わったあと、継続することについて考えた
　docs/20230214-resume.txt
  (prover-gtrail *goallist*)
　でできる。
　*goallist*を好きなように作れば、好きなように続けられる。続けるというのは違うかもしれないが

5) macroを作った。pg=prover-gtrail, pm=pmetrics. 
'(c1)みたいに'をつけるのが面倒なだけ

例
RUBBISH(4): (pg (c1))

start-time: 2023-02-14T10:19:29.116715+09:00

  ### PARAMETERS ###
  goals                = (C1)
  *max-clauses*        = 1000
  *max-contradictions* = 30
  *max-trials*         = 100
  *max-steps*          = 100
  *timeout-sec*        = 10
  *enable-semantics*   = NIL

limit-over number of contradictions exceeds

end-time: 2023-02-14T10:19:29.140190+09:00

  ### SUMMARY ###
  time consumed = 0.035740 secs
  #clauses = 481
  #contras = 31
  #valids = 0
  #trials = 2007
  #max proof steps = 20
NIL
RUBBISH(5): (lscova)

((C35 C46 C53 C69 C94 C111 C121 C128 C148 C155 C168 C196 C203 C226 C245 C255
  C262 C288 C299 C306 C322 C329 C345 C373 C384 C391 C404 C427 C434 C462 C481)
 NIL)
RUBBISH(6): (pm c35)
[C35]
  depth                 = 7
  num of clauses        = 12  see (cids-of-proof cid)
  num of input clauses  = 6  see (inclauses-of-proof cid)
  num of input literals = 9  see (inliterals-of-proof cid)
  num of preds          = 2  see (preds-of-proof cid)
NIL

2023/02/13月
proof metrixを作った
 proofのメトリックス(になりそうなもの)を計算する関数と表示する関数(pmetrics)

 literals-of-cidは意味がなさそうなのでやめた。inliterals-of-cidで十分では??


2023/01/21土
summaryのmax steps of proof数が0だ
証明のdepthを数えていない。
各resolventを作った時にそのdepthを計算し、propertyにいれておくのでどうか。
resolventのdepthは親のdepthのmaxにする

それでよいか?
とりあえずなくても困らないのでこのまますこし考える?

summaryの中で(lscova)から[]のcidをもとめて、そのdepth-cidのmaxを表示した
一回だけなので性能は問題ない



2023/01/20金
p2codeとpcodeの関係を考えた
p2codeのほうが正確。pcodeは高速なのか? ややあいまいなきがする。

2023/01/18水
・p2codeを作成した
　これは、resolveされたLIDペアのリストを(list-mgu cid)からとってきたもの。
  pcodeの曖昧さは、p2codeならないだろうという考えで、どれくらい違うかみてみたい。

  よく必要になるuniqをrubbish-essential.lispに追加。


・p2top は p2codeからpcodeを作る関数。追加
例)

(p2top '((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L9-1)
   (L3-2 L5-1)))

(L9-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L10-1 L1-1)

see 20230118-aboutp2code.txt


2023/01/17火
スクリプトからrubbish を使う別の方法。recip参照

1. script2.shを次のように作る
---
#!/bin/zsh

./test-path --script testdir/test-run.lisp 10 "kqc/path/graph201.kqc" '(quote (c1)))'
---

2. test-run.lispを次のように作る
---
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail '(c1))

(print-analyze (analyze-pcode))
---
これは、rubbish-statistics.lisp/test-graphとほぼ同じだが、(require :gtrail)も
ここに書いているので、core ファイル(test-path) のようなものはいらない。
ただし、実行時間はよけいかかるだろうけど。
それはcoreを起動するようにすればいいだけなので、 ここの問題ではない。

3. 実行
 ./testdir/script2.sh

*** string -> s-expはどうするか?
"(C1)" -> '(c1) にする方法?

 (read (make-string-input-stream "(c1 c2)"))
 => (c1 c2)

複数のs-expの場合は、

 (let ((s (make-string-input-stream "(c1 c2)"))) 
    (list (read s)(read s))
 )
みたいな

test-run.lispを次のようにすればgoalも指定できた


--- test-run.sh
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail (read (make-string-input-stream (nth 3 SB-EXT:*POSIX-ARGV*))))
(print-analyze (analyze-pcode))
---

--- script2.sh
./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph201.kqc" (quote (c1)))' --eva
#!/bin/zsh

./test-path --script testdir/test-run.lisp 20 "kqc/path/graph201.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph202.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph203.kqc" '(c1)'
---




2023/01/16月
・sbclのaliaasをlispに変えた
sbclを生で呼びたいこともあるだろう

rlwrap sbcl
を使うことをおすすめする > 自分

メモリふやさなくてもgraph201.kqcくらいは動く
・
-----
shin@Chapterhouse rubbish % sbcl --script test-pathfinder001.lisp
Unhandled SB-INT:EXTENSION-FAILURE in thread #<SB-THREAD:THREAD "main thread" RUNNING
                                                {70051701A3}>:
  Don't know how to REQUIRE GTRAIL.
See also:
  The SBCL Manual, Variable *MODULE-PROVIDER-FUNCTIONS*
  The SBCL Manual, Function REQUIRE
...

lispファイルはだめか。
coreファイルを作って(require :gtrail)まではやっておくか
test-graphの定義はrubbish-statistics.lispに追加した
　最初は、sbclの起動時の--evalで定義するのを考えたが、タイプが多すぎる。
test-graphをrubbish-package.lispでパッケージのexternにいれた。


★ステップ1　コアつくる :gtrailロードしたもの
shin@Chapterhouse rubbish % rlwrap sbcl
This is SBCL 2.1.9, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
CL-USER(1): (require :gtrail)
To load "local-time":
  Load 1 ASDF system:
    local-time
; Loading "local-time"

NIL

CL-USER(2):  (sb-ext:save-lisp-and-die "test-path" :executable t)
[undoing binding stack and other enclosing state... done]
[performing final GC... done]
[saving current Lisp image into test-path:
writing 1728 bytes from the read-only space at 0x300000000
writing 1840 bytes from the static space at 0x300200000
writing 0 bytes from the immobile space at 0x300300000
writing 42532864 bytes from the dynamic space at 0x7003000000
done]

** sb-extの指定は不要


★ステップ2 実行
  rlwrap ./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph001.kqc" (quote (c1)))' --eval '(sb-ext:exit)'

この実行のあと、REPLに残りたいときは、--eval '(sb-ext:exit)'を指定しない。
たとえば 
(print-analyze(analyze-pcode0))
をしたいとき
----
(in-package :rubbish)
(defun test-graph (mc kqcfile goal)
  (defparameter *enable-semantics* nil)
  (defparameter *max-contradictions* mc)
  (readkqc kqcfile)
  (prover-gtrail goal)
  (print-analyze (analyze-pcode))
)
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
------
test-gtaphの定義をどこかにうつして、スクリプトは
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
だけ書くようにする

テストのしかた

./testdir/script.shを作り
実行
./testdir/script.sh >xxx.txt
xxx.txtに結果出力される
(scriptコマンドを使うとへんなコード(^Mとか^[)がでたり、出力されなかったりした)


2023/01/15日
グラフの例を追加。
00?は直線
10?は複数パスの例
20?はループのある例
　201はa->b->a
　202はもうすこし長い
　203は複数パスのあるループ

(analyze-pcode)
(print-analyze)
などを作った

すこし様子をみた


2023/01/11水
グラフのパスをみつける例を作った greph101.kqc, graph102.kqc

そして
(lnumof Lid) ln-mからn
(cnumof cid) cn から n
を作ったが、なんのために作ったのか忘れた・・・

思い出したpcodeでLidのリストをソートするとき、今は文字列でやっているので
(pcode ...) の結果が
(L2-2 L2-1 L10-1 L1-1)
みたいになる。これを数字の順にしたかった

今はname<という関数を作っていて、これは文字列比較している。

関連して、string<とかstring>とか使っているsortを全部(name< (lnumof llid) (lnumof rlid))を
使うようにかえた。

残り
　もしかしたら L2-1とL2-2のsortでL2-2 L2-1にしたいかもしれない。

