
2024/02/13火
・rubbish-beauty.lispを最近作っていた。
　kqcをreadkqcしたものを手書きのclauseみたいに表示するもの。
　noteに書いている「論理に迷う」のサンプルとしてレシピを書こうと思って、以前のkqcを使い方ったから。

　cakeのkqcを見ていると、よくわからなくなっていた。
　Riceは篩にかけるという意味ではないだろうか。それならSiftだ。
　
・itoの使い方がわからなくなっている。
  lispで起動すると、(myload "ito.lisp")でitoはロードできる。
　(load "ito-asubst.lisp")はコードにエラーがあるらしい。
　　と思ったが、asubstを定義している play-newsubst.lispをloadしていなかったからだった。
　問題なく動作した。

 


2023/08/10木
・初期記述Σにfact列φiを適用していって矛盾がでたら置き換えるという操作でどうなるか。
　運動のときのことも思い出す
　新しいfactで置き換えるのは、単純化だけどセンサーではない場合、factを信頼できる場合としては考えられる。



2023/07/28金
・sazare.github.ioにまどかのpdf
・下書き書き


2023/07/16日
「まどか」の全体を考えていた。
用語の定義が必要

矛盾を結節点とするΣの遷移として世界の記述を整理する。
ストーリーを矛盾しないfactの列してとらえる。
とはいえ、死などの世界を変更する事実は矛盾を引き起こすから、何かストーリーと矛盾の関係は違うかも。

まどかの例から、人の信じる世界あるいは記憶の世界は現実とは別のΣとして存在するという表現ができるのではないか。
記憶なのか、空想なのか。

ファイル名に空白や特殊記号の入っていたものがあったので、変更した。


2023/07/09日
ここ数日、「魔法少女です」の複数の定義とその関係について考えていた。
概念をモデルで解釈するとき、その解釈が妥当かどうかを確認するための操作が概念とともに提供される必要がある。
複数の定義は、そういう役割を果たすのかなと思う。
数学でも、同じ概念が複数の定義と同値だという話をするが、あれは文脈がひとつしかないからどれかひとつの定義を使えばよいということになるのだけれど、野生のモデルではそうもいかないので、そういう「野生性」を考える必要があるのではないか。

2023/07/05水
・恭介魔法少女問題について考えている。

・*timeout-sec*を超えてもなかなか終わらない件
　判定タイミングが、1レベル終わった段階でなく、resovle-idかなどのタイミングであればどうか?
　その場合、gloal jumpをどう書くか?
　*max-clause*についても同じかも。

・「契約する」という述語はおかしいので「契約した」に変えた madoka/*.kqc

2023/07/04火
敬語モデルを考えた
　Aの主観でのA-Bの関係とBの主観でのA-Bの関係を尊敬値のような抽象化した関係で表し
　敬語の発生や食い違いによるトラブルを表現できるかどうか
　　ここから、メール敬語サービスのようなものを考え
　　敬語不要な世界を導く


2023/07/02日
まどか
*qbei/da001.kqc

　キュゥべえは、殺されても新しいのがくる
これをこう書いてみる。
( (w) (- kill w q) (+ death q))
( () (- death q)(- death q))
( () (+ kill homura q))

これだと、次の2つの問はどちらも□になりQは死んでいるし死んでいない。

;; ? ( () (- death q))
;; ? ( () (+ death q))

実際には、1つめのQが死ぬと2つめのQが発送されるだけで
Qにインデックスをつければ解決するかな。

* rule-0001.kqc
 (穢れ (魂 who) )のところを(魂 who)にしていた。




2023/07/01土
・まどかをrefactoringしている。
　書けないかもしれないような事態がいろいろある。



2023/06/30金
・操作/手続/変化させることと関係表現の関係について考えた

・rule0001.kqcにキュゥべえはインキュベーターであるというのを加えた。

状態を変化させるのは、なにか。

* kqcにテンプレートを通して、わかりやすい日本語にする方法

　(+ 魔法少女です who) => "whoは魔法少女です。"
　(+ 契約する キュゥべえ who) => "whoはキュゥベェと契約する。"
あるいは
　(+ 契約する who whom) => "キュゥベェはwhomと契約する。"
などのルールを書いておいて
　translate(kqc, rule) => テキスト
 するというのはどうか?

・まどかで、いろいろと気づいた点がある。→20230630-relandproc.txt

2023/06/29木
・readekqcで、kqcの中の(readefile ...)が読み込まれていなかった。
　readefileの中で、readefileのevalの結果を()で置き換えていた。
　それを修正した

2023/06/27火
childからparentに送る(ts coninf)のカッコをformat でつけているが
データをlistにすればよいような気がする。
タイムスタンプを送らないことにした。将来大丈夫かよくわからない??

RUBBISH(5): (pl mmm)
((1 (X.129) (+ P X.129)) (L5-2 L5-1 L4-2 L4-1 L1-1) (L3-2 L3-1 L2-2 L2-1 L1-1))
((2 NIL (- P A) (- S A)) (L3-2 L3-1 L2-2 L2-1 L1-1))
((3 NIL (- P B) (+ S A)) (L3-2 L3-1 L2-2 L2-1 L1-1))
((4 NIL (- P A) (- R A)) (L5-2 L5-1 L4-2 L4-1 L1-1))
((5 NIL (- P B) (+ R A)) (L5-2 L5-1 L4-2 L4-1 L1-1))
という具合に、continfはcdrになっていて()が一つへっている。

* まどかのjuliaの命題をすこし移した
　sbclで日本語のatomが使える

2023/06/26月
result.msgはsupresedeで作ることにした。(new-flog)

mkfifo result.msgでやってみたら、やはりとまってしまった。

　fifoの場合どうすればよいか?
    run-programで非同期に実行できるかな
　もしできたとしても、今度は子の終了を調べなくてはならない。いまは無理か

最後にresult.msgを消すまではしなかった

　もしも子を並列に実行する必要性がでてきたら、run-programをthreadにわけて実行するとか。
　その場合、同じファイル名ではだめなので、全体的な構造を見直さないといけないようだ。

復帰値を矛盾情報にした。こんな感じで、復帰値つかうときはTの表示は不要だなあ。

RUBBISH(4): (setq mmm (mujun-finder "kqc/mujun/mj301.kqc"))
kqc reading: kqc/mujun/mj301.kqc
.....
(1 (X.129) (+ P X.129)): ((L5-2 L5-1 L4-2 L4-1 L1-1) (L3-2 L3-1 L2-2 L2-1 L1-1))
(2 NIL (- P A) (- S A)): ((L3-2 L3-1 L2-2 L2-1 L1-1))
(3 NIL (- P B) (+ S A)): ((L3-2 L3-1 L2-2 L2-1 L1-1))
(4 NIL (- P A) (- R A)): ((L5-2 L5-1 L4-2 L4-1 L1-1))
(5 NIL (- P B) (+ R A)): ((L5-2 L5-1 L4-2 L4-1 L1-1))
(((1 (X.129) (+ P X.129)) (L5-2 L5-1 L4-2 L4-1 L1-1) (L3-2 L3-1 L2-2 L2-1 L1-1)) ((2 NIL (- P A) (- S A)) (L3-2 L3-1 L2-2 L2-1 L1-1)) ((3 NIL (- P B) (+ S A)) (L3-2 L3-1 L2-2 L2-1 L1-1))
 ((4 NIL (- P A) (- R A)) (L5-2 L5-1 L4-2 L4-1 L1-1)) ((5 NIL (- P B) (+ R A)) (L5-2 L5-1 L4-2 L4-1 L1-1)))
RUBBISH(5): mmm

(((1 (X.129) (+ P X.129)) (L5-2 L5-1 L4-2 L4-1 L1-1) (L3-2 L3-1 L2-2 L2-1 L1-1)) ((2 NIL (- P A) (- S A)) (L3-2 L3-1 L2-2 L2-1 L1-1)) ((3 NIL (- P B) (+ S A)) (L3-2 L3-1 L2-2 L2-1 L1-1))
 ((4 NIL (- P A) (- R A)) (L5-2 L5-1 L4-2 L4-1 L1-1)) ((5 NIL (- P B) (+ R A)) (L5-2 L5-1 L4-2 L4-1 L1-1)))

構造は
(goal . pcode*)


2023/06/25日
result.msgで子→親のやりとりをすることにした
result.logはログ
ちがいは、データをs-式で持っていることin msg

in result.log
(timestamp (consistent goal))
(timestamp (contradiction goal pcode*))


2023/06/24土
方法案
1) mkfifo で名前つきパイプを作る(親で作るか、shで作るか)
2) 子でそのパイプに復帰情報を渡す。consisかcontraか、pcode
3) 親は子の終了後それを読み込む。あるいは別スレッドで???

fifoの使い方は、learningcommonlisp/procsのpipe-op.lisp参照
read-lineを使っているが、ここをreadにして、両方listで
(consistent)
(list contradiction contrainfo)みたいにする
contrainfoは
1) (car (lscova)) がcidのリストなので、これからpcodeを作って、
(classify-cid-by-pcode (car (lscova))
で (pcode cids)*ができる。

これはわたせる。cidいるかな??
また、fifoだと、child側が終了できるだろうか?
parent側はchild作って、終了したらreadするので、child側は
終了できないような気がする。

それならfifoでなく、普通のfileでよいのでは??


2023/06/23金
・子プロセスから結果をもらいたい
　子プロセスは1度にひとつしか作らない。今は。
　　子プロセスを使うのは実行空間を別々にしたいからなので、複数実行する必要はない。

　今、ファイルに出力(あるいはT)している内容でなく、必要な情報だけ渡したい。
　goal, kqc -- 親は知っている。ただし、複数子プロセスを作るときはgoalもあったほうがよさそう。
　子プロセスのid -- 呼び出すときidを振り分けたらよいかも。
　parameterも必要かも。
　結果
　　無矛盾 nilでよい、:maybe-consistentでもよい。
　　矛盾　 contradictionのp2codeがほしいかもしれない。
　　　　　　p2codeからproofを再現できないかもしれないがinput clauseは親子共通なので、これを元にしていれば話せる。
　　　　　　だから、Lidは共通。

　矛盾は一個しかみつからないか?


2023/06/20火
github/learningcommonlisp/procs
プロセスの実験
mujunはうまくいっているが、かなり微妙。
シンプルな構造でやってみた。
outerprocs.lispが呼び出し側で、innerprocs.lispが呼ばれ側のscript。
innerはloadすると最後に書いた関数が実行される。
mujunとは違う制御。

uiop:run-programの引数に:outputがあって、指定するとそこに出力される。
inner側でwith-openしてもできるが、こっちの方が楽。

run-programの値はうまくいったかしっぱいしたか。
inner側の関数の復帰地とは関係ない。

rubbishでは管理するソースを1本にしようとしたが、procsのようにバラバラにしたほうがわかりやすい。
特に、別プロセスで動かすから。threadなら同じにしたほうが変数の関係などわかりやすいかもしれない。

別プロセスにしているのは、rubbishがpropertyを使うなどして、プロセス空間を汚染しつくしているから、
別のΣの証明を1空間に維持することはムリ。
threadで同一空間ではできないし、いくつΣを使うのかもわからないので、やはりprocessがよい。


2023/06/08木
・なぜかml002.kqcが*enable-semantics* をtにしても矛盾がでなくなった。

prover-gtrailを実行する前にtにしても処理が終わるとnilになっている
show-parameterでnilといっているので、最初のほうでnilになっているらしい
★ mujun.confで設定していた
★★ これはわからないので、enable-* は*.kqcで指定することにする。confではしない
[確認すみ]


2023/06/07水
・コメントの書き方で
#|
こめんと
こめんと
|#
と書けるのをrecipeで知ったのでkqcでかけるかためしてみた。
comment.kqc
readekqcで正しく読めた(というかコメントは読み飛ばせた)


・runmujun.shのパラメタ違いのときのusage表示追加。
・mj207.kqcとmj208.kqcのclauseの順を逆にした
　　head -2 *.kqcのとき、内容がわかりやすくなる。
・readekqcの終わりの*clist*の順を逆にした。max → 1だったのを書いた順の1→maxにした。
　他に影響がないかよくわからない。
　exp-clistとinit-kbでreverse *clist* していたので、そのreverseをとった。
　これらの関数は他で使われていなかったので、影響はないと考える。

* readXkqcを繰り返すと、*clist*の順序がめちゃくちゃになるのを修正。つまり
1回目 *clist* = (1 2 3 4)
2回目 *clist* = (4 3 2 1  5 6 7)
などとなっていた

****
　既存のΣの無矛盾性をチェックするのはmujun-finder
　fact列で、次に加えるfactが矛盾するかどうかを判定するのは、prover-gtarilを直接使えば良い。
　　Σに含まれないgoalでチェックするinner-mujun-finderも使えそうだが、無駄なproveringをするのでだめ。
　新しいclauseをreadskqcしたとして・・・

　... 考え中 ...




2023/06/06火
・mujun-finderで、kqcから1つのclauseを選んだ時、それを作り直して実行する必要はないのでは?
  check-mujunのときみたいに、cidだけ指定すればいいのでは??

そのようにしたバージョン
　(mujun-finder kqc)

　呼ばれる関数は末尾に-nをつけた。

inner-mujun-finderはΣ内のclauseしか指定しないので、cannonみたいに新たにclauseを作る必要がない
ところ、わざわざ作っていたのでそれをやめたのがmujun-finder

だから、cannonもinnerもコード消して良い

・pred記号が全部orphanのとき無矛盾判定していたコードは残しておいてもいいかも。
　なので追加した。

・メッセージも見直し、mujun/*.kqcについて動作させ、矛盾が発見できるかみた。
　パラメタの値が妥当かよくわからない。
　

2023/06/05月
・inner-mujun-finderの子プロセスで、パラメータを変えたいのでmujun.confをloadするようにしたin {pure-}prover-gtrail
・普通のproverとmujun-finderで違うので、切り替えられるようにしたいが、同じmujun.confなので気をつける必要がある。

・cannon-*と古いcheck-mujunやmujun-setをコメントアウトした。間違っているから。
　でもまだ消せない

・reqdekqc で、eval x とかくと(eval x)するようにした。
　しかし、mj001.kqcに(eval (setq *enable-reduce-syntax* t)とかくと
----
RUBBISH(3): (inner-mujun-finder  #p"kqc/mujun/mj001.kqc")
kqc reading: kqc/mujun/mj001.kqc
....
start : 293023check-mujun-on g=(NIL (- P A) (- S C)) kqc=kqc/mujun/mj001.kqc
cmd = sbcl --control-stack-size 128MB --sysinit rubbish-mujun-init.lisp --eval '(rubbish:mujun-prover)' '(NIL (- P A) (- S C))' 'kqc/mujun/mj001.kqc'

Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

restarts (invokable by number or by possibly-abbreviated name):
  0: [CONTINUE] Ignore runtime option --eval "(rubbish:mujun-prover)".
  1: [ABORT   ] Skip rest of --eval and --load options.
  2:            Skip to toplevel READ/EVAL/PRINT loop.
  3: [EXIT    ] Exit SBCL (calling #'EXIT, killing the process).

(RUBBISH::ADD-CID EVAL)
   source: (MAX *MAXCID* N)
0]
-----
というようなエラーになる。
色々調べたがよくわからないので、mujun.confで切り替えるようにした。
このエラーを見る限り(eval ...)をclauseと思って変換しているようだが・・・
(readekqc ...)
単体では問題がおきない。
よくわからない。readkqcを読んでいるか。それだった。

*enable-reduce-syntax*をkqcによって切り替えたいか?とは思う。
いまは、これをtでいろいろ動かしてみたいのでparams.lispでtにしておき
kqcでは指定しない。mj001.kqcだけ残す
この指定が有効になるようなので、これでもいいのかも。(6/6)

以上から
mujun.confの設定はprover-gtrailで読み込む。有効になることを確認。



2023/06/04日
・停止条件の処理がおかしかった
 - *num-of-trials*が参照されていなかったり、したので
　tirals-countを*trials-count*にかえて数えるようにかえた
   resolve-idのあと。trialsは失敗してもカウントするのでこれでよい
trialsはresolve-idで、失敗した回数も含む。
clauseの数は、成功したresolve-idの数(input clausesも含む)になる。

- contradictionsを*contradictions*にした。contraditionsの数はこれをもとに計算するようにした
　gather-contradictionsでcontrasを計算しているので二重にcontradictionsを求めている
    違っていたら問題なので一方にしたい。gathercontraは

昨日から出ているdefconstantのえらー
--------------------
ASDF could not load gtrail because The constant +RESULTLOG+ is being redefined (from "mujun-output/result.log" to "mujun-output/result.log")
See also:
  The ANSI Standard, Macro DEFCONSTANT
  The SBCL Manual, Node "Idiosyncrasies".

debugger invoked on a SB-EXT:DEFCONSTANT-UNEQL in thread
#<THREAD "main thread" RUNNING {70086C03A3}>:
  The constant +RESULTLOG+ is being redefined (from "mujun-output/result.log"
  to "mujun-output/result.log")
See also:
  The ANSI Standard, Macro DEFCONSTANT
  The SBCL Manual, Node "Idiosyncrasies"
--------------------
#p",,"にして解決した。同じ文字列でも違うオブジェクトになる。


2023/06/03土
・つまり、一般にΣが無矛盾だということは証明できない。特別、有限の場合はできる。
だから、「Σが無矛盾である」というのは断定できない。

そこで、Σ=∅からはじめて、ひとつひとつclauseを追加していくことを考える。

世界についてのfactは、無変数と考えられて、それを無矛盾を維持して追加していくことはできる。

・ファイルパスをdefparamerで名前をつけた

   mujun-output/mujun.log => +MUJUNLOG+
　mujun-output/result.log => +RESULTLOG+

 recipe をみると、defconstantには+をつけるらしい
defconstantにすると、asdfが再定義しているという。
(require :gtrail)で一度このエラーがでるが、もう一度(require ...)をすると出なくなる
こわいのでdefparameterにかえた。変数名は定数の気持ちを表すため


2023/06/02金
・昨日の段階で、canonicalによるmujun checkerは矛盾をみつけすぎであり、
その原因はcanonial clauseが一般的すぎてΣにない矛盾までみつけてしまうからだった
<+P(a):-P(b)>の場合

そこで、先のcheck-mujunの方法で、∀c∈Σ check Σ,c⊢□でやるものを作った
それが inner-mujun-controller in rubbish-mujun.lisp
昨日のcheck-mujun-controllerはcannon-mujun-controllerとした。

mj202.kqcが、{+P(a), -P(b)}であり、cannonとinnerで実験したところ
cannonでは□がみつかり、innerでは無矛盾となった。

また、mj00[12].kqcはunit clauseがないケースで、以前、check-mujunでは矛盾がみつけられなかったもの。
これは、cannonでもinnerでもみつけられた。
reduce-syntaxを実装したので、innerでもみつけられるようになっている。

この結果をmujun-outputの下のsub dirに保存しておいた。
result-cannon-mj202-findcontra
result-inner-mj001-findcontra
result-inner-mj002-findcontra
result-inner-mj202-nocontra

これで十分なのだろうか。他の例も考えてみるひつようがある。



2023/06/01木
・kqc/mujunの整理
　mj2*は基本的なものにした

・rubbish-flog.lispを作成
　(create-flog filename)でファイルを作り(あったら上書きする)
    (flog filename format data...)で出力する
    x filenameで指定するのがいやだけど、その場その場でcloseしたいし、fidみたいのは使えない

・run-gtrailを作るスクリプトmake-gtrail-image.shを作った
　昨日まではrun-mujunにしていたが、中身が(require :gtrail)だけなのでこの名前にした。
　run-gtrail以外の名前もつけられるようにパラメタでファイル名をとるように拡張できるが、
　やることは(request :gtrail)に固定なので、このままにする。

imageを使ったcontrollerのほうの動作も確認した。
このソースをrun-programの行をコメントアウトしておいたら、実行時にエラーになった。
かっこの構造がわからないようだ。

とりあえず、関数の外側にこのコメント行を残した。
もっとよい方法を考えよう
ということで、(xxx-mujun-finder kqc &optional (faster nil))とした
開始・終了時刻と経過時間をmujun.logに出力するようにした。
確かにすこしだけ速くなる。
kqcが小さいのでそうなのかもしれない。

innerとcannonの比較ではcannonが速いが、そもそもcannonは間違っているので比較してもいみがない。
残しておく理由もないかも。

★★★ ソースを修正したら必ず、make-gtrail-image.shの実行をすることにしよう。
　run-gtrailを使わないバージョンでも、問題ない。
　　　　忘れないようにするためにスクリプトを作ったのだし。

忘れずにやるようにするのは難しいかな。


・矛盾がどのような場合に発生するか考える


2023/05/31水
check-mujun調整
1) run-mujunなしで動いた
　しかし、性能が必要なときはこれを使うべき
　そのため --sysinit rubbish-mujun-init.lispを使用。
　　init.lispではquicklispの初期化だけしている。(require :gtrail)のため

2) 出力はmujun-output/result.logのみにした
　work.logへの出力はコメントアウト
　work.txtはprover-gtrailのログ

3) 矛盾がでない場合のメッセージ
　　1) 全部isoのとき、Σ全体がconsistentかもしれないメッセージ
　　2) isoのliteralについてメッセージを出す
　　3) 出ていない) (lscova)でcontraがでていないとき。もしかして

★★ この方法では次の場合に矛盾があることになる
{+P(a), -P(b)}
(x).+P(x)と(x).-P(x)でチェックするから・・・

ううむ


2023/05/30火
・いちおううごいた
手順
 1) save image run-mujunを作る
    $lisp
　　(require :gtrail)
       (sb-ext:save-lisp-and-die "run-mujun" :executable t)
 2)
    $lisp
　  (require :gtrail)
      (in-package :rubbish)
      (check-mujun-controller "kqc/mujun/mj1101.kqc")

　呼び出すところは
　run-programでsbcl --core run-mujun  --eval '(mujun-prover)' $g $kqc $ofile
みたいなことをして、呼ばれた方の動作確認した

　この場合、rubbish-mujun-prover.lispは不要で、定義している mujun-proverもrubbish-mujun.lispに含めれば良い。
　が、rubbish-mujun-prover.lispは別にして、gtrail.asdに含めている。

★ちょっと疑問
・save imageを作らないとうまくいかない。
　run-programしたとたんどこかに行ってしまう。

・? lispでrequire gtrailして、直接mujun-proverを動かしてうまくいく。つまり、呼ばれる側の動作は確認した。
　(mujun-prover g kqc ofile)

　ログをwork.txtにとり、かくproverの出力はmujunxxx.outにしている。

・run-programにすると動かないのは、この関数の使い方だ。
　(require :gtrail)をmujun-proverで

★
　prover-g trailのあと、(lscova)しても(nil nil)
　contradictionがみつかっていない??

★　(prover-gtrail '(c0))を実行しても*clist*が増えていない。
　手でやると増えている。
　*clist*の定義がdefvarだったのでdefparameterにしてみたが同じ

　prover-gtrailが動いていないのか??

　prover-gtrailのreturnが(contradictions valids)なので、その値を使ってみる
　やはりnil

　step-solverの値もnil
ここまでは check-mujun-controller経由の実行

*単体で動かしてみると
 (mujun-prover-inside "(()(+ P a))" "kqc/mujun/mj101.kqc" "mujun-output/debug.out")
これならC3がみつかる。

* prover-gtrailでgid=c0をevalするとエラーになってるらしい。

***どうするか?
* できていること
  prover-mujun-inside, prover-mujunは動いている(c3がみつかってログにでる)
  run-programでパラメタ goalの文字列、kqc, ofileは渡っている

* できないこと
　(prover-gtrail '(c0))を実行してもcontraがでない。
 確認　c0は(L0-1)になっている。

1) run-programで直接起動すると何が違うのか?
2) run-mujun経由がまずいのか??
3)  ちなみに(prover-gtrail)の結果がnilになっている。(nil nil)ではない???

c0とc1の違いは、symbol-plistのname。c0は0、c1はc1になっている。
関係ないと思うが・・・

C0のnameが0なのも気になるが、問題ないはず。

★canonical-clauseで、varsとclauseの変数名がちがっているからresolveできるはずがない。
(rawclause0 cid)が間違っていた
(vars . body)
となるべきところ
(vars body)
になっていた。



2023/05/29月
scriptの先頭に.sbclrcから次をコピーしておくとrequire は呼べる
------------------
#-quicklisp
(let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp"
                                       (user-homedir-pathname))))
  (when (probe-file quicklisp-init)
    (load quicklisp-init)))
;;; for ASDF
(pushnew #p"/Users/shin/.common-lisp/" asdf:*central-registry*)
------------------
? packageの関数をrun-program越しによべるのか?
--userinit xxx.lisp でrequire, inpackageとreadkqcを行い
--eval '(rubbish:print-clauses)'
で出力できた

また、xxx.lispでreadkqcをせずに
--evalで、'(let()(readkqc "...")(print-clauses)'
でも動いたので、scriptでin-packageしてあれば、evalの式はそのpackage内で動くように見える
-----

(quit :unix-status 2)でprocessの$?が2になる
run-programで実行して、値が0以外だと、breakしてしまう
　他の方法

*ファイル名のつくりかた
(format t "~4,'0d" 12)
数字の左側を0で埋める


2023/05/28日
shからsbclを呼び出す。check-mujunの道具

% cat c005.lisp
(defun a () (format t "in a~%"))
(defun b () (format t "in b~%"))
(format t "~a~%" (b))
------
% sbcl --script c005.lisp --exec '(format t "~a~%" (a))'
in b
NIL

execの結果がでないな
sbcl --eval '(format t "~a~%" 123)'
は
123
でる。



2023/05/27土
・矛盾チェックの準備

まず、lispから別のprocessでlispを実行する方法をしらべた
1. save-lisp-and-dieで、(require :gtrail)を実行したイメージ(rungtrail)を作る
2. sbcl --core rungtrail --script ....lisp　が動く
3. 2の行を含むshを作る
4. 3のスクリプトを sbclの中で、(uiop:run-program "zsh c001.sh" :output t)
あるいは
chmod +x c001.sh
で
(uiop:run-program "c001.sh" :output t)
で動く

あとはプロセス間でのデータのやりとり

* ml002.kqcの意味がわかった。
*enable-semantics*をtにしたが、計算されていない

C21: RESOLVENT NIL [((- >= 0.9 0.9) (- >= 0.9 0.8) (- >= 0.85 0.8))]
が残り、これはreduce-by-semanticsで□になりそうに見える。

これは、reduce-by-syntaxを作った時にこっちのパスを適当に修正したから。

reduce-by-syntaxの実行後、これの結果だけをreduce-by-semanticsに渡していた。
reduce-by-syntaxの前のresolventについても、by-semanticsを実行するようにしたら
矛盾がでるようになった

・clauseの証明にby-semanticsをふくむ場合もp2codeやpcodeが表示できている



2023/05/25木
・rubbish-goods.lispを追加
　長い函数名をmacroで短くする
(rp path) = (readkqc path) (print-clauses)
(pc cid)   = (print-clause cid)
(pcs)       = (print-clauses)
(ppg gs path) = (play-prover-gtrail 'gs path)

rubbish-goods.lispはgtrail.asdに追加した

[使い方]
(require :gtrail)
(in-package :rubbish)
(rp "kqc/...")
(pg c1)
や
(pg c1 c2)

;(prover-gtrail '(c1))
(pg c1)

;表示
(pc) = (print-clauses *clist*)
(pc c1 c2) = (print-clauses '(c1 c2))


または

(play-prover-gtrail '(c1) "kqc/ml002.kqc")
(ppg (c1) "kqc/ml002.kqc")
;;
;; 昨日までは(play-prover-gtrail '(1 2) "...")だったが、ここだけ数字だとよくわからなくなるのでC1 C2とするようにした



; set some rubbish parameters different
(load "pre-rubbish.conf")



2023/05/24水
・kqcやplay-*.lispの整理の前に、ひととおり動かしてみる。


2023/05/18木
・kqcを整理しておかないといけない。全部やりなおすため

記録する項目は?
kqc path/目的/特徴/補足/使い方

分類コードは?

実行するパラメタは?

*max-clauses*
*enable-reduce-syntax* 
*enable-semantix*

rubbish-setup-unif.lispで代入はparに設定している。だったらeval不要では??


2023/05/17水
・goalが複数リテラルの場合、矛盾があっても矛盾が出ない
kqc/merge/mg004.kqc
 (prover-gtrail '(c1))
C14: RESOLVENT NIL [((- P A) (- S A))]
C13: RESOLVENT NIL [((- P A) (+ S A))]
C12: RESOLVENT NIL [((- P A) (- S A))]
C11: RESOLVENT NIL [((- P A) (+ S A))]
C10: RESOLVENT NIL [((+ P A) (- P A))]
C9: RESOLVENT NIL [((+ P A) (- P A))]
C8: RESOLVENT NIL [((- S A) (+ P A))]
C7: RESOLVENT NIL [((+ S A) (+ P A))]
C6: RESOLVENT NIL [((+ R A) (- S A))]
C5: RESOLVENT NIL [((+ R A) (+ S A))]
C4: C4 NIL [((- P A) (- S A))]
C3: C3 NIL [((- P A) (+ S A))]
C2: C2 NIL [((+ P A) (- R A))]
C1: C1 NIL [((+ P A) (+ R A))]
こんな感じで永遠に続く

★現在のprover-gtrailでは、lsym∋lidがinputだけなので、全部2-literalsのこのような例では矛盾はでない。

entry-reduceでpushlsymをするようにした。
ただし、make-lidでlidを作ってから、それにsetlidをして、pushlsymをするなど処理が煩雑
entry-clauseでも同じではないか


2023/05/15月
step-solverでLLがLになるのは確認した。

prover-gtrailが、unitのないclause setで□をだせない点。
goal/factのある世界を考えていたのでこのようなΣでは□はだせない。

check-mujunのようにc ∈Σについて、Σ, c⊢□もでない

述語記号について +Pとか-Pを作ってΣ, +P⊢□もできない

これは、resolventをopposの+P, -Pに追加していないからかな。
+P, -Pにはinput literal idのみが登録されている。

・resolventはentry-lid
・inputclauseはmake-lid

resolve-id -> entry-clause -> setlid これは、lidのplistの設定

(input) make-lsymlist -> pushlsym ここで、lsym(+/-P)にlidを追加している。
　だから、resolventのlidをpushlsymすれば追加できる。


・矛盾解析に必要な機能は何か?

(entry-clause)と(entry-reduce)にpushlsymを追加したが、新しいlidを設定しなくてはいけないのに
もとのコードはもとのlidに設定していた。
entry-clauseについては、resolventを登録するという処理はなかったので、今まで問題にならなかったのか?

このコードは、


2023/05/14日
step-solverにstep-reduce-syntaxを組み込んだ
  step-reduce-syntax/reduce-id
　だからprover-gtrailもpure-prover-gtrail自体は修正していない。両方ともstep-solverを呼ぶ

* 名前:reduce-syntaxはreduce-propがよいのではないか?

[おかしい点]




2023/05/13土
・reduce-idは　pure-prover-gtrailにだけ組み込めばいいのではないか。mujunチェック用ということで。
　prover-gtrailでは、こういうことが起きないような気がするので様子見。

・単体で動作
　　reduce-id　　2つのlidでreduceする
       match-lids　cidからlidをみつける
       step-reduce  cidからlidみつけてreduceする

　print-proof0, print-proof修正した。0と無印の違いがよくわからない

　p2code, pcodeは動かない
　　だから check-mujunは動かない

2023/05/12金
・+P+Pα => +Pα
　の処理を追加したい。
　ルール名は  reduced-by-syntax
　+Pはequalのときだけ適用する。(equal lid1 lid2)でよい。
　もしも、<L1:L2>=σ≠∅の場合、L1α・σとすると、L1>L2なら、-σの範囲にあるtermが除外されてしまうので適切でない。
　逆にL2・-σも意味がおかしいので、まったく同一の場合だけ1つにするというルールにする。だから、命題算のルール。
　equal-litとかequal-lidという関数を使っていないので、名前はこれ
　reduce-by-semantixを参考に作る

　L1L2L3αの場合もL1αとしたい。proof-stepの構造としては、2▷1の形とし、3Literalの場合は、2回適用する。
　ルールが適用できなくなるまで繰り返すということか。

　rubbish-resoid.lispに含める。

  reduce-idは動いた。1ステップなので、これをどう組み込むか。

2023/05/11木
・Σ, c ⊢ ?
を考えた時、Σ∋cでない場合を考えたほうがいいのかなと思う。
Σ, cで証明する中で、cとcのresolutionは起きないのか?
+Pの形なら、resolveされないので問題ない。
しかし、cが-P+Pのような形なら起きるだろう。

述語命題なら、+P(x)-P(f(x))
Σ={+P(a), -P(f(a))}なら、□になる。
なるがどうした?

これは矛盾を含んでいるのか??
conj +P(f(x))で¬conj -P(a)を使ってrefutationするときは、{+P(f(a))



2023/05/10水
mutatから不完全な□を削除するようにした

問題は
-P(x,a)
が
+P(3,a)
のconflictの原因ということで消されてしまうこと


2023/05/09火
・□の件
mutateで発生する□は、処理後
RUBBISH(16): (p2code 'c19)

((L17-1 NIL))
こんな感じになっている。消したcidのlidがなくなっているため。
だからこの□は消したほうがよい

*変数がはいってくるとややこしくなる
-P(x,a)で初期状態を表した場合
+P(3,a)で-P(x,a)からx=3の場合を除外したいが-P(x,a)ifx≠3は、その次の移動で-P(3,a)がきた時
if x≠3を消すとかなんとかしたなくなる。それは大変
では
-P(x,a)∨+P(3,a)みたいにすればいいのか?

{-P(x,a)∨+P(3,a), +P(3,a)}と??
そして
-P(x,a)∨+P(3,a) x -P(3,a)で
-P(x,a)
に戻れば良い。もどるかな。

これは、Σ x cで、Σの中から〜cをすべて消し去るようなこと。cがunitだから意味ありそうに見えるがそうでなかったら?

proverの場合、-P(x,a)をそのまま残しておいて十分か?
というのは
+P(3,a)は-P(3,a)とのconflictで消せる
-P(x,a)は-P(3,a)と交わらないので透明
だから

なんかそれでいい気もする

では
-P(x,a)
は、空間全体にaが存在しないというよりは、デフォルトがaの不在みたいな感じがする。




2023/05/08月
運動の例で、はじめて矛盾解消ができた
20230312-conflict-disolver-lisp.txt

一番単純な例だと思う。
どこまで一般化できるだろうか

運動の例を最後まで実行するスクリプトを作って記録をのこそう。今は時間がない。

**
削除するclauseの判定をclauseのborn-whenの古いものを選ぶように変えた。

そして、全体を実行する。

bug1 : f2を実行すると、+Pがorphanになる。
RUBBISH(38): (mutate f2)
orphan lsym L13-1 in C13.
NIL

create-cid でf2を作ったとき+PにL13-1がはいっていない??
入力データでliteralのリストにしていた。
(() (+ P x))
とすべきところを
(() ((+ P x))
にしていた
プログラムの問題ではなかった。
★それがわからないのがまずい

こんな感じでどうさする。
(require :gtrail)
(require :mutat)
(in-package :rubbish)

; no a in [1:10]
(factisf (loop for i from 1 to 10 collect (list () (list '- 'P i 'a))))

(setq f1 (factIs ( () (+ P 1 a))))
(mutate f1)

(setq f2 (factis (() (+ P 3 a))(() (- P 1 a))))
(mutate f2)

(setq f3 (factIs (() (+ P 8 a)) (() (- P 3 a))))
(mutate f3)
---
ここで、check-mujunで作った□がずっと残っているのはよくなさそう。
あとで消すか
*clist*に追加しないようにできるか??

[]をremove-cidすればよいのだが、不思議なことに□があっても問題ない。
というのも、goal g は絶対に□とresolveされることがないから。★
これは逆説的で面白い。

とにかく□は残しておこうかなと思う。



2023/05/07日
rubbish-prover-gtrail.lispで
pure-prover-gtrailはprover-gtrailの一部であり、check-mujun用に抜き出したもの。
停止用チェックのメッセージなどをはずしている。

これ、ひとつにならないだろうかと思う。

check-mujunをrubbish-mujun.lispに分離
pure-prover-gtrailは、prover-gtrailと似ていることがわかるように、
　　いつか、ひとつにできるかもしれないので、もとのままにした。
　実際はcheck-mujunのためだけにあるので、こっちにいれたほうがよいかも。

1) mujun-setは、Σのclause cに対する矛盾集合(複数)をみつける関数。
　


・追加
(isinputcid cid)
(isunitclauses cid) => (isunitcid cid)


***　これで、矛盾集合からキーとするcidを選ぶ用意はできた。
　どう判定するかは難しい


2023/05/06土
運動の例で、動的fact列の処理を考えようとしている

mutat システムを作った
(require :gtrail)
(require :mutat)
(in-package :rubbish)
で使える。
20230312-conflict-disolver-lisp.txt
で例をやってみている

>>
aの存在しない状態を記述してから
factでaの位置を与える
矛盾したらも古いfactを消去する
<<
という手順

2023/04/25火
　新しいfactにより矛盾するΣと矛盾解消の例を考えたい


2023/04/08土
・4/2にΣの無矛盾性を判定する方法を考えた。これに続くこととして
　1) Σの部分矛盾集合のぎりぎりおおきいものの検出
　　そういう集合が存在するのかどうか?
　　複数ある場合について
　2)　Σから無矛盾部分集合を取り出すことはできるのか
　　これは操作の目的がうまく定義できないような気がする。

・証明器の正当性の定義と証明

2023/04/02日
・Σの無矛盾性チェックの実装
　rubbish-prover-gtrail.lisp
    (is-consistent *clist*)
    (pure-prover-gtrtail goals)

  ∀a ∈ Σについて　Σ, a ⊢□ を確認する。この証明があれば、Σ⊢〜aが証明されるということなので矛盾する。
　Σ, 〜a ⊢□ は常になりたつので確認不要。

2023/03/05日
・Σの拡張についてすこし検討した

2023/03/04土
・samplerunからadja、radja の行をコメンアアウト。使っていないので


2023/02/27月
・doc追加。tautologyとvalidの違いを書こうと思ったら、矛盾するΣとか
gを真にしてしまうΣとか


2023/02/26日
・digraphでpngを作る手順を作った
 digraphを作る部分 rubbish-digraph.lispにした
　最初に(require :gtrail)をするとコンパイラーでoffsetがどーのこーのいうエラーになった
　(load "rubbish-digraph.lisp")を一回やったらエラーがでなくなった。


2023/02/25土
・quicklispのgraphと名前にあるライブラリをさがしてみた
(ql:system-apropos 'graph)
いろいろあった
cl-graphは使い方がわからないし、maintainerがもうやっていないらしい
cl-digraphがどきゅめんとも書かれていて使えそう。
cl-digraphのグラフ表示は(ql:quickload 'cl-digraph.dot)
　pngが作れた。
(digraph.dot:draw *d* :filename "digraph.png" :format :png)
Graphvizのcl-dotを使ってcl-digraph.dotでグラフがかける



2023/02/24金
・自動ではいる改行を抑制したい
(setq  *print-right-margin* 200)
　~/.sbclrcに追加した

・show-parameter0, show-parameterで*kqc-file*を表示するようにした。
　他のパラメタと同じ扱いのほうがよいと思う。

・tkplotで、
　- layoutをeingold-Tilfordにするとツリー表示になる。逆さまなので
　　rotateをする。
　- epsを出力する
　　GIMPで変換する
　　1) 「名前をつけてエクスポート」
　　2) 出力形式はメニューから選べるので
　　　 pdfやpngにする。jpegはサイズがでかくなる

・p2codeに番号をつけたが、
　木の末端になるのは
　　1) contradiction(body がnil)
　　2) contradictionではないものは、proveの途中のものが残るような気がするが
　　　　[]と同じp2codeになるのはなぜだろうか?
　　　　literalが残っているが、input 射影で[]と同じになるもの。
　　　その意味は?

・作ったpdf, pngなどをgithubに追加したが、動かすたびに新規で置き換わるので、
  git statusでは、毎回untrackedになってしまう。よくないか
　次のcommitでgithubリポジトリから消えてしまうのでは?

2023/02/23木
・p2codeの木をRで描く
　sbclで隣接行列のlistをつくり
　そのままだと向きが逆なので転置
　adjmの転置なのがmjdaという名前にして
　mjda.r に出力する
・Rでは
  source(mjda-to-graph.R)
　とするとtkplot()でグラフ表示をし、手で操作できる。
　(コメントしているが、xquart()で plot(gr)してもよい)
　このとき、labelの値を隣接行列のnからn-1にしている
  0はinputで、そのあとのindexがnodeのindexより1大きいから

・Rのtkplotなどはpdfにexportできるので、その画像をdocsにいれてある


2023/02/22水
・Rでグラフを描く。
 sbclで隣接行列を出力する
　1. rubbish-analyze.lisp
　　　にグラフ関係をまとめた。他にもいれたい
　2. (defparameter adjm (conv-to-adjacent mapn))でbitmap行列に変換した
　3. (writeadj "adj.r" adjm) でファイルに出力。Rの形式

　R側ではこのadj.rを読み込むとadという変数に値が設定されるので
　matrix(ad, col=length(ad), row=length(ad))
　でmatrixが作れる


2023/02/21火
・隣接情報を取り出した。edgeの定義だけ取り出した

・どうやってグラフを描くか
　1) juliaでGraphs, GraphPlot
　2) Rで、library(igraph)のサンプルがあった

juliaもRもtkl/tkがないという
juliaはIJuliaのnotebookで表示できた。
RはMacの場合Quartzをインストール(CRANにリンクがあった)したらよかった
quartz()を起動すると別ウインドウで表示できるみたい。


2023/02/20月
・p2codeの1pairごとの拡張関係
　(make-nnmap sccp2)でclassify-cid-by-p2codeの結果を使って木を作る

(p2c-n p2c sccp2n) p2codeから番号
(n-p2c n sccp2n)   番号からp2code

==== funcions usage
(require :gtrail)
(in-package :rubbish)
(readkqc "kqc/path/graph201.kqc")
 (pg (c1))

;; ccp2は同じp2codeをもつcidのリストつきのリスト
(defparameter ccp2 (classify-cid-by-p2code))

;sccp2はccp2のfirstの長さでソートしたもの。secondはcidのリスト
(defparameter sccp2 (sort-ccp2 ccp2))

;sp2は長さ順のp2codeのlist
(defparameter sp2 (loop for x in sccp2 collect (first x)))

;sccp2に番号をわりふる。cidのリストがついている
(defparameter sccp2n (numbering-sccp2 sccp2))

;sp2nは、p2codeに番号を割り振る。p2codeのみのリスト。
(defparameter sp2n (numbering-sccp2 sp2))

; amapはsccp2のp2codeのお隣り(arrow)map (p2code (p2c1 p2c2 ...))*
(defparameter amap (make-nnmap sccp2))

; amapのp2codeを番号に置き換えたもの
(defparameter mapn (map-in-number amap sccp2n))

========


2023/02/19日
・p2codeの次のspccp2 の要素をもとめる
  (find-next-p2codes p2c allp2c)

・s2codeに番号を割り振る
　(numbering-sccp2 sccp2)
  (find-p2code p2c scpp2n)



2023/02/18土
・p2codeの包含関係と長さ+1で、となりのclauseをp2codeベースで定義してみた。
・head部分が同じならp2codeを含むという見方で(p2-adjmap p2cs)を考えた
  (cnext p2 allp2code) でp2の隣のp2codeを取り出す。
　p2codeがそういうふうにソートされているわけではないので、このアプローチはNG
・(p2c-containp p2 allp2)はp2の全pairを含むp2code in allp2を選ぶようにする。
　これにp2の長さ+1の条件を加えて、となりのp2codeを決めた
　　(wnext p2 allp2code)と(p2-wadjmap allp2cs)を定義した。
　　これでよさそうだが、数が増えるので、使い方を考えなくては。

・(p2toc p2code) => このp2codeをもつcid
を作った。なかったっけ??(p2top p2code) => pcode。これを思い出しているだけ

・ソートしたり手がはいっているので、それを除去することを考える


2023/02/14火
1) propが描けるか確認した(昔、書けるように作った気がする)

 kqc/prop/prop001.kqc
(1 () (+ P))
(2 () (+ P)(- Q))
(3 () (- P)(+ Q)(- R))
(4 () (- Q))
(5 () (+ R))

のようにかけた。引数のない述語に見えるが+/-が分離しているのでこれが命題だ。


2) 複数の証明環境を持てるようにする方法を考えた
　docs/20230214-metaverse.txt

3) orphanがあったときどうなるかを確認した
　orphanをのぞいて[]になればOKな気がする
　docs/20230214-orphan.txt

4) prover-gtrailが終わったあと、継続することについて考えた
　docs/20230214-resume.txt
  (prover-gtrail *goallist*)
　でできる。
　*goallist*を好きなように作れば、好きなように続けられる。続けるというのは違うかもしれないが

5) macroを作った。pg=prover-gtrail, pm=pmetrics. 
'(c1)みたいに'をつけるのが面倒なだけ

例
RUBBISH(4): (pg (c1))

start-time: 2023-02-14T10:19:29.116715+09:00

  ### PARAMETERS ###
  goals                = (C1)
  *max-clauses*        = 1000
  *max-contradictions* = 30
  *max-trials*         = 100
  *max-steps*          = 100
  *timeout-sec*        = 10
  *enable-semantics*   = NIL

limit-over number of contradictions exceeds

end-time: 2023-02-14T10:19:29.140190+09:00

  ### SUMMARY ###
  time consumed = 0.035740 secs
  #clauses = 481
  #contras = 31
  #valids = 0
  #trials = 2007
  #max proof steps = 20
NIL
RUBBISH(5): (lscova)

((C35 C46 C53 C69 C94 C111 C121 C128 C148 C155 C168 C196 C203 C226 C245 C255
  C262 C288 C299 C306 C322 C329 C345 C373 C384 C391 C404 C427 C434 C462 C481)
 NIL)
RUBBISH(6): (pm c35)
[C35]
  depth                 = 7
  num of clauses        = 12  see (cids-of-proof cid)
  num of input clauses  = 6  see (inclauses-of-proof cid)
  num of input literals = 9  see (inliterals-of-proof cid)
  num of preds          = 2  see (preds-of-proof cid)
NIL

2023/02/13月
proof metrixを作った
 proofのメトリックス(になりそうなもの)を計算する関数と表示する関数(pmetrics)

 literals-of-cidは意味がなさそうなのでやめた。inliterals-of-cidで十分では??


2023/01/21土
summaryのmax steps of proof数が0だ
証明のdepthを数えていない。
各resolventを作った時にそのdepthを計算し、propertyにいれておくのでどうか。
resolventのdepthは親のdepthのmaxにする

それでよいか?
とりあえずなくても困らないのでこのまますこし考える?

summaryの中で(lscova)から[]のcidをもとめて、そのdepth-cidのmaxを表示した
一回だけなので性能は問題ない



2023/01/20金
p2codeとpcodeの関係を考えた
p2codeのほうが正確。pcodeは高速なのか? ややあいまいなきがする。

2023/01/18水
・p2codeを作成した
　これは、resolveされたLIDペアのリストを(list-mgu cid)からとってきたもの。
  pcodeの曖昧さは、p2codeならないだろうという考えで、どれくらい違うかみてみたい。

  よく必要になるuniqをrubbish-essential.lispに追加。


・p2top は p2codeからpcodeを作る関数。追加
例)

(p2top '((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L9-1)
   (L3-2 L5-1)))

(L9-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L10-1 L1-1)

see 20230118-aboutp2code.txt


2023/01/17火
スクリプトからrubbish を使う別の方法。recip参照

1. script2.shを次のように作る
---
#!/bin/zsh

./test-path --script testdir/test-run.lisp 10 "kqc/path/graph201.kqc" '(quote (c1)))'
---

2. test-run.lispを次のように作る
---
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail '(c1))

(print-analyze (analyze-pcode))
---
これは、rubbish-statistics.lisp/test-graphとほぼ同じだが、(require :gtrail)も
ここに書いているので、core ファイル(test-path) のようなものはいらない。
ただし、実行時間はよけいかかるだろうけど。
それはcoreを起動するようにすればいいだけなので、 ここの問題ではない。

3. 実行
 ./testdir/script2.sh

*** string -> s-expはどうするか?
"(C1)" -> '(c1) にする方法?

 (read (make-string-input-stream "(c1 c2)"))
 => (c1 c2)

複数のs-expの場合は、

 (let ((s (make-string-input-stream "(c1 c2)"))) 
    (list (read s)(read s))
 )
みたいな

test-run.lispを次のようにすればgoalも指定できた


--- test-run.sh
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail (read (make-string-input-stream (nth 3 SB-EXT:*POSIX-ARGV*))))
(print-analyze (analyze-pcode))
---

--- script2.sh
./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph201.kqc" (quote (c1)))' --eva
#!/bin/zsh

./test-path --script testdir/test-run.lisp 20 "kqc/path/graph201.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph202.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph203.kqc" '(c1)'
---




2023/01/16月
・sbclのaliaasをlispに変えた
sbclを生で呼びたいこともあるだろう

rlwrap sbcl
を使うことをおすすめする > 自分

メモリふやさなくてもgraph201.kqcくらいは動く
・
-----
shin@Chapterhouse rubbish % sbcl --script test-pathfinder001.lisp
Unhandled SB-INT:EXTENSION-FAILURE in thread #<SB-THREAD:THREAD "main thread" RUNNING
                                                {70051701A3}>:
  Don't know how to REQUIRE GTRAIL.
See also:
  The SBCL Manual, Variable *MODULE-PROVIDER-FUNCTIONS*
  The SBCL Manual, Function REQUIRE
...

lispファイルはだめか。
coreファイルを作って(require :gtrail)まではやっておくか
test-graphの定義はrubbish-statistics.lispに追加した
　最初は、sbclの起動時の--evalで定義するのを考えたが、タイプが多すぎる。
test-graphをrubbish-package.lispでパッケージのexternにいれた。


★ステップ1　コアつくる :gtrailロードしたもの
shin@Chapterhouse rubbish % rlwrap sbcl
This is SBCL 2.1.9, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
CL-USER(1): (require :gtrail)
To load "local-time":
  Load 1 ASDF system:
    local-time
; Loading "local-time"

NIL

CL-USER(2):  (sb-ext:save-lisp-and-die "test-path" :executable t)
[undoing binding stack and other enclosing state... done]
[performing final GC... done]
[saving current Lisp image into test-path:
writing 1728 bytes from the read-only space at 0x300000000
writing 1840 bytes from the static space at 0x300200000
writing 0 bytes from the immobile space at 0x300300000
writing 42532864 bytes from the dynamic space at 0x7003000000
done]

** sb-extの指定は不要


★ステップ2 実行
  rlwrap ./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph001.kqc" (quote (c1)))' --eval '(sb-ext:exit)'

この実行のあと、REPLに残りたいときは、--eval '(sb-ext:exit)'を指定しない。
たとえば 
(print-analyze(analyze-pcode0))
をしたいとき
----
(in-package :rubbish)
(defun test-graph (mc kqcfile goal)
  (defparameter *enable-semantics* nil)
  (defparameter *max-contradictions* mc)
  (readkqc kqcfile)
  (prover-gtrail goal)
  (print-analyze (analyze-pcode))
)
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
------
test-gtaphの定義をどこかにうつして、スクリプトは
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
だけ書くようにする

テストのしかた

./testdir/script.shを作り
実行
./testdir/script.sh >xxx.txt
xxx.txtに結果出力される
(scriptコマンドを使うとへんなコード(^Mとか^[)がでたり、出力されなかったりした)


2023/01/15日
グラフの例を追加。
00?は直線
10?は複数パスの例
20?はループのある例
　201はa->b->a
　202はもうすこし長い
　203は複数パスのあるループ

(analyze-pcode)
(print-analyze)
などを作った

すこし様子をみた


2023/01/11水
グラフのパスをみつける例を作った greph101.kqc, graph102.kqc

そして
(lnumof Lid) ln-mからn
(cnumof cid) cn から n
を作ったが、なんのために作ったのか忘れた・・・

思い出したpcodeでLidのリストをソートするとき、今は文字列でやっているので
(pcode ...) の結果が
(L2-2 L2-1 L10-1 L1-1)
みたいになる。これを数字の順にしたかった

今はname<という関数を作っていて、これは文字列比較している。

関連して、string<とかstring>とか使っているsortを全部(name< (lnumof llid) (lnumof rlid))を
使うようにかえた。

残り
　もしかしたら L2-1とL2-2のsortでL2-2 L2-1にしたいかもしれない。

