2023/05/07日
rubbish-prover-gtrail.lispで
pure-prover-gtrailはprover-gtrailの一部であり、check-mujun用に抜き出したもの。
停止用チェックのメッセージなどをはずしている。

これ、ひとつにならないだろうかと思う。

check-mujunをrubbish-mujun.lispに分離
pure-prover-gtrailは、prover-gtrailと似ていることがわかるように、
　　いつか、ひとつにできるかもしれないので、もとのままにした。
　実際はcheck-mujunのためだけにあるので、こっちにいれたほうがよいかも。

1) mujun-setは、Σのclause cに対する矛盾集合(複数)をみつける関数。
　


・追加
(isinputcid cid)
(isunitclauses cid) => (isunitcid cid)


***　これで、矛盾集合からキーとするcidを選ぶ用意はできた。
　どう判定するかは難しい


2023/05/06土
運動の例で、動的fact列の処理を考えようとしている

mutat システムを作った
(require :gtrail)
(require :mutat)
(in-package :rubbish)
で使える。
20230312-conflict-disolver-lisp.txt
で例をやってみている

>>
aの存在しない状態を記述してから
factでaの位置を与える
矛盾したらも古いfactを消去する
<<
という手順

2023/04/25火
　新しいfactにより矛盾するΣと矛盾解消の例を考えたい


2023/04/08土
・4/2にΣの無矛盾性を判定する方法を考えた。これに続くこととして
　1) Σの部分矛盾集合のぎりぎりおおきいものの検出
　　そういう集合が存在するのかどうか?
　　複数ある場合について
　2)　Σから無矛盾部分集合を取り出すことはできるのか
　　これは操作の目的がうまく定義できないような気がする。

・証明器の正当性の定義と証明

2023/04/02日
・Σの無矛盾性チェックの実装
　rubbish-prover-gtrail.lisp
    (is-consistent *clist*)
    (pure-prover-gtrtail goals)

  ∀a ∈ Σについて　Σ, a ⊢□ を確認する。この証明があれば、Σ⊢〜aが証明されるということなので矛盾する。
　Σ, 〜a ⊢□ は常になりたつので確認不要。

2023/03/05日
・Σの拡張についてすこし検討した

2023/03/04土
・samplerunからadja、radja の行をコメンアアウト。使っていないので


2023/02/27月
・doc追加。tautologyとvalidの違いを書こうと思ったら、矛盾するΣとか
gを真にしてしまうΣとか


2023/02/26日
・digraphでpngを作る手順を作った
 digraphを作る部分 rubbish-digraph.lispにした
　最初に(require :gtrail)をするとコンパイラーでoffsetがどーのこーのいうエラーになった
　(load "rubbish-digraph.lisp")を一回やったらエラーがでなくなった。


2023/02/25土
・quicklispのgraphと名前にあるライブラリをさがしてみた
(ql:system-apropos 'graph)
いろいろあった
cl-graphは使い方がわからないし、maintainerがもうやっていないらしい
cl-digraphがどきゅめんとも書かれていて使えそう。
cl-digraphのグラフ表示は(ql:quickload 'cl-digraph.dot)
　pngが作れた。
(digraph.dot:draw *d* :filename "digraph.png" :format :png)
Graphvizのcl-dotを使ってcl-digraph.dotでグラフがかける



2023/02/24金
・自動ではいる改行を抑制したい
(setq  *print-right-margin* 200)
　~/.sbclrcに追加した

・show-parameter0, show-parameterで*kqc-file*を表示するようにした。
　他のパラメタと同じ扱いのほうがよいと思う。

・tkplotで、
　- layoutをeingold-Tilfordにするとツリー表示になる。逆さまなので
　　rotateをする。
　- epsを出力する
　　GIMPで変換する
　　1) 「名前をつけてエクスポート」
　　2) 出力形式はメニューから選べるので
　　　 pdfやpngにする。jpegはサイズがでかくなる

・p2codeに番号をつけたが、
　木の末端になるのは
　　1) contradiction(body がnil)
　　2) contradictionではないものは、proveの途中のものが残るような気がするが
　　　　[]と同じp2codeになるのはなぜだろうか?
　　　　literalが残っているが、input 射影で[]と同じになるもの。
　　　その意味は?

・作ったpdf, pngなどをgithubに追加したが、動かすたびに新規で置き換わるので、
  git statusでは、毎回untrackedになってしまう。よくないか
　次のcommitでgithubリポジトリから消えてしまうのでは?

2023/02/23木
・p2codeの木をRで描く
　sbclで隣接行列のlistをつくり
　そのままだと向きが逆なので転置
　adjmの転置なのがmjdaという名前にして
　mjda.r に出力する
・Rでは
  source(mjda-to-graph.R)
　とするとtkplot()でグラフ表示をし、手で操作できる。
　(コメントしているが、xquart()で plot(gr)してもよい)
　このとき、labelの値を隣接行列のnからn-1にしている
  0はinputで、そのあとのindexがnodeのindexより1大きいから

・Rのtkplotなどはpdfにexportできるので、その画像をdocsにいれてある


2023/02/22水
・Rでグラフを描く。
 sbclで隣接行列を出力する
　1. rubbish-analyze.lisp
　　　にグラフ関係をまとめた。他にもいれたい
　2. (defparameter adjm (conv-to-adjacent mapn))でbitmap行列に変換した
　3. (writeadj "adj.r" adjm) でファイルに出力。Rの形式

　R側ではこのadj.rを読み込むとadという変数に値が設定されるので
　matrix(ad, col=length(ad), row=length(ad))
　でmatrixが作れる


2023/02/21火
・隣接情報を取り出した。edgeの定義だけ取り出した

・どうやってグラフを描くか
　1) juliaでGraphs, GraphPlot
　2) Rで、library(igraph)のサンプルがあった

juliaもRもtkl/tkがないという
juliaはIJuliaのnotebookで表示できた。
RはMacの場合Quartzをインストール(CRANにリンクがあった)したらよかった
quartz()を起動すると別ウインドウで表示できるみたい。


2023/02/20月
・p2codeの1pairごとの拡張関係
　(make-nnmap sccp2)でclassify-cid-by-p2codeの結果を使って木を作る

(p2c-n p2c sccp2n) p2codeから番号
(n-p2c n sccp2n)   番号からp2code

==== funcions usage
(require :gtrail)
(in-package :rubbish)
(readkqc "kqc/path/graph201.kqc")
 (pg (c1))

;; ccp2は同じp2codeをもつcidのリストつきのリスト
(defparameter ccp2 (classify-cid-by-p2code))

;sccp2はccp2のfirstの長さでソートしたもの。secondはcidのリスト
(defparameter sccp2 (sort-ccp2 ccp2))

;sp2は長さ順のp2codeのlist
(defparameter sp2 (loop for x in sccp2 collect (first x)))

;sccp2に番号をわりふる。cidのリストがついている
(defparameter sccp2n (numbering-sccp2 sccp2))

;sp2nは、p2codeに番号を割り振る。p2codeのみのリスト。
(defparameter sp2n (numbering-sccp2 sp2))

; amapはsccp2のp2codeのお隣り(arrow)map (p2code (p2c1 p2c2 ...))*
(defparameter amap (make-nnmap sccp2))

; amapのp2codeを番号に置き換えたもの
(defparameter mapn (map-in-number amap sccp2n))

========


2023/02/19日
・p2codeの次のspccp2 の要素をもとめる
  (find-next-p2codes p2c allp2c)

・s2codeに番号を割り振る
　(numbering-sccp2 sccp2)
  (find-p2code p2c scpp2n)



2023/02/18土
・p2codeの包含関係と長さ+1で、となりのclauseをp2codeベースで定義してみた。
・head部分が同じならp2codeを含むという見方で(p2-adjmap p2cs)を考えた
  (cnext p2 allp2code) でp2の隣のp2codeを取り出す。
　p2codeがそういうふうにソートされているわけではないので、このアプローチはNG
・(p2c-containp p2 allp2)はp2の全pairを含むp2code in allp2を選ぶようにする。
　これにp2の長さ+1の条件を加えて、となりのp2codeを決めた
　　(wnext p2 allp2code)と(p2-wadjmap allp2cs)を定義した。
　　これでよさそうだが、数が増えるので、使い方を考えなくては。

・(p2toc p2code) => このp2codeをもつcid
を作った。なかったっけ??(p2top p2code) => pcode。これを思い出しているだけ

・ソートしたり手がはいっているので、それを除去することを考える


2023/02/14火
1) propが描けるか確認した(昔、書けるように作った気がする)

 kqc/prop/prop001.kqc
(1 () (+ P))
(2 () (+ P)(- Q))
(3 () (- P)(+ Q)(- R))
(4 () (- Q))
(5 () (+ R))

のようにかけた。引数のない述語に見えるが+/-が分離しているのでこれが命題だ。


2) 複数の証明環境を持てるようにする方法を考えた
　docs/20230214-metaverse.txt

3) orphanがあったときどうなるかを確認した
　orphanをのぞいて[]になればOKな気がする
　docs/20230214-orphan.txt

4) prover-gtrailが終わったあと、継続することについて考えた
　docs/20230214-resume.txt
  (prover-gtrail *goallist*)
　でできる。
　*goallist*を好きなように作れば、好きなように続けられる。続けるというのは違うかもしれないが

5) macroを作った。pg=prover-gtrail, pm=pmetrics. 
'(c1)みたいに'をつけるのが面倒なだけ

例
RUBBISH(4): (pg (c1))

start-time: 2023-02-14T10:19:29.116715+09:00

  ### PARAMETERS ###
  goals                = (C1)
  *max-clauses*        = 1000
  *max-contradictions* = 30
  *max-trials*         = 100
  *max-steps*          = 100
  *timeout-sec*        = 10
  *enable-semantics*   = NIL

limit-over number of contradictions exceeds

end-time: 2023-02-14T10:19:29.140190+09:00

  ### SUMMARY ###
  time consumed = 0.035740 secs
  #clauses = 481
  #contras = 31
  #valids = 0
  #trials = 2007
  #max proof steps = 20
NIL
RUBBISH(5): (lscova)

((C35 C46 C53 C69 C94 C111 C121 C128 C148 C155 C168 C196 C203 C226 C245 C255
  C262 C288 C299 C306 C322 C329 C345 C373 C384 C391 C404 C427 C434 C462 C481)
 NIL)
RUBBISH(6): (pm c35)
[C35]
  depth                 = 7
  num of clauses        = 12  see (cids-of-proof cid)
  num of input clauses  = 6  see (inclauses-of-proof cid)
  num of input literals = 9  see (inliterals-of-proof cid)
  num of preds          = 2  see (preds-of-proof cid)
NIL

2023/02/13月
proof metrixを作った
 proofのメトリックス(になりそうなもの)を計算する関数と表示する関数(pmetrics)

 literals-of-cidは意味がなさそうなのでやめた。inliterals-of-cidで十分では??


2023/01/21土
summaryのmax steps of proof数が0だ
証明のdepthを数えていない。
各resolventを作った時にそのdepthを計算し、propertyにいれておくのでどうか。
resolventのdepthは親のdepthのmaxにする

それでよいか?
とりあえずなくても困らないのでこのまますこし考える?

summaryの中で(lscova)から[]のcidをもとめて、そのdepth-cidのmaxを表示した
一回だけなので性能は問題ない



2023/01/20金
p2codeとpcodeの関係を考えた
p2codeのほうが正確。pcodeは高速なのか? ややあいまいなきがする。

2023/01/18水
・p2codeを作成した
　これは、resolveされたLIDペアのリストを(list-mgu cid)からとってきたもの。
  pcodeの曖昧さは、p2codeならないだろうという考えで、どれくらい違うかみてみたい。

  よく必要になるuniqをrubbish-essential.lispに追加。


・p2top は p2codeからpcodeを作る関数。追加
例)

(p2top '((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L9-1)
   (L3-2 L5-1)))

(L9-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L10-1 L1-1)

see 20230118-aboutp2code.txt


2023/01/17火
スクリプトからrubbish を使う別の方法。recip参照

1. script2.shを次のように作る
---
#!/bin/zsh

./test-path --script testdir/test-run.lisp 10 "kqc/path/graph201.kqc" '(quote (c1)))'
---

2. test-run.lispを次のように作る
---
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail '(c1))

(print-analyze (analyze-pcode))
---
これは、rubbish-statistics.lisp/test-graphとほぼ同じだが、(require :gtrail)も
ここに書いているので、core ファイル(test-path) のようなものはいらない。
ただし、実行時間はよけいかかるだろうけど。
それはcoreを起動するようにすればいいだけなので、 ここの問題ではない。

3. 実行
 ./testdir/script2.sh

*** string -> s-expはどうするか?
"(C1)" -> '(c1) にする方法?

 (read (make-string-input-stream "(c1 c2)"))
 => (c1 c2)

複数のs-expの場合は、

 (let ((s (make-string-input-stream "(c1 c2)"))) 
    (list (read s)(read s))
 )
みたいな

test-run.lispを次のようにすればgoalも指定できた


--- test-run.sh
(require :gtrail)
(in-package :rubbish)
(defparameter *enable-semantics* nil)
(defparameter *max-contradictions* (parse-integer (nth 1 SB-EXT:*POSIX-ARGV*)))
(readkqc (nth 2 SB-EXT:*POSIX-ARGV*))
(prover-gtrail (read (make-string-input-stream (nth 3 SB-EXT:*POSIX-ARGV*))))
(print-analyze (analyze-pcode))
---

--- script2.sh
./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph201.kqc" (quote (c1)))' --eva
#!/bin/zsh

./test-path --script testdir/test-run.lisp 20 "kqc/path/graph201.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph202.kqc" '(c1)'
./test-path --script testdir/test-run.lisp 20 "kqc/path/graph203.kqc" '(c1)'
---




2023/01/16月
・sbclのaliaasをlispに変えた
sbclを生で呼びたいこともあるだろう

rlwrap sbcl
を使うことをおすすめする > 自分

メモリふやさなくてもgraph201.kqcくらいは動く
・
-----
shin@Chapterhouse rubbish % sbcl --script test-pathfinder001.lisp
Unhandled SB-INT:EXTENSION-FAILURE in thread #<SB-THREAD:THREAD "main thread" RUNNING
                                                {70051701A3}>:
  Don't know how to REQUIRE GTRAIL.
See also:
  The SBCL Manual, Variable *MODULE-PROVIDER-FUNCTIONS*
  The SBCL Manual, Function REQUIRE
...

lispファイルはだめか。
coreファイルを作って(require :gtrail)まではやっておくか
test-graphの定義はrubbish-statistics.lispに追加した
　最初は、sbclの起動時の--evalで定義するのを考えたが、タイプが多すぎる。
test-graphをrubbish-package.lispでパッケージのexternにいれた。


★ステップ1　コアつくる :gtrailロードしたもの
shin@Chapterhouse rubbish % rlwrap sbcl
This is SBCL 2.1.9, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
CL-USER(1): (require :gtrail)
To load "local-time":
  Load 1 ASDF system:
    local-time
; Loading "local-time"

NIL

CL-USER(2):  (sb-ext:save-lisp-and-die "test-path" :executable t)
[undoing binding stack and other enclosing state... done]
[performing final GC... done]
[saving current Lisp image into test-path:
writing 1728 bytes from the read-only space at 0x300000000
writing 1840 bytes from the static space at 0x300200000
writing 0 bytes from the immobile space at 0x300300000
writing 42532864 bytes from the dynamic space at 0x7003000000
done]

** sb-extの指定は不要


★ステップ2 実行
  rlwrap ./test-path --eval '(in-package :rubbish)' --eval '(test-graph 10 "kqc/path/graph001.kqc" (quote (c1)))' --eval '(sb-ext:exit)'

この実行のあと、REPLに残りたいときは、--eval '(sb-ext:exit)'を指定しない。
たとえば 
(print-analyze(analyze-pcode0))
をしたいとき
----
(in-package :rubbish)
(defun test-graph (mc kqcfile goal)
  (defparameter *enable-semantics* nil)
  (defparameter *max-contradictions* mc)
  (readkqc kqcfile)
  (prover-gtrail goal)
  (print-analyze (analyze-pcode))
)
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
------
test-gtaphの定義をどこかにうつして、スクリプトは
(test-graph 50 "kqc/path/graph201.kqc" '(c1))
だけ書くようにする

テストのしかた

./testdir/script.shを作り
実行
./testdir/script.sh >xxx.txt
xxx.txtに結果出力される
(scriptコマンドを使うとへんなコード(^Mとか^[)がでたり、出力されなかったりした)


2023/01/15日
グラフの例を追加。
00?は直線
10?は複数パスの例
20?はループのある例
　201はa->b->a
　202はもうすこし長い
　203は複数パスのあるループ

(analyze-pcode)
(print-analyze)
などを作った

すこし様子をみた


2023/01/11水
グラフのパスをみつける例を作った greph101.kqc, graph102.kqc

そして
(lnumof Lid) ln-mからn
(cnumof cid) cn から n
を作ったが、なんのために作ったのか忘れた・・・

思い出したpcodeでLidのリストをソートするとき、今は文字列でやっているので
(pcode ...) の結果が
(L2-2 L2-1 L10-1 L1-1)
みたいになる。これを数字の順にしたかった

今はname<という関数を作っていて、これは文字列比較している。

関連して、string<とかstring>とか使っているsortを全部(name< (lnumof llid) (lnumof rlid))を
使うようにかえた。

残り
　もしかしたら L2-1とL2-2のsortでL2-2 L2-1にしたいかもしれない。

