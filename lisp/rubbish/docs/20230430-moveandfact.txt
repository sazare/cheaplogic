20230430-moveandfact


[移動するボールをセンサーで観測した場合]

[運動a]
 0                    100
 |--------------------|
1 a
2   a
3       a
4       a

P(x, a) : 位置xに物体aが存在する
だとすると

[運動a]はこう書かれる
(A)
0 -P(x,a)∀x   どこにもaはない
1 +P(1,a)　　　1にaがある
2 +P(3,a)　　　3にaがある
3 +P(7,a)　　　7にaがある
4 +P(7,a)　　　7にaがある


実際には消えたaも書かなくてはならないので
(B)
0 -P(x,a)∀x
1 +P(1,a)
2 +P(3,a)∧-P(1,a)
3 +P(7,a)∧-P(3,a)
4 +P(7,a)

これは時間を考慮していない。一番左端の数字を時間だと考えると
Pを拡張して P(t,p,a) と書くようにすればよいのか?
tは時刻、pは位置、aは物体

(C)
0 -P(0,x,a)∀x
1 +P(1,1,a)
2 +P(2,3,a)∧-P(1,1,a)
3 +P(3,7,a)∧-P(2,3,a)
4 +P(4,7,a)

かあるいは
(D)
0 -P(0,x,a)∀x
1 +P(1,1,a)
2 +P(2,3,a)∧-P(2,1,a)
3 +P(3,7,a)∧-P(3,3,a)
4 +P(4,7,a)

さて、どちらか

センサーは時間がわからず、いつも「今」についての事実を作っていると考えると
CやDのように時刻をもつということは、ロジック側が時刻を認識しているということ
に見える。そのときの時刻は、ログのタイムスタンプのようなもの。

Cは過去についてaがなくなったということを言っていて
Dでは1つのclauseでは1つの時刻しかないから、今についてしかいっていないのと同じなのでBと同じに見える。

AやBの(0)はすべての時刻とすべての位置について言っているので、
+P(t,p,a)がfactになったとき単に矛盾する。だから(0)はおかしい。
だから(0)を除外したものをA', B'とする。

B'の場合、各時刻でのΣの変化を次のようにすればよいだろう

fact+P(1,a)がΣに追加されて

Σ1 ={+P(1,a)}

とする。
これに、時刻2のfact

2 +P(3,a), -P(1,a)

を適用して

Σ2={+P(3,a)}

とする。Σ1の+P(1,a)とfact2の-P(1,a)が対消滅してこうなる。

対消滅は正しい操作だろうか。

Σ全体が矛盾で崩壊するのではなく、factと矛盾する知識だけが消える。

ここでは、知識はground instanceであり、証明プロセスを経てでてくるresolventではない。(*1)
過去のfactと今のfactの衝突。

(*1) これはπ(Σ, -P(1,a))のmguがεである結果かもしれない。
もしもπ(Σ, -P(1,a))が複数のclauseからなる「証明」の場合、ε≠σかどうかで判断されるのか?

ε≠σは「命題算だ」と言っている。
これが矛盾を解消する条件とは思えない。

* Σ ⊢ 〜g ≡ Σ, g ⊢ □
という証明があったとき、Σの何をけせば(gはfactなので除去する優先度は低い)よいのか

たぶん
　π(Σ, g) : Σとgを仮定して□を導出する証明のp2code
　　このp2codeは、Σ⊢〜gの証明の構造になっている。

すべてのπの集合を
　Π(Σ, g)
と書くことにする。
Π(Σ,g)は本質的に異なる証明。ループも除去されている。(p2codeはinput lidで書かれるから)
このΠの構造を見てたとえば
　∧(Π(Σ,g))
があれば、それを除去すればよさそうな気もする。
根本的に異なる〜gの証明があるのなら、複数除去が必要になるのかも。
根本的に異なる〜gの証明というのは
▶︎〜g と▷〜gで、〜g以外のclauseが共通でないとか
証明のmguが違うとか・・・

・証明のmgu
　μ(▽)
とは、▽の任意の証明δについて
　g・δ ≦ g・μ(▽)
となるようなmguかな?
よくわからないのは、証明のmguが何か明白ではないからか
　
gの変数をかえてしまうと、証明に出てくるmguはかわってしまう。
gの変数というものは変えても意味は変わらないのだから、それはまずい。


・rubbishでは
e1とe2に変数が共通しないDVCを満たすようにしていて

<λv1.e1:λv2.e2> を λV<e1:e2>と書いてもよいとする
そのとき

σ=<e1:e2>

とすると

σは{V←T}
という形に書ける。大文字はtermの並び。
Vの順番は、par代入だと意味がないが、表現としてはソートして一意になるようになっているとする。

証明▷Pについては、DVCのもとで、どのresolutionにも同じ変数がおきないとするためには
必ずrenameが発生しているということになる。

σ=<L1:〜L2>
でresolventは、renameをρとして
R=(C1+C2)-{L1,L2})σ'・ρ
と書ける。ρの右変数はすべて新しい記号。

▷Pの証明は、σとρを集めたものになる。

▷P以前の部分の代入はPの形の中に項/変数として残るが、その変数に対して証明の残りで何かが代入されても遡って適用する必要がない。
　それは、証明というものが上から下へ積み重なっているから。
　もしも証明全体して、無駄のない形にしたいのであれば、遡ってmguを適用する必要があるだろう。
　しかし、未適用の上部分の証明は、そこまでで正しい推論をしているので、その下部分でよりinstance化されるもの以外にも利用できるようになっている。

　矛盾の証明Π= ▷□ を考えたとき、この証明の最も最適化された証明Π'が存在して、そこでは、instance化が必要ないものにできるだろう。
証明のmgu、μが求められたとして、
「最適化された」というのは、その□の証明で、たとえば、最初のclauseにμを適用してインスタンス化すると、証明▽は命題レベルで証明できるということかな。途中のresolutionで必要なmguはrename以外はすべてεになる。
そのときrenameは必要か??

必要なclauseses=証明▽に登場するclauses(重複あり)

にμを適用してCi'を作ってから、証明▽の作り方(レシピ)に従って証明をつくっていくと
resolutionのmguはすべてεになり、renameは不要。という感じかな?

証明▽ができてから、μを適用しようと思うと大変かも。

gの変数リストVか、全Ci'の変数のリストV'を使い
証明の全ステップで得られるσをこのV'に適用していくと、□の証明が完成したとき最後に得られるV'*σとV'から、
<'V':V'*σ>はσかな。
この方法でもできそう。(Sha)

****
証明は、操作の順序があり、それに依存して最小の情報を個別に作らない。
unificationアルゴリズムもそうで、部分的な代入操作の順序に最適化を委ねている

それを個別に取り出すのは、動的なものから断片を切り出すようなもので、結構難しいという気がする。

表現上の操作で、最適なものをみつけるのはややこしいという話。

unificationについては、20230503-unification に書く。

証明については、
　▷Aは、▷部分はAを証明する一番ゆるい証明になっている。
　Aを使ってBの証明を作った場合、▷A▷Bで、Bの証明にはAの一部分(インスタンス)の情報しか使わないかもしれない。
　その差を埋めて、証明中のmgu全体が必要最小限の代入にしようと思うので、▷Bのmguを▷Aに適用したくなる。
　ということを上で書いていた。

　それが必要なのかどうか?
　　必要ないのは、証明はBが出る途中にゆるくても関係なくて、Bが出さえすればよいから。

　　これは、操作を適用されるものが、そういう時差を調整してくれるから。

　　これが「操作」というものではないのだろうか。

　　一つの証明▷□から、mguの絞り込みによって必要最低限の証明、つまり命題論理の証明を作る。
　　これはできるかもしれない。

　　一つの□に対して一つの証明であれば、命題証明でよい。mguを操作とし、操作表現を残せばよい。
　
　　操作表現は、その証明▷Aの部分について操作表現を与えるとすると、ゆるい方のmguでいいのではないか。
　　実行が進めば、しぼりこまれていくので。

　　




----
おまけ
resolutionで消えるL1,L2の変数は
L1,L2以外の変数はRに残るが、□の変数が()であることを考えると

変数は次の三種類ある
　1) L1,L2のみに登場しRには登場しない
　2) L1,L2に登場せず、Rにしか登場しない
　3) L1,L2とRの両方に登場する

1)の変数はRの変数には登場しない
2)の変数は<L1:L2>=σのmguではε={x/x}になる
3)の変数は、証明の後段でRに対して発生するσ'がこの段の証明のσに関係する。
　関係するためには、<L1:L2>={V←T}のTの部分にこの変数が出現しなくてはならない。
　? resolutionの証明では、消えた変数に代入が発生することはない。
　　Rに登場するtにある変数が、処理の終わったσのtの変数と同じであることはある。
　renameを行った段階で、resolveされ代入σとして処理された変数/項が残りの証明に関係することはない。
　σは代入適用されると解消される。Tの部分の変数がRとのつながりを持ち続ける。
　しかし、
　のこりのRに対して












★aに幅があったら
もしもaが幅2だったとしたらどう書くだろうか?
1. +P(1,a), +P(2,a)
と書いたとして、aが1だけ移動すると
2. -P(1,a), +P(2,a), +P(3,a)
というfactsになりそう。
これが
2'. -P(1,a), -P(2,a), +P(2,a), +P(3,a)
というfactになるとfact自体が矛盾してしまいまずい

aの左とaの右にわけると

1. +P(1,al), +P(2,ar)
2. -P(1,al), -P(2,ar), +P(2,al), +P(3,ar)

となる。これはいけそう。
だが、alとarでひとつのaであることをどこかで書かなくてはなるまい。
それは別の課題だろう。







