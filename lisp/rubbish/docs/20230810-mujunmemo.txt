20230810-mujunmemo

(mujun-prover-inside-n 1 "kqc/mujun/mj102.kqc")

;kqcの1番目のcidで矛盾が起きるかをチェックする

これまで気にしていたΣ、φが矛盾したとき、置き換えられるのはφか¬φかという点は
ここでは新しいfactφを残すことにする。

センサーを信頼するということだ。


運動の問題であったように
+P(10)から+P(11)に変化したとき、元の
+P(10)は-P(10)にしなくてはならない。という件

何もない空間は-P(x)だった。
そこに+P(1)が登場すると
{+P(1), -P(x)ifx≠1}となる。

次に2へ移動すると
{+P(2), -P(x)ifx≠2}
にかわる。
あるいは
{-P(1),-P(2),-P(3),-P(4)}から
+P(1) => {+P(1),-P(2),-P(3),-P(4)}
+P(2) => {-P(1),+P(2),-P(3),-P(4)}
と変わっていく方法?
Pの運動の制約条件として
λx {+P(x), -P(y)ifx≠y}
を置くというのもあるかもしれない。

この場合
a) +P(1) => {+P(1), -P(y)if 1≠y}
b) +P(2) => {+P(2), -P(y)if 2≠y}
となっていく。

b)の場合に対して

?P(4)という質問については、反証により
+P(4) => □if 2≠4だから、□になり4ではないことがわかる。
-P(4) => noop

また、?P(2)については
+P(2) => if 2≠2でsemanticにtrueなので無視
-P(2) => □だから、+P(2)が証明されて今は2であることがわかる。

このように変数を用いて表現する方法だと、変数を含む式の変形が必要になる。
つまり
+P(2)が新しいfactとなったとき
λx{+P(x), -P(y)∨x=y}
に対してx<-2を適用して
{+P(2), -P(y)∨y=2}
を生成するようなこと。
これで、Σの中のどのclauseを置き換えるのかはどうわかるか??

一方で
RDBのようにすべてのinstance +/-P(?)を列挙すると
出現については、-P(4)とfact +P(4)が□して+が残る。

移動したときは、たとえばfact+P(6)なら-P(6)を置き換えるのはよいが
+P(4)を-P(4)に戻すことが書けない。

以上から
λx{+P(x), -P(y)∨x=y}はP(?)の?がuniqueである場合には適切。



