pcodeの有効性と計算

1. すべてのresolventのliteralはinput のliteralのインスタンス
2. proofのp2codeは、resolveされたpairの集合
3. ループの場合、同じresolveは1つになる。集合なので

ふたつのclause C1, C2についてR=L1,L2 in C1,C2なら
p2codeは{(L1' L2')} ∪ pcode(C1) ∪ pcode(C2)になる
すでにこのpcodeがある場合でも、普通はresolutionを行う必要がある

もしもΣの含む情報を手続で表現することを考えると、手続きはこのようなループを投射してひとつのコードにするものなので、pcodeに対応する手続片の合成になるはず。

pcodeのpairに対応するmguがそのコードに対応するが
同じpairのmguは親のmguのインスタンスになる

計算コードとは何か? それはmguだろう。

命題レベルの証明と、mguそれぞれの役割はなにか?

input L/Cに射影した証明の構造がp(2)code





===============
証明と計算

人間があることがらについて知識を得るということは
関係的な認識をして、それを手続的なものにかえていくと思う。
なぜなら、関係的な理解だとある目的を達成するには時間がかかるから。
特定の目的については手続にして効率よく実行できるようにする。

たとえば、ある場所に行くには、点から点への関係としての移動を積み立てて目的地にたどりつくルールを考える。
一度たどり着くと、その経験をもとに、移動を手続化して、道筋の判定はより効率よく行えるようになる。

というような仕組みではないかと思う。


証明の特徴
・並列性 = すべての組み合わせをやったとする
　非決定性の計算は、証明みたいなものか。
　すべての組み合わせを行うということ。量子計算に近いかも。
・

計算の特徴
・決定性の計算は、迷わない。

===============
人間は、あることがらについて、
1) ルールをみつけようとする。
　(1) 
　(2) 自分の行動を決めたあとで、ルールにあっているかどうか考える
　(3) そのルールにもとづいて自分の行動を決める
　
2) そのルールが妥当だときまったら
　(1) ルールを手続化する

メリット: 手続はいちいち迷わなくてよいので停滞する時間がへらせる

ルールが優先されるみたいな書き方だが、たぶん
 3) 手続を組み合わせて問題を考える
　(1) ある手続が達成することが何かを認識する
　　　これは論理化、述語化
　(2) その達成を組み合わせてよりおおきな目的を達成する
　　　これはプログラミング

だとすればHore方式かDijkstra方式でよいのか?

　述語を明文化するのはむずかしい
　だからのwpか





