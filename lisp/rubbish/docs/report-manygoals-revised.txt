report-manygoals-revised.txt

複数のgoalとは、(P∨Q)の形をしたconjである。

これを否定して、clause化mすると
-(P∨Q) から -P ∧ -Qとなり、二つのclause/goalsとなる。

述語で考えると、goalに∀変数があるということは、こう考えられる。

conjectureはこの形である。
∃x(P(x) ∨ Q(x)) ... (1)

¬(1)をclauseに変形すると

∀xP(x) ∧ ∀xQ(x) ... (2)

となって、∧でつながっているので、∀変数xを含むclause/goalがふたつになる。


+P(x) ... (2.1)
+Q(x) ... (2.2)

∀変数xは、2.1と2.2で独立なものになっている。

一方、(1)にskolem関数(この場合は定数)sを導入すると

P(s) ∨ Q(s) ... (3)

となり、これの否定からできるclauseは

-P(s) ... (3.1)
-Q(s) ... (3.2)

である。この場合、この二つのclauseの引数sは同じ値をとる。

conjectureの意味としては、+P(s)か+Q(s)かのどちらかがTであればよいのでnconjは両方が同時にFであるようなsを求めることになる。

もしも、Axiomとして次のものが与えられていた場合、sはaでなくてはならないが、sが定数なのでそのような解はもとめられない。

+P(a) ... (4.1)
+Q(a) ... (4.2)
+P(b) ... (4.3)

Σから定まる、本当のsの値(定数)は見つけるものなのか、与えるものなのか


????
[skolem関数は何なのか]
この例のように、∃xにskolem関数を導入する場合、関数自体が変数であるようなものを想定していないだろうか。

「何かある関数があって」と考えるとき、その関数にまだ定義が決まっていない関数fを導入する。
このfは変数の扱いであり、具体的な構成方法は示さない。

定数sの場合、Σから証明を作ることでsとしてaが選ばれることを期待していたとすると、このsは定数でなく変数でなくては話があわない。

つまり、ここで導入したsは、何か決まった定数になるものという意味の変数だからである。

このような変数は、clauseに出現する変数と違うもののようだ。

つまり、Σの定義によって決まるはずの定数に仮に名前をつけたsという変数である。

この変数は、Σ全体で1つの解を持つ。複数かもしれないが、Σのどこにでてきても同じ値であるという意味で定数であり、具体的にどの定数なのかは証明によって決まってくるという意味で変数である。

そのようなskolem関数/定数あるいはskolem変数といってもいいが、を処理するには、goalsをtupleで扱わないといけないだろう。

今日までのrubbishは、goalsを独立に[]にしていたので、このような目的にはあわない。





-- issue --
複数goalsは、そのconjectureが∃x(P ∨ Q)のような形をしている。

∃x(P(x) ∨ Q(x))... (1) を否定すると
∀x(-P(x)) ∧ ∀x(Q(x))
となり、nconjは二つのclausesで、それぞれの変数は独立になる。

しかし、(1)でskolem関数/定数を導入すると

+P(s) ∨ +Q(s)の否定になるので
-P(s) ∧ -Q(s)
という2つのclauseになる。変数はないが、二つのclauseでsは同一の値であることが求められる。

conjecture(1)の意味はどちらかが

see report-manygoals-revised.txt





