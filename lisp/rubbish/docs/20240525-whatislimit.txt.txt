20240525-whatislimit.txt

1) Σに+Pしかなければ矛盾しない
2) proverにできること?
　　(1) Σ,g ⊢□ 
　　(2) Σ,g ⊢□♾️
　　(3) Σ, ¬g ⊢ □

　(1)のときは(2)なのかな?

3) Σの無矛盾性を確認する方法を前考えたけど、確実なのはないのか
　Σ,g ⊢ □ではなく、Σ⊢□の確認方法

　(a) ∀c ∈ Σについて、Σ,c⊢□をみつける。∀c∈Σなので、Σ⊢cだから、この□がみつけられれば、Σ⊢¬cとなるのでΣ⊢□がいえる。cへの直接の道と、¬cへの回り道があることを証明するのだろう。cと¬cはresolveされるが、cとcはresolveされない。だから他の道があればこれはいえそう。

* Σ⊢αと実際に証明ができることを区別したいかも。Σ→αで証明構成を示すか。

　(a’)  ∀c ∈ Σについて、Σ-{c} ,¬c⊢□をみつける。のではどうか? これは　Σ⊢cと同じだから意味ないか。

　(b) Σの全述語pについて、+p(x)と-p(x) {xの個数はpの引数の数が決まっているので異なる変数で作る}を考え
　　　Σ, +p(x) ⊢□とΣ,-p(x)⊢□を並行して調べる。
　　　これは、Σ⊢□があるなら、必ずunit clauseどうしでresolveするから、その述語が存在するわけで、その述語の一般形の+p(x)と-p(x) {これらはΣに直接でてきていないかもしれないしでてきているかもしれない}が、矛盾するはず。

　　というのは、おかしいかな。
　　Σ→+p(t)とΣ→-p(s)の証明があったとして、+p(t)と-p(s)で□するかどうかはわからないような・・
　　つまり、t ⊥ sなら矛盾しないか。

記法 t⊥s ⇔ ¬∃<t:s>　

　引数のH^n空間で重ならない二つの部分はunifyできない。そのような部分はresolveの対象外であり矛盾しない。
　∃<t:s>なら矛盾する。


4) DVCを満たすΣのdisagree pairΔ(Σ)をプログラミング言語とみなしたい。Δ.langと仮に呼ぶ。
　特に述語記号をけして、引数のタプルだけで表現しその間の遷移を考える。

　タプルの一部で、値の確定したもの(input)に対して、なんらかの条件で次の遷移先が決まるのではないか。
　違う述語で同じ引数数だったらどうなるのか。述語の区別は不要なのか。

　元のグラフでは述語で区別されている。それにしたがって遷移のグループ分けを行えば、述語の区別は暗黙のうちにおこなわれる。

　そのような計算を行うシステムがあれば、それは証明器のかわりになり、述語のマッチングが必要ないだけ高速な計算ができる(証明より高速ということ)

4’) Δ言語で、述語記号の間の遷移でtermの関数記号の冪乗に注目すると、
　行きも帰りも同じ冪乗なら(fでいってgで戻ってくるような場合、行き帰りで何も情報が増えていないので無駄。
　Herbrand宇宙では、f^nを1の倍数で作っていたが、inputΣの構造によって、でてくる冪乗だけを考えればよいのではないか。★

5) 証明論の教科書は適当にメタ論理で書いているが、そのメタな論理はどのように定義できるのか? もしも述語論理で書くとすると、どのような限界があるのか?

6) 定数変数 in target, observer
　(a x)(+ P a x) (- Const a)(- Var x)

のaとxは対象言語の定数と変数が代入される。
具体的な値はΣに含まれる+Constと+Var
による。

もしも

　(() (+ P a x))

では、aとxは観察言語の定数である。
もしも
　(+ Const a)や(+ Var x)がΣにあってもこのa,xとは関係ない。(??)



   (x y) (+ P x y))

だと、xyは対象言語のものではない何かがはいる。
単にリテラル間での同一性を示しているかもしれない。


もしもaxiomに

(+ Const a)
とあったら、xにはaが代入される。


　


