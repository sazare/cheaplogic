代入操作の実装について(仮)

* 代入操作が可換だと、代入表現の標準表現が定義できる。のか?
　可換でないと、σ≡σ1*σ2 ≠ σ2*σ1となり、要素代入の順番によってことなる代入になってしまう。
　要素それぞれは同じなのに全体として異なるのはいやだと思う。

　代入について考えるとき、表現と機能について考えるわけだが、同じ機能が同じ表現でないと面倒。
　そもそも同じ機能に同じ表現を与えられるのかどうかとかいう問題はあるが、最初から異なる表現で同じ機能になってしまうのはやめい。
　というわけで、表現の正規化(標準化)を考えた場合、代入操作の可換性が頭に浮かぶ。
　可換な代入だったら、unificationのとき、ここのdisagreement setを合成して全体のmguを作るという仮定で、「合成」操作が可換であれば、mguは一意になりそうではないか。
　もちろん、アルゴリズムでは、mguの表現に対してなんらかの文字列としてのsortはするとして。そのようなsortが代入機能に影響を及ぼさないことを保証するための可換性。

　代入と変数の関係。
　表現としては、変数が異なれば、代入機能も異なる。

　代入の同値の定義もややこしい。

　たとえば、二つの代入σとρは、「任意の表現Eについて、E*σ≡E*ρ」であるとき、等しいと考えられそう。

　代入表現、代入操作、代入間操作をこの条件を満たすように定義していくことはできるのか?

　代入σ={t1/v1, t2/v2,...}と集合の形でかけるか
　σの要素をそれぞれσ1, σ2,...と書いたとして
　σ = σ1*σ2*...
　と書けるのか。これが可換であればunificationアルゴリズムの記号的な妥当性が言いやすくなるような気がする。
　
　Chang&Leeだと、disagreement setの発見順によってσの表現がかわる。
　(x,y,z) . <f(g(x), a):f(y, z)> と
　(x,y,z) . <f(a, g(x)):f(z, y)>
　のmguの形が違っていたら気持ち悪くないか?
　何か大切な性質が抜け落ちてしまいそうな気がする。




　論理式では、束縛変数の名前書き換えても同じ式だというのがある。これは代入操作とは別の話。

****
まず、表現はS-式と考える。一階論理学の式や論理式では一番左側の記号を関数記号として特別に扱うが、意味を除外した表現としてはそれはただの定数であり、S-式とみなして単純化したい。

最初は、変数を含まない表現を考える。代入を考えるときに変数を導入するが、定数と変数の区別は

表現には同一性判定が定義できる。

表現e1,e2に対して、e1≡e2かどうかが判定できる。


次に、代入操作に対する表現として代入表現を考える。次のような定義があるだろう。

1 基本代入表現 σ≡{t/v} vは記号、tは式。であり、気持ちとしては表現の中のvをすべてtで置き換える操作と定義するという意図を持っている。

2 代入表現 σ≡{t1/v1, t2/v2, ..., tk/vk}
　これの意味は表現に対して代入表現を適用する代入操作の定義によって決まる。
　{viti}はσの要素代入とでも呼ぶ。特に区別したい場合はσを複合代入と呼ぶ。
　また、これは表現の定義なので、≡を使って書いている。代入表現を集合と考えることもできるが、その場合はσ={t1/v1, t2/v2, ..., tk/vk}と書ける。ただし、表現操作の文脈では集合を直接扱うことはないだろう。また、代入や表現に対して別途同値関係を定義した場合は、=でも≡でもない記号を使う。

以下では、表現をeやeiで、代入をσやσiで表す。

3. 表現に対して代入表現を適用する操作*を考える。
　e' ≡ e*σ
　
　この*にはいろいろな定義がありうる。
　それは、要素代入と複合代入の関係で定義したい。
　代入表現がσとσ'のふたつある場合、あるσがあって
　e*σ≡e*'σ
　とならない場合、その代入操作は異なると考えることもできる。しかし、表現の等値性から代入表現の構造を考えるのは難しいので、複合代入と要素代入の関係で違いを考えたい。
　以下、σ≡{v1/t1, v2/t2, ..., vk/tk}≡{σ1, σ2, ..., σk}であるとする。

3.1  

(途中)
