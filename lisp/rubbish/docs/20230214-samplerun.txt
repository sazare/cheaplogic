20230214-samplerun

see pg, pc, p2c, pm



CL-USER(1): (require :gtrail)
To load "local-time":
  Load 1 ASDF system:
    local-time
; Loading "local-time"

NIL
CL-USER(2): (in-package :rubbish)

#<PACKAGE "RUBBISH">
RUBBISH(3): (readkqc "kqc/path/graph201.kqc")

NIL
RUBBISH(4): (pg (c1))

start-time: 2023-02-14T19:04:20.165311+09:00

  ### PARAMETERS ###
  goals                = (C1)
  *max-clauses*        = 1000
  *max-contradictions* = 30
  *max-trials*         = 100
  *max-steps*          = 100
  *timeout-sec*        = 10
  *enable-semantics*   = NIL

limit-over number of contradictions exceeds

end-time: 2023-02-14T19:04:20.185634+09:00

  ### SUMMARY ###
  time consumed = 0.031379 secs
  #clauses = 481
  #contras = 31
  #valids = 0
  #trials = 2007
  #max proof steps = 20
NIL
RUBBISH(5): (pc c35)

(L7-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L1-1)
RUBBISH(6): (p2c c35)

((L1-1 L2-1) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L7-1) (L3-2 L5-1))
RUBBISH(7): (pm c35)
[C35]
  depth                 = 7
  num of clauses        = 12  see (cids-of-proof cid)
  num of input clauses  = 6  see (inclauses-of-proof cid)
  num of input literals = 9  see (inliterals-of-proof cid)
  num of preds          = 2  see (preds-of-proof cid)
NIL

RUBBISH(13): (reportc (analyze-pcode))

kqc file             : kqc/path/graph201.kqc

  goals                = NIL
  *max-clauses*        = 1000
  *max-contradictions* = 30
  *max-trials*         = 100
  *max-steps*          = 100
  *timeout-sec*        = 10
  *enable-semantics*   = NIL

# of pcodes          : 10
16 (L9-1 L8-1 L7-1 L6-1 L5-1 L4-1 L2-3 L2-2 L2-1 L10-1 L1-1)
10 (L9-1 L8-1 L7-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L10-1 L1-1)
5 (L8-1 L7-1 L6-1 L5-1 L4-1 L2-3 L2-2 L2-1 L1-1)
3 (L8-1 L7-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L1-1)
2 (L9-1 L8-1 L6-1 L5-1 L4-1 L2-3 L2-2 L2-1 L10-1 L1-1)
2 (L9-1 L8-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L10-1 L1-1)
2 (L9-1 L6-1 L5-1 L4-1 L2-3 L2-2 L2-1 L10-1 L1-1)
2 (L7-1 L6-1 L5-1 L4-1 L2-3 L2-2 L2-1 L1-1)
1 (L9-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L10-1 L1-1)
1 (L7-1 L6-1 L5-1 L3-2 L3-1 L2-3 L2-2 L2-1 L1-1)
NIL

RUBBISH(15): (reportc (analyze-p2code))

kqc file             : kqc/path/graph201.kqc

  goals                = NIL
  *max-clauses*        = 1000
  *max-contradictions* = 30
  *max-trials*         = 100
  *max-steps*          = 100
  *timeout-sec*        = 10
  *enable-semantics*   = NIL

# of pcodes          : 10
16 ((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L4-1) (L2-3 L5-1) (L2-3 L6-1)
    (L2-3 L7-1) (L2-3 L8-1) (L2-3 L9-1))
10 ((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L7-1)
    (L2-3 L8-1) (L2-3 L9-1) (L3-2 L5-1))
5 ((L1-1 L2-1) (L2-1 L2-2) (L2-2 L4-1) (L2-3 L5-1) (L2-3 L6-1) (L2-3 L7-1)
   (L2-3 L8-1))
3 ((L1-1 L2-1) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L7-1) (L2-3 L8-1)
   (L3-2 L5-1))
2 ((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L4-1) (L2-3 L5-1) (L2-3 L6-1)
   (L2-3 L8-1) (L2-3 L9-1))
2 ((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L8-1)
   (L2-3 L9-1) (L3-2 L5-1))
2 ((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L4-1) (L2-3 L5-1) (L2-3 L6-1)
   (L2-3 L9-1))
2 ((L1-1 L2-1) (L2-1 L2-2) (L2-2 L4-1) (L2-3 L5-1) (L2-3 L6-1) (L2-3 L7-1))
1 ((L1-1 L2-1) (L10-1 L2-3) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L9-1)
   (L3-2 L5-1))
1 ((L1-1 L2-1) (L2-1 L2-2) (L2-2 L3-1) (L2-3 L6-1) (L2-3 L7-1) (L3-2 L5-1))
NIL

**** こっち
(require :gtrail)
(in-package :rubbish)
;(readkqc "kqc/path/graph201.kqc")
(readkqc "kqc/path/graph203.kqc")

(setq *max-clauses* 100)
 (pg (c1))


;; ccp2は同じp2codeをもつcidのリストつきのリスト
(defparameter ccp2 (classify-cid-by-p2code))

;sccp2はccp2のfirstの長さでソートしたもの。secondはcidのリスト
(defparameter sccp2 (sort-ccp2 ccp2))

;sp2は長さ順のp2codeのlist
(defparameter sp2 (loop for x in sccp2 collect (first x)))

;sccp2に番号をわりふる。cidのリストがついている
(defparameter sccp2n (numbering-sccp2 sccp2))

;sp2nは、p2codeに番号を割り振る。p2codeのみのリスト。
(defparameter sp2n (numbering-sccp2 sp2))

; amapはsccp2のp2codeのお隣り(arrow)map (p2code (p2c1 p2c2 ...))*
(defparameter amap (make-nnmap sccp2))

; amapのp2codeを番号に置き換えたもの
(defparameter mapn (map-in-number amap sccp2n))

; for print graph (in Julia or R), adjmap may prefered. so translate mapn to adjmap 
(defparameter adja (nnmap-to-adjmap mapn))
; revert edges of adja
(defparameter radja (loop for e in adja collect (list (second e)(first e))))

;; Rのため隣接行列用データをつくる

(defparameter adjm (conv-to-adjacent mapn))
(defparameter mjda (trans-mat adjm))

;; file に描く
(writeadjm "mjda.r" mjda)

;; then
rubbish/
mjda.r
mjda-to-graph.R

の状態で、
R
を起動し(大文字のR)

source("mjda-to-graph.R")
とすると、しばらくしてp2codeのグラフが表示される

-----------------------
#library(igraph)
source("adj203.r")
# 16 = sqrt(length(ad))
rgr = graph.adjacency(matrix(ad, ncol=16, nrow=16))
gr = simplify(rgr, remove.loop=F)
----------
quartz()
plot(gr)
----------------------
または
tkplot(gr)
--------


mapnの数字nから
　(nth n sp2n)でp2codeがわかる。
　(nth n sccp2n)でp2codeと対応するcidがわかる

どのpairが増えているのかはちょっとわかりにくい。

; analyze-p2code
(defparameter ap2 (analyze-p2code ))
(defparameter ap2a (analyze-p2code0 ))

(p2c-n p2c sccp2n) p2codeから番号
(n-p2c n sccp2n)   番号からp2code


★現在
(length (analyze-p2code)) == 10
(length (analyze-p2code0)) == 64
(length mapn) == 64

;mapnは全p2codeについての矢印情報。

;mapnのtargetが()のものの数
(defparameter tarnull (loop for x in mapn when (null (second x)) collect x))
tarnull
;((1 NIL) (3 NIL) (47 NIL) (49 NIL) (48 NIL) (63 NIL) (62 NIL) (61 NIL))

[]の数
 (length (car (lscova)))
;31
これらの[]のp2codeは


★この例では(length mapn) = 64。これは範囲をふやしてもかわらないのか?
いまのpgはmax-contradictions=30で終わっているので、これをふやしてみる

****

(p2cn-p  p2code sccp2n)

(find-next-p2codes nil sp2n)

数字とp2codeの対応表
 (loop for x in sccp2n collect (list (third x) (first x)))

これで数字におきかえてwnextの表をつくる

(p2c (wnext p2c))

