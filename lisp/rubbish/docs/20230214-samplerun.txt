20230214-samplerun

一行の途中で改行をいれたくないとき
(setq  *print-right-margin* 200)

;; do these
(require :gtrail)
(in-package :rubbish)
(readkqc "kqc/path/graph201.kqc")
;(readkqc "kqc/path/graph203.kqc")
;(readkqc "kqc/basic/basic004.kqc")

(setq *max-clauses* 250)
(setq *max-contradictions* 50)
;(setq *max-trials* 100)

(pg (c1))

;(defparameter ap2a (analyze-p2code0 ))
;(reportc ap2a)

;; ccp2は同じp2codeをもつcidのリストつきのリスト
(defparameter ccp2 (classify-cid-by-p2code))

;sccp2はccp2のfirstの長さでソートしたもの。secondはcidのリスト
(defparameter sccp2 (sort-ccp2 ccp2))

;sp2は長さ順のp2codeのlist
(defparameter sp2 (loop for x in sccp2 collect (first x)))

;sccp2に番号をわりふる。cidのリストがついている
(defparameter sccp2n (numbering-sccp2 sccp2))

;  (p2c-n p2c sccp2n) ;p2codeから番号
;  (n-p2c n sccp2n)   ;番号からp2code

;sp2nは、p2codeに番号を割り振る。p2codeのみのリスト。
(defparameter sp2n (numbering-sccp2 sp2))

; amapはsccp2のp2codeのお隣り(arrow)map (p2code (p2c1 p2c2 ...))*
(defparameter amap (make-nnmap sccp2))

; amapのp2codeを番号に置き換えたもの
(defparameter mapn (map-in-number amap sccp2n))


;; Rでのグラフ表示用(tkplotはよい)に隣接行列を作るなど
; for print graph (in Julia or R), adjmap may prefered. so translate mapn to adjmap 
(defparameter adja (nnmap-to-adjmap mapn))

;; 有向木の出力
(load "rubbish-digraph.lisp")
(defparameter dgmapn (make-p2graph mapn))
;(defparameter dgmapn (make-p2graph2 (length mapn) adja))
;(write-p2graph dgmapn "dgmapn.png")
(write-p2g dgmapn sccp2n "dgmapn.rep")

;;; almost over


; revert edges of adja
(defparameter radja (loop for e in adja collect (list (second e)(first e))))

;; Rのため隣接行列用データをつくる
(defparameter adjm (conv-to-adjacent mapn))
(defparameter mjda (trans-mat adjm))

;; file に描く
(writeadjm "mjda.r" mjda)

;; then
rubbish/
mjda.r
mjda-to-graph.R

の状態で、
R
を起動し(大文字のR)

source("mjda-to-graph.R")
とすると、しばらくしてp2codeのグラフが表示される

tkplotのLayoutでReingold-Tilfordを選ぶとツリーになるので、それをexportする。
epsになるので、GIMPでインポートしてから、
 1) rotateして逆さまにする。数字は読める向きのままになる。
 2)「名前をつけてエスクポート」でpdfとかpngとかjpgとかにする。pdfかpngのサイズはjpgより小さい。
　　(種類はメニューから選べ)
 2') quartzでplotの場合は、saveするとpdfになる。が、レイアウトが変えられないので、それでよい場合のみそうする。
   quartzだと画面が広いので、みやすいかもしれない。


p2codeとidとcidのリストの表示
; in ~/.sbclrc
(setq  *print-right-margin* 200)
(loop for x in sccp2n do (format t "~a ~a ~a~%" (third x)(second x)(first x)))


-----------------------
#library(igraph)
source("adj203.r")
# 16 = sqrt(length(ad))
rgr = graph.adjacency(matrix(ad, ncol=16, nrow=16))
gr = simplify(rgr, remove.loop=F)
----------
quartz()
plot(gr)
----------------------
または
tkplot(gr)
--------


mapnの数字nから
　(nth n sp2n)でp2codeがわかる。
　(nth n sccp2n)でp2codeと対応するcidがわかる

あるいは
(loop for x in sccp2n do (format t "~a ~a~%" (third x)(second x)))

どのpairが増えているのかはちょっとわかりにくい。

; analyze-p2code
(defparameter ap2 (analyze-p2code ))
(defparameter ap2a (analyze-p2code0 ))



★現在
(length (analyze-p2code)) == 10
(length (analyze-p2code0)) == 64
(length mapn) == 64

;mapnは全p2codeについての矢印情報。

;mapnのtargetが()のものの数
(defparameter tarnull (loop for x in mapn when (null (second x)) collect x))
tarnull
;((1 NIL) (3 NIL) (47 NIL) (49 NIL) (48 NIL) (63 NIL) (62 NIL) (61 NIL))

[]の数
 (length (car (lscova)))
;31
これらの[]のp2codeは


★この例では(length mapn) = 64。これは範囲をふやしてもかわらないのか?
いまのpgはmax-contradictions=30で終わっているので、これをふやしてみる

****

(p2cn-p  p2code sccp2n)

(find-next-p2codes nil sp2n)

数字とp2codeの対応表
 (loop for x in sccp2n collect (list (third x) (first x)))

これで数字におきかえてwnextの表をつくる

(p2c (wnext p2c))

