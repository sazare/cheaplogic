20230508-moveandfact

prev: 20230430-moveandfact.txt

対消滅はおかしいので、-Pをちゃんと書くべきだと思う。だから

(B')
1 -P(x,a)∀x
2 +P(1,a)
3 +P(3,a)∧-P(1,a)
4 +P(7,a)∧-P(3,a)

が正しいと思う。


この変数のある0の扱いはまた後に書く(20230304-studyofcontradiction.txt)が、まずは

(B2)
1 -P(1,a)
2 -P(2,a)
3 -P(3,a)
4 -P(4,a)
5 -P(5,a)
6 -P(6,a)
7 -P(7,a)
8 -P(8,a)
ここまでが初期状態Σ0で、aはどこにもない状態を示す
以下は時系列のfactで
10 +P(1,a)
11 +P(3,a)∧-P(1,a)
12 +P(7,a)∧-P(3,a)

これが1から3から7に移動するaを示す。

(実装は、rubbish-mujun.lisp, rubbish-mutat.lisp。20230312-conflict-disolver-lisp.txtも参照)
を考える

step1 fact 10が出現し、Σと10から、矛盾を探す。
　矛盾集合は{1,10}になる
　ここで、どちらかを消すと矛盾が解消できる。
　どちらの矛盾を消すかだが、この例の世界は、「古いfactは正しくない」世界なので
　両方のfactの発生時刻を比較し、古い方を消せば良い。
　このような矛盾の対処方法は、世界の成り立ちによるので、それがどう明記できるかを考えなくてはならない。
　
　その判定のための基本関数はrubbishのcommit 6461cd71cd9f3fe34994f195eaaa6ba954f70bc6で作成した。
isunitcid, isinputcidなど

　逆の場合としては、axiomは絶対に正しいという確信・前提のある場合もありそう。
今は、センサー/ロジックシステムなので、それはない。

　古い新しいを調べるために、clauseを作った時刻を調べたい。
　inputかどうかでは判定できない。

　あと、センサーから得たfactかどうかとか、センサーの信頼性とかあるかもしれない。
　Σ+fact⊢□が複数でたとき、それぞれの□について


*今(5/8)は、□からpcodeでlidのリストを作り、それを構成するcidを求めている(mujun-setのuniq-pcodesのあたり)が
　p2codeでなくてもよいかなと思っている。cidがわかればよいので・・・

*今(5/8)の段階では、cidの生まれた時刻はcidの数字でわかる。
　わざわざ別にproperty(:born-when)を持たせる必要があるだろうか?
　cidと誕生日は本質的に異なるような気がするので、あってもいいけど・・・
　将来、このいきさつを忘れたときに、cidから数字を取り出す処理を見て、それを誕生時刻だと解釈できるだろうか。
　cidの作り方が変わったらこれが問題になるかもしれない。
　そもそも、make-clauseでclauseに番号がはいっていると、cidがその番号になるから、誕生日と違う場合は簡単におこる。
  だから、born-whenは必要。
　注意: requireをしたりparam.lispをloadすると*born-when*がリセットされてしまう。cidとborn-whenが別になる。


★ Σに複数の□がある場合を考慮していたが、そのとき□同士が独立なら問題ないけど、混じっていたらわざわざ消す必要はあるのか
　また、factが複数clauseの場合は、mujun-setが複数になる?
　複数□があるというのは、factが1つでも□にいたる道が複数あるということ。factは残すので、消すcidは違うものになるかもしれない。同じなら二度は消せないので問題ない。

ここら辺はさらに例を作ってみないとなんとも。

ということで、今は
factが1個、□が複数でたら、それぞれで一つclauseを選び、全部消していくことにする。


0 -P(x,a)∀x
1 +P(1,a)
2 +P(3,a)∧-P(1,a)
3 +P(7,a)∧-P(3,a)
4 +P(7,a)








