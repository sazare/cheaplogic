20230503-unification

see: 20230430-moveandfact

>>
証明は、操作の順序があり、それに依存して最小の情報を個別に作らない。
unificationアルゴリズムもそうで、部分的な代入操作の順序に最適化を委ねている

それを個別に取り出すのは、動的なものから断片を切り出すようなもので、結構難しいという気がする。

表現上の操作で、最適なものをみつけるのはややこしいという話。
<<

unificationについては、
1) par代入を考えることで、代入表現の正規化みたいなことをして
2) par代入間の合成を考えて、unificationでのdisagreement set 処理の順序を無視するようにした

これでやりたかったのば、「unificationでどういう順番で同一化していっても、最終的に求められるmguは同値になる」ということだった(証明できていないが、並列計算の場合、同値かどうかはソートして決めればいいのかなと思う。p2codeやpcodeでやったみたいに。それでも同じにならない場合があるのかどうかが証明の必要なことか)



一方で、実際の処理は、並列に実行できないので、処理の性能が遅くなる。


