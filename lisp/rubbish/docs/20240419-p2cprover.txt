20240419-p2cprover.txt


ΣのG0レベルの証明をp2codeに写像すると、ループが1回だけに射影されたものになるので、証明全体が有限のp2codeに落ちる。
　(これがうまくいくのは、rubbishが、すべてのliteralにlid、clauseにcidをつけて、区別しているからだろう)

これを使って、G1レベルの証明をガイドできないか。あるいは、なんらかの証明を作りだすプログラムぽいものを作れないか。

まず、input clauseのすべてのpairについてmguを求める。
(readkqc ...)
(defparameter mm (mguofΣ))

mmは<L1:L2>の集合になる。
ここで、(L1:L2)で、L1とL2をresolveしたresolutionを表すことにした。

mmはmguの集合なのでinsideなpairは含まない。これを解除するとしたら
　1) mguでなくdisagree を使う
　　　(disagree '(x y) 'x '(f x) ()  #'collect)でdisagree setを求められるようだ(rubbish-unif.lisp)
　　つまり、mguではinsideを含む情報がとりだせないが、disagreeなら取り出せる。それを圧縮しないので、安全に処理できる。

　2) Σの書き方で、insideがないようにできる。
　　　というのも、もしも潜在的なinsideがあった場合、それが顕在化するのは、□になるまでmguを圧縮したときの話で、input clauseでのpairのmguをもとめそのままにしているならば、変数の書き方をうまくすることで、insideが中和できる。(neutralized)。これはFlowのやっていたことかも。

用語・記法
　・<L1:L2>  L1と¬L2のmgu。これは¬L1とL2のmguに等しいので、¬をつけず<L1:L2>と書く。だから、符号は逆になっている。
　・(L1:L2) (rubbishのlidやcidの方法を前提とすると) L1とL2はΣ全体でuniqueなので、L1とL2を指定すると1つのresolutionが決まる。そこで(L1: L2)でそのresolventを表す。この書き方だと、証明は lidをleafにもつバイナリツリーになる。renameも考慮すると、バイナリの部分の間にrenameの枝がのびている形になるだろう。
　・G0レベル 命題算レベルということ。
　・G1レベル 述語算レベルということ。
　・(情報を)安全に取り出す　　unificationではinsideは禁止しているが、insideで起こる無限ループ(unification algorithmの問題)を回避して安全に処理すること。　
　・圧縮　証明全体に散らばるmguは、証明の一番下のclause(□の場合に注目しているが)を考えると、証明全体のmguを合成してものになる。この合成をmguの圧縮と呼ぶ。
　・中和　insideによって禁止されたmguがもつ情報を取り出すため、(圧縮せず)input clauseの形まま情報を取り出すとき、insideを中和していると考える。
　・rubbish方式　clauseとそのliteralそれぞれにidをつける。cid, lid。すべてのclauseの変数は異なるように名前をつける。
　　　これはresolutionでclauses間に共通の変数を持たないという前提を満たすため、resolutionのたびにrenameすることをやめ、clauseを作るときにすべての変数の名前を変えている、その処理とその効果をDVCと呼ぶ。(Disjoint Variables Condition)
　　　これによって、ひとつの変数は、ひとつのclauseに属することになり、変数名からcidを求められるようになる。


とりあえずmguで考えるとして(mguofΣ)はその環境にある全literalsの逆符号の述語記号についてpairを作り、そのmguを求める。
このmgu集合は、(x y z) ← (t1 t2 t3)の形をしている。
各mguには述語記号が対応しているが、その述語記号を省略しても、変数名からclauseがわかるので、mguだけで情報が欠落していないと考えられる。
これをmmと呼ぶ。

exploreでは、このmgu集合から次のような加工をしたm1を作っている。
　1) (x y)←(a b)を変数ごとにわけて ((x←a)(y←b))とする
　2) (x y)←(x b)の変化しない変数を除去して((y←b))とする

こうして分解されたm1は、プログラムに近いが、どうもmmのように変数のtupleが、述語リテラルによる同時というか入出力の組み、つまり普遍性を反映しているのであり、プログラムとしてはこちらのほうが役に立つのではないかという気がしている。

m1の場合、どの変数が同じclauseに属しているのかに着目して、変数の値のpushや遅延を行う必要があるのかなと思う。

だんだん面倒になってきたので、これは一時保留。


