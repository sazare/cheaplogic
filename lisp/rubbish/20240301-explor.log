

(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/2on2001.kqc")
;(defparameter *max-clauses* 10000)
;(defparameter *max-trials* 1000)
;(defparameter *max-steps* 1000)
;(defparameter *timeout-sec* 10)
(play-prover-gtrail '(c1) fkname)

(mds)
(oph* (car (lscova)) "explore.txt")


(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/2on2001.kqc")
(readkqc fkname)
(bcs)

;;; これは2つの矛盾がでて問題なさそう

;;RとSの間にUを入れて、痕跡を隠した
(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/2on2002.kqc")
(play-prover-gtrail '(c1) fkname)

(mds)
(oph* (car (lscova)) "explore.txt")


(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/2on2002.kqc")
(readkqc fkname)
(bcs)

;; 矛盾x2がでてしまう


;; cakeのように2つのパスが必要にしてみた
(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/2on2003.kqc")
(play-prover-gtrail '(c1) fkname)

(mds)
(oph* (car (lscova)) "explore.txt")

RUBBISH(7): (lscova)

((C18 C19) NIL)
RUBBISH(8): (extract-inf 'c18 '(c1) '(z.148))
(:TUPLE (F C (G B C)))
RUBBISH(9): (extract-inf 'c19 '(c1) '(z.148))
(:TUPLE (F C (G A C)))

(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/2on2003.kqc")
(readkqc fkname)
(bcs)

;矛盾が二個できる??

linearでないproofを探している


*** input pairs and mgu of them
;as rubbish-explore.lisp

(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/cake/cake006-sim1-4.kqc")
(readkqc fkname)
 (defparameter mm (mguofΣ))
(loop for x in mm do (format t "~a~%" x))

これがもとの結果で
((CAKE L7-2 L1-1) ((X.149 Z.148) (X.149 (OVEN X.149))))
((EGGYELLOW L4-1 L8-1) ((X.150 Y.151) (YELLOW Y.151)))
((MIXPR1 L8-3 L9-1) ((X.150 Y.151 X.152 Y.153) (X.152 Y.153 X.152 Y.153)))
((EGGWHITE L3-1 L10-1) ((X.154 Y.155 Z.156 W.157) (WHITE Y.155 Z.156 W.157)))
((SUGARP L2-1 L8-2) ((X.150 Y.151) (X.150 SUGAR)))
((SUGARP L2-1 L10-2) ((X.154 Y.155 Z.156 W.157) (X.154 SUGAR Z.156 W.157)))
((MIXPR2 L10-3 L11-1) ((X.154 Y.155 Z.156 W.157 X.158 Y.159) (X.158 Y.159 Z.156 W.157 X.158 Y.159)))
((MIX1 L9-2 L12-1) ((X.152 Y.153 X.160 Y.161) (X.152 Y.153 (MX1 X.152 Y.153) Y.161)))
((SIFTED L5-1 L12-2) ((X.160 Y.161) (X.160 RICEFLAUR)))
((MIXPR3 L12-3 L13-1) ((X.160 Y.161 X.162 Y.163) (X.162 Y.163 X.162 Y.163)))
((D1 L13-2 L14-1) ((X.162 Y.163 X.164 Y.165) (X.162 Y.163 (DO1 X.162 Y.163) Y.165)))
((MILKP L6-1 L14-2) ((X.164 Y.165) (X.164 MILK)))
((MIXPR4 L14-3 L15-1) ((X.164 Y.165 X.166 Y.167) (X.166 Y.167 X.166 Y.167)))
((D2 L15-2 L16-1) ((X.166 Y.167 X.168 Y.169) (X.166 Y.167 (DO2 X.166 Y.167) Y.169)))
((MELENGE L11-2 L16-2) ((X.158 Y.159 X.168 Y.169) (X.158 Y.159 X.168 (MEL X.158 Y.159))))
((MIXPR5 L16-3 L17-1) ((X.168 Y.169 X.170 Y.171) (X.170 Y.171 X.170 Y.171)))
((DOUGH L17-2 L18-1) ((X.170 Y.171 X.172) (X.170 Y.171 (DOU X.170 Y.171))))
((BAKEPR L18-2 L7-1) ((X.172 X.149) (X.149 X.149)))
((BAKEPR (L18-2) (L7-1)) ((X.172 X.149) (X.149 X.149)))

ここからx←xを除いたものが今の結果

((CAKE L7-2 L1-1) ((Z.148) ((OVEN X.149))))
((EGGYELLOW L4-1 L8-1) ((X.150) (YELLOW)))
((MIXPR1 L8-3 L9-1) ((Y.151 X.150) (Y.153 X.152)))
((EGGWHITE L3-1 L10-1) ((X.154) (WHITE)))
((SUGARP L2-1 L8-2) ((Y.151) (SUGAR)))
((SUGARP L2-1 L10-2) ((Y.155) (SUGAR)))
((MIXPR2 L10-3 L11-1) ((Y.155 X.154) (Y.159 X.158)))
((MIX1 L9-2 L12-1) ((X.160) ((MX1 X.152 Y.153))))
((SIFTED L5-1 L12-2) ((Y.161) (RICEFLAUR)))
((MIXPR3 L12-3 L13-1) ((Y.161 X.160) (Y.163 X.162)))
((D1 L13-2 L14-1) ((X.164) ((DO1 X.162 Y.163))))
((MILKP L6-1 L14-2) ((Y.165) (MILK)))
((MIXPR4 L14-3 L15-1) ((Y.165 X.164) (Y.167 X.166)))
((D2 L15-2 L16-1) ((X.168) ((DO2 X.166 Y.167))))
((MELENGE L11-2 L16-2) ((Y.169) ((MEL X.158 Y.159))))
((MIXPR5 L16-3 L17-1) ((Y.169 X.168) (Y.171 X.170)))
((DOUGH L17-2 L18-1) ((X.172) ((DOU X.170 Y.171))))
((BAKEPR L18-2 L7-1) ((X.172) (X.149)))

これからz.148の行方をたどれる

z.148<-(oven x149)
z.149<-x.172
x.172<-(dou x.170 y.171)
x.170<-x.168
y.171<-x.169
x.168<-(do2 x.166 x.167)
x.169<-(mel x.158 y.159)

;; inputで
;; 変数のリストを作る
 (defparameter vs (allvars mm))
;; (assoc 'x.150 mm)
;; で(x.150 xxx)がでる


★
; mguをパラレルでなく1:1にするのがbreak-mgu*
mmから1mguを作ってprint-mmで表示すると
input のpairのmguが変数単位で確認できる
この変数のつながりは、証明の情報を示しているので
extract-mguが得られることがわかる。

もしも繋がっていなければ、extractできないはず

(setq 1mgu (break-mgu* mm))
(print-mm 1mgu)
Z.148 (OVEN X.149)
X.150 YELLOW
Y.151 Y.153
X.150 X.152
X.154 WHITE
Y.151 SUGAR
Y.155 SUGAR
Y.155 Y.159
X.154 X.158
X.160 (MX1 X.152 Y.153)
Y.161 RICEFLAUR
Y.161 Y.163
X.160 X.162
X.164 (DO1 X.162 Y.163)
Y.165 MILK
Y.165 Y.167
X.164 X.166
X.168 (DO2 X.166 Y.167)
Y.169 (MEL X.158 Y.159)
Y.169 Y.171
X.168 X.170
X.172 (DOU X.170 Y.171)
X.172 X.149
NIL

* goal varはz.148

あれ? x.149がない

この例では、あいまいさなく情報がとれてしまう
ルーブがない

そのように書いたのではあるが

ルーブがありf^nの形になるときはどうなのか

p2codeの課題

1) □のp2codeから、input clauseが使われたかどうかだけがわかるので、複数回使われたものはわからない。
　つまり、複数回使う可能性のあるものがわかれば、L1の証明を作るのに役立つ

共通

(defparameter mm (mguofΣ))
(defparameter m1 (break-mgu* mm))
(print-mm m1)
;(defparameter vs (allvars mm))


;;; cakeの例　ループなし
(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/cake/cake006-sim1-4.kqc")
(readkqc fkname)
(pcs)

(defparameter zz (trackvars '(z.148)))
(print-mm zz)


;; simple inside はどうなるか



(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/howinside.kqc")
(readkqc fkname)
(pcs)

(defparameter zz (trackvars '(z.148 z.149)))
(print-mm zz)

結果
C1: 1 (X.148 Z.149) ((- P X.148 Z.149))
C2: 2 NIL ((+ P 1 1))
C3: 3 (X.150 Y.151) ((- P X.150 Y.151) (+ P (S X.150) (M X.150 Y.151)))
から
Z.149 1
Z.149 (M X.150 Y.151)
X.150 1
Y.151 1

** inputしかないので extract-infは使えない!!

ここから得られるのは
z.149 ← 1
z.q49 ← (m 1 1)
のみで、ループはできていない

ここで


(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/noinside.kqc")
(readkqc fkname)
(pcs)
(defparameter zz (trackvars '(z.148 z.149)))
(print-mm zz)

結果
C1: 1 (X.148 Z.149) ((- P X.148 Z.149))
C2: 2 NIL ((+ P 1 1))
C3: 3 (X.150 Y.151) ((- P X.150 Y.151) (+ Q (S X.150) (M X.150 Y.151)))
C4: 4 (X.152 Y.153) ((- Q X.152 Y.153) (+ P X.152 Y.153))
から
Z.149 1
Z.149 Y.153
Y.153 (M X.150 Y.151)
X.150 1
X.150 X.152
X.152 (S X.150)
X.148 1
X.152 X.148
X.148 X.152
Y.151 1
Y.151 Y.153

これは整理すると以下のとおり

Z.149←1
Z.149←y.153

y.153←(m x.150 y.151)

x.150←1
x.150←x.152

x.152←(s x.150)
x.152←x.148
discard x.148 x.152  ∵ x.148はinputだから

y.151←1
y.151←y.153

変数にcidを割り振る

c1.Z.149←1
c1.Z.149←c4.y.153

c4:
c4.y.153←(m c3.x.150 c3.y.151)

c3:
c3.x.150←1
c3.x.150←c4.x.152

c4
c4.x.152←(s c3.x.150)
c4.x.152←c1.x.148
discard x.148 x.152  ∵ x.148はinputだから

c3:
c3.y.151←1
c3.y.151←c4.y.153

変数名にcid連想するものをつけてみる


(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/noinside.kqc")
(readkqc fkname)
(pcs)
(defparameter zz (trackvars '(x1.148 z1.149)))
(print-mm zz)

結果
C1: 1 (X1.148 Z1.149) ((- P X1.148 Z1.149))
C2: 2 NIL ((+ P 1 1))
C3: 3 (X3.150 Y3.151) ((- P X3.150 Y3.151) (+ Q (S X3.150) (M X3.150 Y3.151)))
C4: 4 (X4.152 Y4.153) ((- Q X4.152 Y4.153) (+ P X4.152 Y4.153))
から
X1.148 1
X1.148 X4.152
X4.152 (S X3.150)
X3.150 1
X3.150 X4.152
Z1.149 1
Z1.149 Y4.153
Y4.153 (M X3.150 Y3.151)
Y3.151 1
Y3.151 Y4.153

これをみると、必要なmguはもとまっているようだ。
cidとvarの関連付けのadhocはともかく。

このmgu1で必要な情報はありそうなので、これをプログラムとみなして実行するのはどうすればよいか

x1.148が2の場合について考える
A←Bのルールがあるとき、左のBが定義されたら、計算が発動され
Bの値がAに設定される。

X1.148 1
適用不可

(- P 2 z1.149)

{x1.148=2}

X1.148 X4.152
　これは x.4.152←x1.148になる。∵ x.148はinputだから

x.152←x.148
から
{x4.152=2}
となる。
x4.152が定義されたので

X3.150 X4.152
から
{x3.150=2}
となり

X3.150 1
は、unify失敗でスキップし

y4.153←(m x3.150 y3.151)
の右辺半分定義されているのでこれが選ばれる

{y4.153=(m 2 y3.151)}

の評価をするために、y3.151の値をさがす
Y3.151 1
はunify失敗

Y3.151←Y4.153
なので、
y3.151のmguをさがすと
y3.151←1
y3.151←(m x3.150 y3.151)
がある
右辺のx3.150を解決するために
X4.152←(S X3.150)
X4.152=2=(s x3.150)
を解くと (逆関数が必要なので、この書き方はおあずけにする)
x3.150=1となり
mguから
x.150←1
と
unifyできて

x3.150=


Z1.149 1
Z1.149 Y4.153

Y4.153 (M X3.150 Y3.151)

Y3.151 1
Y3.151 Y4.153

まず、x1.149に2を設定すると


;;; 改版 noinside2.kqc

; 逆関数のいらない書き方をしてみる
; 場合わけも必要かな

(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/noinside2.kqc")
(readkqc fkname)
(pcs)
(defparameter zz (trackvars '(x1.148 z1.149)))
(print-mm zz)

結果C1: 1 (X1.148 Z1.149) ((- Q X1.148 Z1.149))
C2: 2 (X2.150) ((- EQ X2.150 1) (+ P 1 1))
C3: 3 (X3.151 Y3.152) ((+ EQ X3.151 1) (- P (D X3.151) Y3.152) (+ Q X3.151 (M X3.151 Y3.152)))
C4: 4 (W4.153 V4.154) ((- Q W4.153 V4.154) (+ P W4.153 V4.154))
から
X1.148 X3.151
X3.151 X2.150
W4.153 (D X3.151)
X3.151 W4.153
X2.150 X3.151
W4.153 X3.151
Z1.149 (M X1.148 Y3.152)
Y3.152 V4.154
V4.154 (M W4.153 Y3.152)

これをもとに (- Q 2 z1.149)の反証を作ってみる。

(- Q 2 z1.149)から
{x1.148=2}となり

x3.151←x1.148から
{x3.151=2}となる

w4.153=(d x3.151)から
w4.153=(d 2) = 1となる

w4.153←x3.151を
x3.151←w4.153とし
x3.151=1となる

***
(- eq x2.150 1)はmguに
x2.150←1 if (not (eq x2.150 1))
(+ eq x2.150 1)はmguに
x3.151←1 if (eq x2.150 1)
みたいにできたら実行できるかも
****

すくなくとも証明のガイドができればいいので

x3.151が決まった今

X3.151 X2.150
X3.151 W4.153
X2.150 X3.151

から
x2.150←x3.151
x4.153←x3.151
と
x2.150←x3.151

のx3.151に1を代入したものが候補となりこれを実行したあとにC2とC3を評価する
そのとき、真となるliteralがあったらそのclauseは捨てる(先に進めても矛盾できないから)
この場合

c2 (-EQ 1 1) (+ P 1 1)
c3 (+EQ 1 1) (-P (D 1) Y3.152) (+ Q 1 (M 1 Y3.152)))

となり、
(+EQ 1 1)は真なので、c2だけが残る

(+ P 1 1)となる

もしもひとつにならなかったら、並行して実行していくことになるのかなあ★
ここで(+ P 1 1)の相手がいない。


* z1.149 = (m x1.148 y3.151)


;; c

(require :gtrail)
(in-package :rubbish)
(defparameter fkname "kqc/explore/noinside3.kqc")
(readkqc fkname)
(pcs)
(defparameter zz (trackvars '(x1.148 z1.149)))
(print-mm zz)

結果

C1: 1 (X1.148 Z1.149) ((- P X1.148 Z1.149))
C2: 2 (W2.150 V2.151) ((+ P 1 1))
C3: 3 (X3.152 Y3.153) ((+ P X3.152 Y3.153) (- Q X3.152 Y3.153))
C4: 4 (X4.154 Y4.155) ((- P (D X4.154) Y4.155) (+ Q X4.154 (M X4.154 Y4.155)))

から

X1.148 1
X1.148 X3.152
X3.152 (D X4.154)
X3.152 X4.154
X4.154 X3.152
Z1.149 1
Z1.149 Y3.153
Y3.153 Y4.155
Y3.153 (M X3.152 Y4.155)
Y4.155 Y3.153


X1.148<-2

X3.152←X1.148　から
X3.152←2

X3.152の右は
X4.154 X3.152
Y3.153 (M X3.152 Y4.155)

から
X4.154 2
Y3.153 (M 2 Y4.155)

この中の
Y4.155の左で
Y4.155 Y3.153

から

Y3.153の左で

Y3.153 Y4.155
Y3.153 (M X3.152 Y4.155)

から

Y4.155 Y3.153は
Y4.155 (M X3.152 Y4.155)
Y3.153 (M X3.152 Y4.155)

のいずれにせよ
になるので (M 2 Y4.155)

Y4.155から


















